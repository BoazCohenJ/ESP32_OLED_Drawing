{"ast":null,"code":"import React from 'react';\nconst getCoordinates = index => ({\n  x: index % 128,\n  y: Math.floor(index / 128)\n});\nconst getIndex = (x, y) => y * 128 + x;\nconst bucketFill = (startIndex, pixels) => {\n  const targetColor = pixels[startIndex]; // Color we're replacing\n\n  // If target is already filled (white), don't do anything\n  if (targetColor === true) return [];\n  const width = 128;\n  const height = 64;\n  const stack = [startIndex];\n  const filledPoints = [];\n  const visited = new Set();\n  while (stack.length > 0) {\n    const currentIndex = stack.pop();\n    if (visited.has(currentIndex)) continue;\n    visited.add(currentIndex);\n\n    // If this pixel doesn't match the target color, skip it\n    if (pixels[currentIndex] !== targetColor) continue;\n    filledPoints.push(currentIndex);\n    const {\n      x,\n      y\n    } = getCoordinates(currentIndex);\n\n    // Check 4 neighboring pixels (up, right, down, left)\n    const neighbors = [{\n      dx: 0,\n      dy: -1\n    },\n    // up\n    {\n      dx: 1,\n      dy: 0\n    },\n    // right\n    {\n      dx: 0,\n      dy: 1\n    },\n    // down\n    {\n      dx: -1,\n      dy: 0\n    } // left\n    ];\n    for (const {\n      dx,\n      dy\n    } of neighbors) {\n      const newX = x + dx;\n      const newY = y + dy;\n\n      // Check if the new coordinates are within the grid bounds\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n        const neighborIndex = getIndex(newX, newY);\n        if (!visited.has(neighborIndex) && pixels[neighborIndex] === targetColor) {\n          stack.push(neighborIndex);\n        }\n      }\n    }\n  }\n  return filledPoints;\n};\nconst BucketFillMode = ({\n  isActive,\n  onPixelUpdate\n}) => {\n  const handleFill = (index, pixels) => {\n    if (!isActive) return;\n    const pointsToFill = bucketFill(index, pixels);\n    if (pointsToFill.length > 0) {\n      onPixelUpdate(prev => {\n        const newPixels = [...prev];\n        pointsToFill.forEach(idx => {\n          newPixels[idx] = true; // Always set to true instead of toggling\n        });\n        return newPixels;\n      });\n      return pointsToFill;\n    }\n    return [];\n  };\n  return {\n    handleFill,\n    modeName: 'Bucket Fill',\n    isActive\n  };\n};\n_c = BucketFillMode;\nexport default BucketFillMode;\nvar _c;\n$RefreshReg$(_c, \"BucketFillMode\");","map":{"version":3,"names":["React","getCoordinates","index","x","y","Math","floor","getIndex","bucketFill","startIndex","pixels","targetColor","width","height","stack","filledPoints","visited","Set","length","currentIndex","pop","has","add","push","neighbors","dx","dy","newX","newY","neighborIndex","BucketFillMode","isActive","onPixelUpdate","handleFill","pointsToFill","prev","newPixels","forEach","idx","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/BucketFillMode.jsx"],"sourcesContent":["import React from 'react';\r\n\r\nconst getCoordinates = (index) => ({\r\n  x: index % 128,\r\n  y: Math.floor(index / 128)\r\n});\r\n\r\nconst getIndex = (x, y) => y * 128 + x;\r\n\r\nconst bucketFill = (startIndex, pixels) => {\r\n  const targetColor = pixels[startIndex]; // Color we're replacing\r\n  \r\n  // If target is already filled (white), don't do anything\r\n  if (targetColor === true) return [];\r\n  \r\n  const width = 128;\r\n  const height = 64;\r\n  const stack = [startIndex];\r\n  const filledPoints = [];\r\n  const visited = new Set();\r\n  \r\n  while (stack.length > 0) {\r\n    const currentIndex = stack.pop();\r\n    \r\n    if (visited.has(currentIndex)) continue;\r\n    visited.add(currentIndex);\r\n    \r\n    // If this pixel doesn't match the target color, skip it\r\n    if (pixels[currentIndex] !== targetColor) continue;\r\n    \r\n    filledPoints.push(currentIndex);\r\n    \r\n    const { x, y } = getCoordinates(currentIndex);\r\n    \r\n    // Check 4 neighboring pixels (up, right, down, left)\r\n    const neighbors = [\r\n      { dx: 0, dy: -1 }, // up\r\n      { dx: 1, dy: 0 },  // right\r\n      { dx: 0, dy: 1 },  // down\r\n      { dx: -1, dy: 0 }  // left\r\n    ];\r\n    \r\n    for (const { dx, dy } of neighbors) {\r\n      const newX = x + dx;\r\n      const newY = y + dy;\r\n      \r\n      // Check if the new coordinates are within the grid bounds\r\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\r\n        const neighborIndex = getIndex(newX, newY);\r\n        if (!visited.has(neighborIndex) && pixels[neighborIndex] === targetColor) {\r\n          stack.push(neighborIndex);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  return filledPoints;\r\n};\r\n\r\nconst BucketFillMode = ({ isActive, onPixelUpdate }) => {\r\n  const handleFill = (index, pixels) => {\r\n    if (!isActive) return;\r\n    \r\n    const pointsToFill = bucketFill(index, pixels);\r\n    if (pointsToFill.length > 0) {\r\n      onPixelUpdate(prev => {\r\n        const newPixels = [...prev];\r\n        pointsToFill.forEach(idx => {\r\n          newPixels[idx] = true; // Always set to true instead of toggling\r\n        });\r\n        return newPixels;\r\n      });\r\n      \r\n      return pointsToFill;\r\n    }\r\n    \r\n    return [];\r\n  };\r\n\r\n  return {\r\n    handleFill,\r\n    modeName: 'Bucket Fill',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default BucketFillMode;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}