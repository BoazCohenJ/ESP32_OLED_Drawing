{"ast":null,"code":"import React from 'react';\nconst BucketFillMode = ({\n  isActive,\n  onPixelUpdate,\n  drawColor = true\n}) => {\n  const handleFill = (index, pixels) => {\n    const targetColor = pixels[index];\n\n    // If we're already on the color we want to fill with, do nothing\n    if (targetColor === drawColor) return;\n    const newPixels = [...pixels];\n    const stack = [index];\n    const width = 128;\n    const height = 64;\n    while (stack.length > 0) {\n      const currentIndex = stack.pop();\n      if (newPixels[currentIndex] === targetColor) {\n        newPixels[currentIndex] = drawColor;\n        const x = currentIndex % width;\n        const y = Math.floor(currentIndex / width);\n\n        // Check adjacent pixels (4-way connectivity)\n        if (x > 0 && newPixels[getIndex(x - 1, y)] === targetColor) {\n          stack.push(getIndex(x - 1, y));\n        }\n        if (x < width - 1 && newPixels[getIndex(x + 1, y)] === targetColor) {\n          stack.push(getIndex(x + 1, y));\n        }\n        if (y > 0 && newPixels[getIndex(x, y - 1)] === targetColor) {\n          stack.push(getIndex(x, y - 1));\n        }\n        if (y < height - 1 && newPixels[getIndex(x, y + 1)] === targetColor) {\n          stack.push(getIndex(x, y + 1));\n        }\n      }\n    }\n    onPixelUpdate(() => newPixels);\n  };\n  const getIndex = (x, y) => y * 128 + x;\n  return {\n    handleFill,\n    modeName: 'Bucket Fill',\n    isActive\n  };\n};\n_c = BucketFillMode;\nexport default BucketFillMode;\nvar _c;\n$RefreshReg$(_c, \"BucketFillMode\");","map":{"version":3,"names":["React","BucketFillMode","isActive","onPixelUpdate","drawColor","handleFill","index","pixels","targetColor","newPixels","stack","width","height","length","currentIndex","pop","x","y","Math","floor","getIndex","push","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/BucketFillMode.jsx"],"sourcesContent":["import React from 'react';\r\n\r\nconst BucketFillMode = ({ isActive, onPixelUpdate, drawColor = true }) => {\r\n  const handleFill = (index, pixels) => {\r\n    const targetColor = pixels[index];\r\n    \r\n    // If we're already on the color we want to fill with, do nothing\r\n    if (targetColor === drawColor) return;\r\n    \r\n    const newPixels = [...pixels];\r\n    const stack = [index];\r\n    const width = 128;\r\n    const height = 64;\r\n    \r\n    while (stack.length > 0) {\r\n      const currentIndex = stack.pop();\r\n      \r\n      if (newPixels[currentIndex] === targetColor) {\r\n        newPixels[currentIndex] = drawColor;\r\n        \r\n        const x = currentIndex % width;\r\n        const y = Math.floor(currentIndex / width);\r\n        \r\n        // Check adjacent pixels (4-way connectivity)\r\n        if (x > 0 && newPixels[getIndex(x-1, y)] === targetColor) {\r\n          stack.push(getIndex(x-1, y));\r\n        }\r\n        if (x < width - 1 && newPixels[getIndex(x+1, y)] === targetColor) {\r\n          stack.push(getIndex(x+1, y));\r\n        }\r\n        if (y > 0 && newPixels[getIndex(x, y-1)] === targetColor) {\r\n          stack.push(getIndex(x, y-1));\r\n        }\r\n        if (y < height - 1 && newPixels[getIndex(x, y+1)] === targetColor) {\r\n          stack.push(getIndex(x, y+1));\r\n        }\r\n      }\r\n    }\r\n    \r\n    onPixelUpdate(() => newPixels);\r\n  };\r\n  \r\n  const getIndex = (x, y) => y * 128 + x;\r\n  \r\n  return {\r\n    handleFill,\r\n    modeName: 'Bucket Fill',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default BucketFillMode;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,cAAc,GAAGA,CAAC;EAAEC,QAAQ;EAAEC,aAAa;EAAEC,SAAS,GAAG;AAAK,CAAC,KAAK;EACxE,MAAMC,UAAU,GAAGA,CAACC,KAAK,EAAEC,MAAM,KAAK;IACpC,MAAMC,WAAW,GAAGD,MAAM,CAACD,KAAK,CAAC;;IAEjC;IACA,IAAIE,WAAW,KAAKJ,SAAS,EAAE;IAE/B,MAAMK,SAAS,GAAG,CAAC,GAAGF,MAAM,CAAC;IAC7B,MAAMG,KAAK,GAAG,CAACJ,KAAK,CAAC;IACrB,MAAMK,KAAK,GAAG,GAAG;IACjB,MAAMC,MAAM,GAAG,EAAE;IAEjB,OAAOF,KAAK,CAACG,MAAM,GAAG,CAAC,EAAE;MACvB,MAAMC,YAAY,GAAGJ,KAAK,CAACK,GAAG,CAAC,CAAC;MAEhC,IAAIN,SAAS,CAACK,YAAY,CAAC,KAAKN,WAAW,EAAE;QAC3CC,SAAS,CAACK,YAAY,CAAC,GAAGV,SAAS;QAEnC,MAAMY,CAAC,GAAGF,YAAY,GAAGH,KAAK;QAC9B,MAAMM,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACL,YAAY,GAAGH,KAAK,CAAC;;QAE1C;QACA,IAAIK,CAAC,GAAG,CAAC,IAAIP,SAAS,CAACW,QAAQ,CAACJ,CAAC,GAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,KAAKT,WAAW,EAAE;UACxDE,KAAK,CAACW,IAAI,CAACD,QAAQ,CAACJ,CAAC,GAAC,CAAC,EAAEC,CAAC,CAAC,CAAC;QAC9B;QACA,IAAID,CAAC,GAAGL,KAAK,GAAG,CAAC,IAAIF,SAAS,CAACW,QAAQ,CAACJ,CAAC,GAAC,CAAC,EAAEC,CAAC,CAAC,CAAC,KAAKT,WAAW,EAAE;UAChEE,KAAK,CAACW,IAAI,CAACD,QAAQ,CAACJ,CAAC,GAAC,CAAC,EAAEC,CAAC,CAAC,CAAC;QAC9B;QACA,IAAIA,CAAC,GAAG,CAAC,IAAIR,SAAS,CAACW,QAAQ,CAACJ,CAAC,EAAEC,CAAC,GAAC,CAAC,CAAC,CAAC,KAAKT,WAAW,EAAE;UACxDE,KAAK,CAACW,IAAI,CAACD,QAAQ,CAACJ,CAAC,EAAEC,CAAC,GAAC,CAAC,CAAC,CAAC;QAC9B;QACA,IAAIA,CAAC,GAAGL,MAAM,GAAG,CAAC,IAAIH,SAAS,CAACW,QAAQ,CAACJ,CAAC,EAAEC,CAAC,GAAC,CAAC,CAAC,CAAC,KAAKT,WAAW,EAAE;UACjEE,KAAK,CAACW,IAAI,CAACD,QAAQ,CAACJ,CAAC,EAAEC,CAAC,GAAC,CAAC,CAAC,CAAC;QAC9B;MACF;IACF;IAEAd,aAAa,CAAC,MAAMM,SAAS,CAAC;EAChC,CAAC;EAED,MAAMW,QAAQ,GAAGA,CAACJ,CAAC,EAAEC,CAAC,KAAKA,CAAC,GAAG,GAAG,GAAGD,CAAC;EAEtC,OAAO;IACLX,UAAU;IACViB,QAAQ,EAAE,aAAa;IACvBpB;EACF,CAAC;AACH,CAAC;AAACqB,EAAA,GA/CItB,cAAc;AAiDpB,eAAeA,cAAc;AAAC,IAAAsB,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}