{"ast":null,"code":"import React, { useMemo } from 'react';\nimport { getCoordinates, drawLine } from './utils';\n\n// Pre-calculate brush patterns for common sizes\nconst BRUSH_PATTERNS = {};\n\n// Initialize brush patterns\nfor (let size = 1; size <= 5; size++) {\n  BRUSH_PATTERNS[size] = {};\n}\nconst FreeformMode = ({\n  isActive,\n  onPixelUpdate,\n  brushSize,\n  drawColor = true\n}) => {\n  // Get or calculate brush pattern - much more efficient\n  const getBrushPattern = (size, centerX, centerY) => {\n    // Cache key based on position\n    const key = `${centerX},${centerY}`;\n\n    // Return from cache if already calculated\n    if (BRUSH_PATTERNS[size][key]) {\n      return BRUSH_PATTERNS[size][key];\n    }\n\n    // For size 1, just return the center point\n    if (size === 1) {\n      const pattern = [{\n        x: centerX,\n        y: centerY\n      }];\n      BRUSH_PATTERNS[size][key] = pattern;\n      return pattern;\n    }\n\n    // Calculate pattern for this brush size and position\n    const points = [];\n\n    // Efficiently calculate diamond pattern\n    for (let y = -size + 1; y < size; y++) {\n      for (let x = -size + 1; x < size; x++) {\n        if (Math.abs(x) + Math.abs(y) < size) {\n          const newX = centerX + x;\n          const newY = centerY + y;\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\n            points.push({\n              x: newX,\n              y: newY\n            });\n          }\n        }\n      }\n    }\n\n    // Cache the result\n    if (Object.keys(BRUSH_PATTERNS[size]).length < 1000) {\n      // Limit cache size\n      BRUSH_PATTERNS[size][key] = points;\n    }\n    return points;\n  };\n  const handleDraw = (lastPoint, currentIndex) => {\n    const currentPoint = getCoordinates(currentIndex);\n    if (!lastPoint) return currentPoint;\n\n    // Use a Set for better performance and to avoid duplicates\n    const pointsSet = new Set();\n\n    // Draw line between the two points - this is a critical bottleneck\n    // Make this function as efficient as possible\n    const linePoints = drawLine(lastPoint, currentPoint);\n    if (brushSize === 1) {\n      // Fast path for single pixel brush\n      linePoints.forEach(idx => {\n        pointsSet.add(idx);\n      });\n    } else {\n      // For larger brushes, apply pattern to each point\n      linePoints.forEach(idx => {\n        const centerX = idx % 128;\n        const centerY = Math.floor(idx / 128);\n\n        // Get brush pattern for this point\n        const brushPattern = getBrushPattern(brushSize, centerX, centerY);\n\n        // Add all points to the set\n        brushPattern.forEach(point => {\n          const pixelIndex = point.y * 128 + point.x;\n          pointsSet.add(pixelIndex);\n        });\n      });\n    }\n\n    // Only update if we have points\n    if (pointsSet.size > 0) {\n      // Convert set to array\n      const pointsToUpdate = Array.from(pointsSet);\n\n      // Use a non-destructive update for better performance\n      onPixelUpdate(prev => {\n        const newPixels = [...prev];\n        for (let i = 0; i < pointsToUpdate.length; i++) {\n          newPixels[pointsToUpdate[i]] = drawColor;\n        }\n        return newPixels;\n      });\n    }\n    return currentPoint;\n  };\n  const handleStart = index => {\n    const centerX = index % 128;\n    const centerY = Math.floor(index / 128);\n\n    // Get brush pattern for this point\n    const brushPattern = getBrushPattern(brushSize, centerX, centerY);\n\n    // Convert pattern to indices\n    const pointsToUpdate = [];\n    for (let i = 0; i < brushPattern.length; i++) {\n      pointsToUpdate.push(brushPattern[i].y * 128 + brushPattern[i].x);\n    }\n\n    // Only update if we have points\n    if (pointsToUpdate.length > 0) {\n      onPixelUpdate(prev => {\n        const newPixels = [...prev];\n        for (let i = 0; i < pointsToUpdate.length; i++) {\n          newPixels[pointsToUpdate[i]] = drawColor;\n        }\n        return newPixels;\n      });\n    }\n  };\n  return {\n    handleDraw,\n    handleStart,\n    modeName: 'Freeform Mode',\n    isActive\n  };\n};\n_c = FreeformMode;\nexport default _c2 = /*#__PURE__*/React.memo(FreeformMode);\nvar _c, _c2;\n$RefreshReg$(_c, \"FreeformMode\");\n$RefreshReg$(_c2, \"%default%\");","map":{"version":3,"names":["React","useMemo","getCoordinates","drawLine","BRUSH_PATTERNS","size","FreeformMode","isActive","onPixelUpdate","brushSize","drawColor","getBrushPattern","centerX","centerY","key","pattern","x","y","points","Math","abs","newX","newY","push","Object","keys","length","handleDraw","lastPoint","currentIndex","currentPoint","pointsSet","Set","linePoints","forEach","idx","add","floor","brushPattern","point","pixelIndex","pointsToUpdate","Array","from","prev","newPixels","i","handleStart","index","modeName","_c","_c2","memo","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/FreeFormMode.jsx"],"sourcesContent":["import React, { useMemo } from 'react';\r\nimport { getCoordinates, drawLine } from './utils';\r\n\r\n// Pre-calculate brush patterns for common sizes\r\nconst BRUSH_PATTERNS = {};\r\n\r\n// Initialize brush patterns\r\nfor (let size = 1; size <= 5; size++) {\r\n  BRUSH_PATTERNS[size] = {};\r\n}\r\n\r\nconst FreeformMode = ({ isActive, onPixelUpdate, brushSize, drawColor = true }) => {\r\n  // Get or calculate brush pattern - much more efficient\r\n  const getBrushPattern = (size, centerX, centerY) => {\r\n    // Cache key based on position\r\n    const key = `${centerX},${centerY}`;\r\n    \r\n    // Return from cache if already calculated\r\n    if (BRUSH_PATTERNS[size][key]) {\r\n      return BRUSH_PATTERNS[size][key];\r\n    }\r\n    \r\n    // For size 1, just return the center point\r\n    if (size === 1) {\r\n      const pattern = [{ x: centerX, y: centerY }];\r\n      BRUSH_PATTERNS[size][key] = pattern;\r\n      return pattern;\r\n    }\r\n    \r\n    // Calculate pattern for this brush size and position\r\n    const points = [];\r\n    \r\n    // Efficiently calculate diamond pattern\r\n    for (let y = -size + 1; y < size; y++) {\r\n      for (let x = -size + 1; x < size; x++) {\r\n        if (Math.abs(x) + Math.abs(y) < size) {\r\n          const newX = centerX + x;\r\n          const newY = centerY + y;\r\n          \r\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\r\n            points.push({ x: newX, y: newY });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Cache the result\r\n    if (Object.keys(BRUSH_PATTERNS[size]).length < 1000) {  // Limit cache size\r\n      BRUSH_PATTERNS[size][key] = points;\r\n    }\r\n    \r\n    return points;\r\n  };\r\n\r\n  const handleDraw = (lastPoint, currentIndex) => {\r\n    const currentPoint = getCoordinates(currentIndex);\r\n    if (!lastPoint) return currentPoint;\r\n\r\n    // Use a Set for better performance and to avoid duplicates\r\n    const pointsSet = new Set();\r\n    \r\n    // Draw line between the two points - this is a critical bottleneck\r\n    // Make this function as efficient as possible\r\n    const linePoints = drawLine(lastPoint, currentPoint);\r\n    \r\n    if (brushSize === 1) {\r\n      // Fast path for single pixel brush\r\n      linePoints.forEach(idx => {\r\n        pointsSet.add(idx);\r\n      });\r\n    } else {\r\n      // For larger brushes, apply pattern to each point\r\n      linePoints.forEach(idx => {\r\n        const centerX = idx % 128;\r\n        const centerY = Math.floor(idx / 128);\r\n        \r\n        // Get brush pattern for this point\r\n        const brushPattern = getBrushPattern(brushSize, centerX, centerY);\r\n        \r\n        // Add all points to the set\r\n        brushPattern.forEach(point => {\r\n          const pixelIndex = point.y * 128 + point.x;\r\n          pointsSet.add(pixelIndex);\r\n        });\r\n      });\r\n    }\r\n\r\n    // Only update if we have points\r\n    if (pointsSet.size > 0) {\r\n      // Convert set to array\r\n      const pointsToUpdate = Array.from(pointsSet);\r\n      \r\n      // Use a non-destructive update for better performance\r\n      onPixelUpdate(prev => {\r\n        const newPixels = [...prev];\r\n        for (let i = 0; i < pointsToUpdate.length; i++) {\r\n          newPixels[pointsToUpdate[i]] = drawColor;\r\n        }\r\n        return newPixels;\r\n      });\r\n    }\r\n    \r\n    return currentPoint;\r\n  };\r\n\r\n  const handleStart = (index) => {\r\n    const centerX = index % 128;\r\n    const centerY = Math.floor(index / 128);\r\n    \r\n    // Get brush pattern for this point\r\n    const brushPattern = getBrushPattern(brushSize, centerX, centerY);\r\n    \r\n    // Convert pattern to indices\r\n    const pointsToUpdate = [];\r\n    \r\n    for (let i = 0; i < brushPattern.length; i++) {\r\n      pointsToUpdate.push(brushPattern[i].y * 128 + brushPattern[i].x);\r\n    }\r\n    \r\n    // Only update if we have points\r\n    if (pointsToUpdate.length > 0) {\r\n      onPixelUpdate(prev => {\r\n        const newPixels = [...prev];\r\n        for (let i = 0; i < pointsToUpdate.length; i++) {\r\n          newPixels[pointsToUpdate[i]] = drawColor;\r\n        }\r\n        return newPixels;\r\n      });\r\n    }\r\n  };\r\n\r\n  return {\r\n    handleDraw,\r\n    handleStart,\r\n    modeName: 'Freeform Mode',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default React.memo(FreeformMode);"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}