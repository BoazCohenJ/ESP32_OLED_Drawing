{"ast":null,"code":"import React from 'react';\nimport { getIndex, getCoordinates, drawLine as utilsDrawLine } from './utils';\nconst EraserMode = ({\n  isActive,\n  onPixelUpdate,\n  brushSize = 1\n}) => {\n  const getPointsForBrush = centerIndex => {\n    const centerX = centerIndex % 128;\n    const centerY = Math.floor(centerIndex / 128);\n    const points = [];\n\n    // For a single pixel\n    if (brushSize === 1) {\n      points.push(centerIndex);\n      return points;\n    }\n\n    // For larger brush sizes, use a diamond pattern\n    for (let y = -brushSize + 1; y < brushSize; y++) {\n      for (let x = -brushSize + 1; x < brushSize; x++) {\n        // Use Manhattan distance for diamond shape\n        if (Math.abs(x) + Math.abs(y) < brushSize) {\n          const newX = centerX + x;\n          const newY = centerY + y;\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\n            const index = getIndex(newX, newY);\n            points.push(index);\n          }\n        }\n      }\n    }\n    return points;\n  };\n\n  // Draw line with brush size taken into account\n  const drawLine = (start, end) => {\n    if (!isActive) return start;\n\n    // Get all points along the line path\n    const lineIndices = utilsDrawLine(start, end);\n    const allPointsToErase = new Set();\n\n    // For each point in the line, apply the brush pattern\n    lineIndices.forEach(index => {\n      const pointsForBrush = getPointsForBrush(index);\n      pointsForBrush.forEach(idx => allPointsToErase.add(idx));\n    });\n\n    // Apply the eraser to all collected points at once\n    onPixelUpdate(prevPixels => {\n      const newPixels = [...prevPixels];\n      allPointsToErase.forEach(idx => {\n        newPixels[idx] = false;\n      });\n      return newPixels;\n    });\n    return end;\n  };\n  const handleStart = index => {\n    if (!isActive) return;\n    const pointsToErase = getPointsForBrush(index);\n    onPixelUpdate(prevPixels => {\n      const newPixels = [...prevPixels];\n      pointsToErase.forEach(idx => {\n        newPixels[idx] = false;\n      });\n      return newPixels;\n    });\n  };\n  const handleDraw = (startPoint, endIndex) => {\n    if (!isActive || !startPoint) return startPoint;\n    const endPoint = getCoordinates(endIndex);\n    return drawLine(startPoint, endPoint);\n  };\n  return {\n    handleStart,\n    handleDraw,\n    modeName: 'Eraser',\n    isActive\n  };\n};\n_c = EraserMode;\nexport default EraserMode;\nvar _c;\n$RefreshReg$(_c, \"EraserMode\");","map":{"version":3,"names":["React","getIndex","getCoordinates","drawLine","utilsDrawLine","EraserMode","isActive","onPixelUpdate","brushSize","getPointsForBrush","centerIndex","centerX","centerY","Math","floor","points","push","y","x","abs","newX","newY","index","start","end","lineIndices","allPointsToErase","Set","forEach","pointsForBrush","idx","add","prevPixels","newPixels","handleStart","pointsToErase","handleDraw","startPoint","endIndex","endPoint","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/EraserMode.jsx"],"sourcesContent":["import React from 'react';\r\nimport { getIndex, getCoordinates, drawLine as utilsDrawLine } from './utils';\r\n\r\nconst EraserMode = ({ isActive, onPixelUpdate, brushSize = 1 }) => {\r\n  const getPointsForBrush = (centerIndex) => {\r\n    const centerX = centerIndex % 128;\r\n    const centerY = Math.floor(centerIndex / 128);\r\n    const points = [];\r\n\r\n    // For a single pixel\r\n    if (brushSize === 1) {\r\n      points.push(centerIndex);\r\n      return points;\r\n    }\r\n\r\n    // For larger brush sizes, use a diamond pattern\r\n    for (let y = -brushSize + 1; y < brushSize; y++) {\r\n      for (let x = -brushSize + 1; x < brushSize; x++) {\r\n        // Use Manhattan distance for diamond shape\r\n        if (Math.abs(x) + Math.abs(y) < brushSize) {\r\n          const newX = centerX + x;\r\n          const newY = centerY + y;\r\n          \r\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\r\n            const index = getIndex(newX, newY);\r\n            points.push(index);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return points;\r\n  };\r\n  \r\n  // Draw line with brush size taken into account\r\n  const drawLine = (start, end) => {\r\n    if (!isActive) return start;\r\n    \r\n    // Get all points along the line path\r\n    const lineIndices = utilsDrawLine(start, end);\r\n    const allPointsToErase = new Set();\r\n    \r\n    // For each point in the line, apply the brush pattern\r\n    lineIndices.forEach(index => {\r\n      const pointsForBrush = getPointsForBrush(index);\r\n      pointsForBrush.forEach(idx => allPointsToErase.add(idx));\r\n    });\r\n    \r\n    // Apply the eraser to all collected points at once\r\n    onPixelUpdate(prevPixels => {\r\n      const newPixels = [...prevPixels];\r\n      allPointsToErase.forEach(idx => {\r\n        newPixels[idx] = false;\r\n      });\r\n      return newPixels;\r\n    });\r\n    \r\n    return end;\r\n  };\r\n\r\n  const handleStart = (index) => {\r\n    if (!isActive) return;\r\n    \r\n    const pointsToErase = getPointsForBrush(index);\r\n    onPixelUpdate(prevPixels => {\r\n      const newPixels = [...prevPixels];\r\n      pointsToErase.forEach(idx => {\r\n        newPixels[idx] = false;\r\n      });\r\n      return newPixels;\r\n    });\r\n  };\r\n\r\n  const handleDraw = (startPoint, endIndex) => {\r\n    if (!isActive || !startPoint) return startPoint;\r\n    \r\n    const endPoint = getCoordinates(endIndex);\r\n    return drawLine(startPoint, endPoint);\r\n  };\r\n\r\n  return {\r\n    handleStart,\r\n    handleDraw,\r\n    modeName: 'Eraser',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default EraserMode;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}