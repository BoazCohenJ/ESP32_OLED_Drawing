{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wikx3\\\\Documents\\\\VS_code\\\\React\\\\ESP32_OLED_Drawing\\\\src\\\\components\\\\pixelGrid\\\\index.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\nimport { drawLine } from './utils';\nimport ESP32Connection from '../ESP32Connection';\nimport BMPHandler from '../BMPHandler';\nimport ResetButton from './ResetButton';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GRID_WIDTH = 128;\nconst GRID_HEIGHT = 64;\nconst PIXEL_SIZE = 8;\nconst TOTAL_PIXELS = GRID_WIDTH * GRID_HEIGHT;\nconst PixelGrid = () => {\n  _s();\n  // Use Uint8Array for better performance (0 = black, 1 = white)\n  const [pixels, setPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\n  const [previewPixels, setPreviewPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\n  const [isLineModeActive, setIsLineModeActive] = useState(false);\n  const [isCircleModeActive, setIsCircleModeActive] = useState(false);\n  const [isBucketFillModeActive, setIsBucketFillModeActive] = useState(false);\n  const [isRectangleModeActive, setIsRectangleModeActive] = useState(false);\n  const isDrawingRef = useRef(false);\n  const startPointRef = useRef(null);\n  const lastPointRef = useRef(null);\n  const lastPointWasOutsideRef = useRef(false);\n  const [isSpacePressed, setIsSpacePressed] = useState(false);\n  const currentIndexRef = useRef(null);\n  const [brushSize, setBrushSize] = useState(1);\n  const [drawColor, setDrawColor] = useState(true);\n\n  // Canvas refs\n  const canvasRef = useRef(null);\n  const brushCanvasRef = useRef(null);\n  const renderRequestRef = useRef(null);\n  const pixelsRef = useRef(pixels);\n  const previewPixelsRef = useRef(previewPixels);\n\n  // FPS counter\n  const [fps, setFps] = useState(0);\n  const frameCountRef = useRef(0);\n  const lastFpsTimeRef = useRef(performance.now());\n\n  // History for undo/redo - optimized\n  const historyRef = useRef([new Uint8Array(TOTAL_PIXELS)]);\n  const historyIndexRef = useRef(0);\n  const [canUndo, setCanUndo] = useState(false);\n  const [canRedo, setCanRedo] = useState(false);\n  const addToHistory = useCallback(newState => {\n    const newHistory = historyRef.current.slice(0, historyIndexRef.current + 1);\n    newHistory.push(new Uint8Array(newState));\n    if (newHistory.length > 100) newHistory.shift();\n    historyRef.current = newHistory;\n    historyIndexRef.current = newHistory.length - 1;\n    setCanUndo(historyIndexRef.current > 0);\n    setCanRedo(false);\n  }, []);\n  const undo = useCallback(() => {\n    if (historyIndexRef.current > 0) {\n      historyIndexRef.current--;\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\n      setPixels(state);\n      setCanUndo(historyIndexRef.current > 0);\n      setCanRedo(true);\n    }\n  }, []);\n  const redo = useCallback(() => {\n    if (historyIndexRef.current < historyRef.current.length - 1) {\n      historyIndexRef.current++;\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\n      setPixels(state);\n      setCanUndo(true);\n      setCanRedo(historyIndexRef.current < historyRef.current.length - 1);\n    }\n  }, []);\n\n  // Keep pixelsRef in sync\n  useEffect(() => {\n    pixelsRef.current = pixels;\n  }, [pixels]);\n  useEffect(() => {\n    previewPixelsRef.current = previewPixels;\n  }, [previewPixels]);\n\n  // Optimized canvas render function\n  const renderCanvas = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    const imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);\n    const data = imageData.data;\n    const currentPixels = pixelsRef.current;\n    const currentPreview = previewPixelsRef.current;\n    for (let i = 0; i < TOTAL_PIXELS; i++) {\n      const offset = i * 4;\n      if (currentPreview[i] === 1) {\n        // White preview\n        data[offset] = 255;\n        data[offset + 1] = 255;\n        data[offset + 2] = 255;\n      } else if (currentPreview[i] === 2) {\n        // Black preview (dark gray for visibility)\n        data[offset] = 34;\n        data[offset + 1] = 34;\n        data[offset + 2] = 34;\n      } else if (currentPixels[i] === 1) {\n        // White pixel\n        data[offset] = 255;\n        data[offset + 1] = 255;\n        data[offset + 2] = 255;\n      } else {\n        // Black pixel (background)\n        data[offset] = 17;\n        data[offset + 1] = 17;\n        data[offset + 2] = 17;\n      }\n      data[offset + 3] = 255;\n    }\n    ctx.putImageData(imageData, 0, 0);\n\n    // FPS counting\n    frameCountRef.current++;\n    const now = performance.now();\n    if (now - lastFpsTimeRef.current >= 1000) {\n      setFps(frameCountRef.current);\n      frameCountRef.current = 0;\n      lastFpsTimeRef.current = now;\n    }\n  }, []);\n\n  // Schedule render with requestAnimationFrame\n  const scheduleRender = useCallback(() => {\n    if (renderRequestRef.current) return;\n    renderRequestRef.current = requestAnimationFrame(() => {\n      renderCanvas();\n      renderRequestRef.current = null;\n    });\n  }, [renderCanvas]);\n\n  // Render on pixel changes\n  useEffect(() => {\n    scheduleRender();\n  }, [pixels, previewPixels, scheduleRender]);\n\n  // Initial render\n  useEffect(() => {\n    renderCanvas();\n  }, [renderCanvas]);\n  const isFreeformActive = !isLineModeActive && !isCircleModeActive && !isBucketFillModeActive && !isRectangleModeActive;\n\n  // Drawing utility functions\n  const getLinePoints = useCallback((start, end) => {\n    const points = [];\n    let x0 = Math.max(0, Math.min(127, start.x));\n    let y0 = Math.max(0, Math.min(63, start.y));\n    let x1 = Math.max(0, Math.min(127, end.x));\n    let y1 = Math.max(0, Math.min(63, end.y));\n    const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\n    if (steep) {\n      [x0, y0] = [y0, x0];\n      [x1, y1] = [y1, x1];\n    }\n    if (x0 > x1) {\n      [x0, x1] = [x1, x0];\n      [y0, y1] = [y1, y0];\n    }\n    const dx = x1 - x0;\n    const dy = Math.abs(y1 - y0);\n    const yStep = y0 < y1 ? 1 : -1;\n    let error = dx / 2;\n    let y = y0;\n    for (let x = x0; x <= x1; x++) {\n      const currentX = steep ? y : x;\n      const currentY = steep ? x : y;\n      const index = currentY * GRID_WIDTH + currentX;\n      if (index >= 0 && index < TOTAL_PIXELS) points.push(index);\n      error -= dy;\n      if (error < 0) {\n        y += yStep;\n        error += dx;\n      }\n    }\n    return points;\n  }, []);\n  const getCirclePoints = useCallback((center, point) => {\n    const points = [];\n    const radius = Math.floor(Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)));\n    let x = radius,\n      y = 0,\n      error = 0;\n    while (x >= y) {\n      const coords = [[center.x + x, center.y + y], [center.x + y, center.y + x], [center.x - y, center.y + x], [center.x - x, center.y + y], [center.x - x, center.y - y], [center.x - y, center.y - x], [center.x + y, center.y - x], [center.x + x, center.y - y]];\n      coords.forEach(([px, py]) => {\n        if (px >= 0 && px < GRID_WIDTH && py >= 0 && py < GRID_HEIGHT) {\n          points.push(py * GRID_WIDTH + px);\n        }\n      });\n      y++;\n      error += 1 + 2 * y;\n      if (2 * (error - x) + 1 > 0) {\n        x--;\n        error += 1 - 2 * x;\n      }\n    }\n    return points;\n  }, []);\n  const getRectPoints = useCallback((start, end) => {\n    const points = [];\n    const startX = Math.max(0, Math.min(start.x, end.x));\n    const startY = Math.max(0, Math.min(start.y, end.y));\n    const endX = Math.min(127, Math.max(start.x, end.x));\n    const endY = Math.min(63, Math.max(start.y, end.y));\n    for (let x = startX; x <= endX; x++) {\n      if (startY >= 0 && startY < GRID_HEIGHT) points.push(startY * GRID_WIDTH + x);\n      if (endY >= 0 && endY < GRID_HEIGHT && endY !== startY) points.push(endY * GRID_WIDTH + x);\n    }\n    for (let y = startY + 1; y < endY; y++) {\n      if (startX >= 0 && startX < GRID_WIDTH) points.push(y * GRID_WIDTH + startX);\n      if (endX >= 0 && endX < GRID_WIDTH && endX !== startX) points.push(y * GRID_WIDTH + endX);\n    }\n    return points;\n  }, []);\n\n  // Get brush pattern points (now accepts non-integer coordinates)\n  const getBrushPoints = useCallback((centerX, centerY, size) => {\n    const points = [];\n    // Round to nearest pixel for center\n    const pixelX = Math.round(centerX);\n    const pixelY = Math.round(centerY);\n    for (let offset = 0; offset < size; offset++) {\n      for (let i = -offset; i <= offset; i++) {\n        const coords = [{\n          x: pixelX + i,\n          y: pixelY - (size - 1 - offset)\n        }, {\n          x: pixelX + i,\n          y: pixelY + (size - 1 - offset)\n        }, {\n          x: pixelX - (size - 1 - offset),\n          y: pixelY + i\n        }, {\n          x: pixelX + (size - 1 - offset),\n          y: pixelY + i\n        }];\n        coords.forEach(point => {\n          if (point.x >= 0 && point.x < GRID_WIDTH && point.y >= 0 && point.y < GRID_HEIGHT) {\n            points.push(point.y * GRID_WIDTH + point.x);\n          }\n        });\n      }\n    }\n    return points;\n  }, []);\n\n  // Get coordinates from canvas position\n  const getCanvasCoordinates = useCallback(e => {\n    const canvas = canvasRef.current;\n    if (!canvas) return null;\n    const rect = canvas.getBoundingClientRect();\n    const scaleX = GRID_WIDTH / rect.width;\n    const scaleY = GRID_HEIGHT / rect.height;\n    const x = Math.floor((e.clientX - rect.left) * scaleX);\n    const y = Math.floor((e.clientY - rect.top) * scaleY);\n    return {\n      x,\n      y\n    };\n  }, []);\n\n  // Bucket fill\n  const handleBucketFill = useCallback(index => {\n    const currentPixels = pixelsRef.current;\n    const targetColor = currentPixels[index];\n    const fillColor = drawColor ? 1 : 0;\n    if (targetColor === fillColor) return;\n    const newPixels = new Uint8Array(currentPixels);\n    const stack = [index];\n    const visited = new Set();\n    while (stack.length > 0) {\n      const currentIndex = stack.pop();\n      if (visited.has(currentIndex) || newPixels[currentIndex] !== targetColor) continue;\n      visited.add(currentIndex);\n      newPixels[currentIndex] = fillColor;\n      const x = currentIndex % GRID_WIDTH;\n      const y = Math.floor(currentIndex / GRID_WIDTH);\n      if (x > 0) stack.push(currentIndex - 1);\n      if (x < GRID_WIDTH - 1) stack.push(currentIndex + 1);\n      if (y > 0) stack.push(currentIndex - GRID_WIDTH);\n      if (y < GRID_HEIGHT - 1) stack.push(currentIndex + GRID_WIDTH);\n    }\n    setPixels(newPixels);\n    addToHistory(newPixels);\n  }, [drawColor, addToHistory]);\n\n  // Mouse event handlers\n  const handleCanvasMouseDown = useCallback(e => {\n    if (e.button !== 0) return;\n    const coords = getCanvasCoordinates(e);\n    if (!coords) return;\n    const clampedX = Math.max(0, Math.min(GRID_WIDTH - 1, coords.x));\n    const clampedY = Math.max(0, Math.min(GRID_HEIGHT - 1, coords.y));\n    const index = clampedY * GRID_WIDTH + clampedX;\n    isDrawingRef.current = true;\n    currentIndexRef.current = index;\n\n    // Check if coords are within bounds\n    const isInBounds = coords.x >= 0 && coords.x < GRID_WIDTH && coords.y >= 0 && coords.y < GRID_HEIGHT;\n    if (isBucketFillModeActive) {\n      if (isInBounds) {\n        handleBucketFill(index);\n      }\n      isDrawingRef.current = false;\n      return;\n    }\n    if (isFreeformActive) {\n      lastPointRef.current = {\n        x: coords.x,\n        y: coords.y\n      };\n      lastPointWasOutsideRef.current = !isInBounds;\n      // Draw any parts that are visible in the grid\n      const points = getBrushPoints(coords.x, coords.y, brushSize);\n      if (points.length > 0) {\n        setPixels(prev => {\n          const newPixels = new Uint8Array(prev);\n          points.forEach(idx => {\n            newPixels[idx] = drawColor ? 1 : 0;\n          });\n          return newPixels;\n        });\n      }\n    } else {\n      startPointRef.current = coords;\n      lastPointRef.current = coords;\n    }\n  }, [isBucketFillModeActive, isFreeformActive, handleBucketFill, getCanvasCoordinates, getBrushPoints, brushSize, drawColor]);\n  const handleCanvasMouseMove = useCallback(e => {\n    const coords = getCanvasCoordinates(e);\n    if (!coords) return;\n    const clampedX = Math.max(0, Math.min(GRID_WIDTH - 1, coords.x));\n    const clampedY = Math.max(0, Math.min(GRID_HEIGHT - 1, coords.y));\n    const index = clampedY * GRID_WIDTH + clampedX;\n    currentIndexRef.current = index;\n\n    // Update brush outline\n    updateBrushOutline(e);\n    if (!isDrawingRef.current) return;\n    if (isFreeformActive && lastPointRef.current) {\n      const isInBounds = coords.x >= 0 && coords.x < GRID_WIDTH && coords.y >= 0 && coords.y < GRID_HEIGHT;\n\n      // If we just re-entered from outside, don't connect - start fresh\n      if (lastPointWasOutsideRef.current && isInBounds) {\n        lastPointRef.current = {\n          x: coords.x,\n          y: coords.y\n        };\n        lastPointWasOutsideRef.current = false;\n        const points = getBrushPoints(coords.x, coords.y, brushSize);\n        if (points.length > 0) {\n          setPixels(prev => {\n            const newPixels = new Uint8Array(prev);\n            points.forEach(idx => {\n              newPixels[idx] = drawColor ? 1 : 0;\n            });\n            return newPixels;\n          });\n        }\n        return;\n      }\n\n      // Draw line from last point to current point\n      const linePoints = drawLine(lastPointRef.current, {\n        x: coords.x,\n        y: coords.y\n      });\n      const allPoints = [];\n      linePoints.forEach(idx => {\n        const centerX = idx % GRID_WIDTH;\n        const centerY = Math.floor(idx / GRID_WIDTH);\n        allPoints.push(...getBrushPoints(centerX, centerY, brushSize));\n      });\n      if (allPoints.length > 0) {\n        setPixels(prev => {\n          const newPixels = new Uint8Array(prev);\n          allPoints.forEach(idx => {\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\n              newPixels[idx] = drawColor ? 1 : 0;\n            }\n          });\n          return newPixels;\n        });\n      }\n      lastPointRef.current = {\n        x: coords.x,\n        y: coords.y\n      };\n      lastPointWasOutsideRef.current = !isInBounds;\n    } else if (isLineModeActive && startPointRef.current) {\n      const points = getLinePoints(startPointRef.current, coords);\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\n      points.forEach(idx => {\n        newPreview[idx] = drawColor ? 1 : 2;\n      });\n      setPreviewPixels(newPreview);\n      lastPointRef.current = coords;\n    } else if (isCircleModeActive && startPointRef.current) {\n      const points = getCirclePoints(startPointRef.current, coords);\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\n      points.forEach(idx => {\n        newPreview[idx] = drawColor ? 1 : 2;\n      });\n      setPreviewPixels(newPreview);\n      lastPointRef.current = coords;\n    } else if (isRectangleModeActive && startPointRef.current) {\n      const points = getRectPoints(startPointRef.current, coords);\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\n      points.forEach(idx => {\n        newPreview[idx] = drawColor ? 1 : 2;\n      });\n      setPreviewPixels(newPreview);\n      lastPointRef.current = coords;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isFreeformActive, isLineModeActive, isCircleModeActive, isRectangleModeActive, getCanvasCoordinates, getBrushPoints, getLinePoints, getCirclePoints, getRectPoints, brushSize, drawColor]);\n  const handleMouseUp = useCallback(() => {\n    if (!isDrawingRef.current) return;\n    if ((isLineModeActive || isCircleModeActive || isRectangleModeActive) && startPointRef.current && lastPointRef.current) {\n      let points = [];\n      if (isLineModeActive) {\n        points = getLinePoints(startPointRef.current, lastPointRef.current);\n      } else if (isCircleModeActive) {\n        points = getCirclePoints(startPointRef.current, lastPointRef.current);\n      } else if (isRectangleModeActive) {\n        points = getRectPoints(startPointRef.current, lastPointRef.current);\n      }\n      if (points.length > 0) {\n        setPixels(prev => {\n          const newPixels = new Uint8Array(prev);\n          points.forEach(idx => {\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\n              newPixels[idx] = drawColor ? 1 : 0;\n            }\n          });\n          // Add to history after state update\n          setTimeout(() => addToHistory(newPixels), 0);\n          return newPixels;\n        });\n      }\n      setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\n    } else if (isFreeformActive) {\n      addToHistory(pixelsRef.current);\n    }\n    isDrawingRef.current = false;\n    startPointRef.current = null;\n    lastPointRef.current = null;\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, isFreeformActive, drawColor, getLinePoints, getCirclePoints, getRectPoints, addToHistory]);\n\n  // Global mouse events for drawing outside the grid\n  useEffect(() => {\n    const handleGlobalMouseMove = e => {\n      if (isDrawingRef.current && (isLineModeActive || isCircleModeActive || isRectangleModeActive)) {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const scaleX = GRID_WIDTH / rect.width;\n        const scaleY = GRID_HEIGHT / rect.height;\n\n        // Allow coordinates outside the grid\n        const x = Math.floor((e.clientX - rect.left) * scaleX);\n        const y = Math.floor((e.clientY - rect.top) * scaleY);\n        const coords = {\n          x,\n          y\n        };\n        let points = [];\n        if (isLineModeActive && startPointRef.current) {\n          points = getLinePoints(startPointRef.current, coords);\n        } else if (isCircleModeActive && startPointRef.current) {\n          points = getCirclePoints(startPointRef.current, coords);\n        } else if (isRectangleModeActive && startPointRef.current) {\n          points = getRectPoints(startPointRef.current, coords);\n        }\n        const newPreview = new Uint8Array(TOTAL_PIXELS);\n        points.forEach(idx => {\n          newPreview[idx] = drawColor ? 1 : 2;\n        });\n        setPreviewPixels(newPreview);\n        lastPointRef.current = coords;\n      }\n    };\n    const handleGlobalMouseUp = () => {\n      if (isDrawingRef.current) {\n        handleMouseUp();\n      }\n    };\n    window.addEventListener('mousemove', handleGlobalMouseMove);\n    window.addEventListener('mouseup', handleGlobalMouseUp);\n    return () => {\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\n      window.removeEventListener('mouseup', handleGlobalMouseUp);\n    };\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, drawColor, getLinePoints, getCirclePoints, getRectPoints, handleMouseUp]);\n\n  // Keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = e => {\n      if (e.code === 'Space' && !isSpacePressed && currentIndexRef.current !== null) {\n        e.preventDefault();\n        setIsSpacePressed(true);\n        // Trigger drawing at current position\n        const index = currentIndexRef.current;\n        isDrawingRef.current = true;\n        if (isFreeformActive) {\n          const x = index % GRID_WIDTH;\n          const y = Math.floor(index / GRID_WIDTH);\n          lastPointRef.current = {\n            x,\n            y\n          };\n          const points = getBrushPoints(x, y, brushSize);\n          setPixels(prev => {\n            const newPixels = new Uint8Array(prev);\n            points.forEach(idx => {\n              newPixels[idx] = drawColor ? 1 : 0;\n            });\n            return newPixels;\n          });\n        }\n      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\n        e.preventDefault();\n        if (e.shiftKey) {\n          redo();\n        } else {\n          undo();\n        }\n      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\n        e.preventDefault();\n        redo();\n      } else if (e.key === 'b') {\n        e.preventDefault();\n        setIsLineModeActive(false);\n        setIsCircleModeActive(false);\n        setIsBucketFillModeActive(false);\n        setIsRectangleModeActive(false);\n      }\n    };\n    const handleKeyUp = e => {\n      if (e.code === 'Space') {\n        e.preventDefault();\n        setIsSpacePressed(false);\n        if (isDrawingRef.current) {\n          addToHistory(pixelsRef.current);\n          isDrawingRef.current = false;\n          lastPointRef.current = null;\n        }\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [isSpacePressed, isFreeformActive, brushSize, drawColor, getBrushPoints, undo, redo, addToHistory]);\n\n  // Brush outline rendering\n  const updateBrushOutline = useCallback(e => {\n    const brushCanvas = brushCanvasRef.current;\n    if (!brushCanvas || !isFreeformActive) {\n      if (brushCanvas) brushCanvas.style.display = 'none';\n      return;\n    }\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n\n    // Calculate pixel position (allow outside bounds)\n    const scaleX = GRID_WIDTH / rect.width;\n    const scaleY = GRID_HEIGHT / rect.height;\n    const pixelX = Math.floor((e.clientX - rect.left) * scaleX);\n    const pixelY = Math.floor((e.clientY - rect.top) * scaleY);\n    const ctx = brushCanvas.getContext('2d');\n    ctx.clearRect(0, 0, brushCanvas.width, brushCanvas.height);\n    ctx.strokeStyle = drawColor ? '#fff' : '#f00';\n    ctx.lineWidth = 1;\n    if (brushSize === 1) {\n      // Only draw if any part would be visible in the grid\n      if (pixelX >= 0 && pixelX < GRID_WIDTH && pixelY >= 0 && pixelY < GRID_HEIGHT) {\n        ctx.strokeRect(pixelX * PIXEL_SIZE + 0.5, pixelY * PIXEL_SIZE + 0.5, PIXEL_SIZE - 1, PIXEL_SIZE - 1);\n      }\n    } else {\n      const diamondPixels = [];\n      for (let y = -brushSize + 1; y < brushSize; y++) {\n        for (let x = -brushSize + 1; x < brushSize; x++) {\n          if (Math.abs(x) + Math.abs(y) < brushSize) {\n            const newX = pixelX + x;\n            const newY = pixelY + y;\n            // Include pixels even outside grid for outline calculation\n            if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) {\n              diamondPixels.push({\n                x: newX,\n                y: newY\n              });\n            }\n          }\n        }\n      }\n      if (diamondPixels.length > 0) {\n        ctx.beginPath();\n        diamondPixels.forEach(({\n          x,\n          y\n        }) => {\n          [{\n            dx: 0,\n            dy: -1,\n            side: 'top'\n          }, {\n            dx: 1,\n            dy: 0,\n            side: 'right'\n          }, {\n            dx: 0,\n            dy: 1,\n            side: 'bottom'\n          }, {\n            dx: -1,\n            dy: 0,\n            side: 'left'\n          }].forEach(({\n            dx,\n            dy,\n            side\n          }) => {\n            const nx = x + dx;\n            const ny = y + dy;\n            if (!diamondPixels.some(p => p.x === nx && p.y === ny)) {\n              const px = x * PIXEL_SIZE;\n              const py = y * PIXEL_SIZE;\n              if (side === 'top') {\n                ctx.moveTo(px, py);\n                ctx.lineTo(px + PIXEL_SIZE, py);\n              } else if (side === 'right') {\n                ctx.moveTo(px + PIXEL_SIZE, py);\n                ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE);\n              } else if (side === 'bottom') {\n                ctx.moveTo(px, py + PIXEL_SIZE);\n                ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE);\n              } else if (side === 'left') {\n                ctx.moveTo(px, py);\n                ctx.lineTo(px, py + PIXEL_SIZE);\n              }\n            }\n          });\n        });\n        ctx.stroke();\n      }\n    }\n    brushCanvas.style.display = 'block';\n  }, [isFreeformActive, brushSize, drawColor]);\n\n  // Update brush outline on global mouse move for freeform mode\n  useEffect(() => {\n    if (!isFreeformActive) return;\n    const handleGlobalMouseMove = e => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const rect = canvas.getBoundingClientRect();\n      // Determine if we're reasonably close to the canvas\n      const margin = brushSize * PIXEL_SIZE * 2; // Allow brush size distance from edges\n      if (e.clientX >= rect.left - margin && e.clientX <= rect.right + margin && e.clientY >= rect.top - margin && e.clientY <= rect.bottom + margin) {\n        updateBrushOutline(e);\n      } else {\n        // Hide if too far from canvas\n        const brushCanvas = brushCanvasRef.current;\n        if (brushCanvas) brushCanvas.style.display = 'none';\n      }\n    };\n    window.addEventListener('mousemove', handleGlobalMouseMove);\n    return () => {\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\n    };\n  }, [isFreeformActive, brushSize, updateBrushOutline]);\n  const handleReset = useCallback(() => {\n    const newState = new Uint8Array(TOTAL_PIXELS);\n    setPixels(newState);\n    setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\n    startPointRef.current = null;\n    lastPointRef.current = null;\n    isDrawingRef.current = false;\n    addToHistory(newState);\n  }, [addToHistory]);\n\n  // Convert Uint8Array to boolean array for ESP32Connection and BMPHandler compatibility\n  const pixelsAsBoolArray = useMemo(() => {\n    return Array.from(pixels).map(p => p === 1);\n  }, [pixels]);\n  const handleBMPPixelUpdate = useCallback(newPixels => {\n    if (Array.isArray(newPixels)) {\n      const uint8Pixels = new Uint8Array(TOTAL_PIXELS);\n      newPixels.forEach((val, i) => {\n        uint8Pixels[i] = val ? 1 : 0;\n      });\n      setPixels(uint8Pixels);\n      addToHistory(uint8Pixels);\n    }\n  }, [addToHistory]);\n  const showBrushSizeControl = isFreeformActive;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"pixel-grid-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'absolute',\n        top: '10px',\n        left: '50%',\n        transform: 'translateX(-50%)',\n        backgroundColor: 'rgba(0,0,0,0.7)',\n        color: fps < 30 ? '#ff4444' : fps < 50 ? '#ffaa00' : '#44ff44',\n        padding: '5px 15px',\n        borderRadius: '4px',\n        fontFamily: 'monospace',\n        fontSize: '14px',\n        zIndex: 1001\n      },\n      children: [\"FPS: \", fps]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 704,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"esp32-container\",\n      style: {\n        position: 'fixed',\n        top: '10px',\n        left: '10px',\n        zIndex: 1000\n      },\n      children: /*#__PURE__*/_jsxDEV(ESP32Connection, {\n        pixelData: pixelsAsBoolArray\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 722,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 721,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"bmp-container\",\n      style: {\n        position: 'fixed',\n        top: '10px',\n        right: '10px',\n        zIndex: 1000\n      },\n      children: /*#__PURE__*/_jsxDEV(BMPHandler, {\n        pixelData: pixelsAsBoolArray,\n        onPixelUpdate: handleBMPPixelUpdate\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 727,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 726,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"brush-size-control\",\n      style: {\n        visibility: showBrushSizeControl ? 'visible' : 'hidden'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"brushSize\",\n        style: {\n          color: 'white',\n          minWidth: '100px'\n        },\n        children: [\"Brush Size: \", brushSize]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 732,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"range\",\n        id: \"brushSize\",\n        className: \"brush-size-slider\",\n        min: \"1\",\n        max: \"5\",\n        value: brushSize,\n        onChange: e => setBrushSize(Number(e.target.value))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 735,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 731,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'flex',\n        justifyContent: 'center',\n        width: '100%',\n        position: 'relative'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"mode-buttons-container\",\n        style: {\n          position: 'relative',\n          left: '22px',\n          width: '1024px',\n          boxSizing: 'border-box',\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(false);\n            setIsCircleModeActive(false);\n            setIsBucketFillModeActive(false);\n            setIsRectangleModeActive(false);\n            setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\n          },\n          className: `mode-button ${isFreeformActive ? 'active' : ''}`,\n          children: \"Freeform Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 752,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(true);\n            setIsCircleModeActive(false);\n            setIsBucketFillModeActive(false);\n            setIsRectangleModeActive(false);\n          },\n          className: `mode-button ${isLineModeActive ? 'active' : ''}`,\n          children: \"Line Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 764,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(false);\n            setIsCircleModeActive(true);\n            setIsBucketFillModeActive(false);\n            setIsRectangleModeActive(false);\n          },\n          className: `mode-button ${isCircleModeActive ? 'active' : ''}`,\n          children: \"Circle Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 775,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(false);\n            setIsCircleModeActive(false);\n            setIsBucketFillModeActive(false);\n            setIsRectangleModeActive(true);\n          },\n          className: `mode-button ${isRectangleModeActive ? 'active' : ''}`,\n          children: \"Rectangle Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 786,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(false);\n            setIsCircleModeActive(false);\n            setIsBucketFillModeActive(true);\n            setIsRectangleModeActive(false);\n          },\n          className: `mode-button ${isBucketFillModeActive ? 'active' : ''}`,\n          children: \"Bucket Fill\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 797,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: undo,\n          className: \"mode-button\",\n          disabled: !canUndo,\n          style: {\n            marginLeft: 'auto'\n          },\n          children: \"Undo\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 808,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: redo,\n          className: \"mode-button\",\n          disabled: !canRedo,\n          children: \"Redo\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 811,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 748,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 747,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"drawing-area\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"color-selector\",\n        style: {\n          display: 'flex',\n          flexDirection: 'column',\n          gap: '15px',\n          marginRight: '15px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => setDrawColor(true),\n          style: {\n            width: '30px',\n            height: '30px',\n            backgroundColor: '#fff',\n            border: drawColor ? '3px solid #2196F3' : '1px solid #666',\n            borderRadius: '4px',\n            cursor: 'pointer',\n            boxSizing: 'border-box',\n            boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\n          },\n          title: \"White (Draw)\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 820,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => setDrawColor(false),\n          style: {\n            width: '30px',\n            height: '30px',\n            backgroundColor: '#000',\n            border: !drawColor ? '3px solid #ff4444' : '1px solid #666',\n            borderRadius: '4px',\n            cursor: 'pointer',\n            boxSizing: 'border-box',\n            boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\n          },\n          title: \"Black (Eraser)\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 830,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 819,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"canvas-container\",\n        style: {\n          position: 'relative',\n          width: `${GRID_WIDTH * PIXEL_SIZE}px`,\n          height: `${GRID_HEIGHT * PIXEL_SIZE}px`\n        },\n        onMouseDown: handleCanvasMouseDown,\n        onMouseMove: handleCanvasMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: () => {\n          if (brushCanvasRef.current) brushCanvasRef.current.style.display = 'none';\n        },\n        onContextMenu: e => e.preventDefault(),\n        children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: canvasRef,\n          width: GRID_WIDTH,\n          height: GRID_HEIGHT,\n          style: {\n            width: '100%',\n            height: '100%',\n            imageRendering: 'pixelated',\n            cursor: isFreeformActive ? 'none' : isBucketFillModeActive ? 'cell' : 'crosshair',\n            border: '1px solid #666'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 854,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: brushCanvasRef,\n          width: GRID_WIDTH * PIXEL_SIZE,\n          height: GRID_HEIGHT * PIXEL_SIZE,\n          style: {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            pointerEvents: 'none',\n            display: 'none'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 866,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 843,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 817,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ResetButton, {\n      onReset: handleReset\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 883,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 702,\n    columnNumber: 5\n  }, this);\n};\n_s(PixelGrid, \"fniy4fs+qgko9oYJIILA7hFtPVs=\");\n_c = PixelGrid;\nexport default PixelGrid;\nvar _c;\n$RefreshReg$(_c, \"PixelGrid\");","map":{"version":3,"names":["React","useState","useRef","useEffect","useCallback","useMemo","drawLine","ESP32Connection","BMPHandler","ResetButton","jsxDEV","_jsxDEV","GRID_WIDTH","GRID_HEIGHT","PIXEL_SIZE","TOTAL_PIXELS","PixelGrid","_s","pixels","setPixels","Uint8Array","previewPixels","setPreviewPixels","isLineModeActive","setIsLineModeActive","isCircleModeActive","setIsCircleModeActive","isBucketFillModeActive","setIsBucketFillModeActive","isRectangleModeActive","setIsRectangleModeActive","isDrawingRef","startPointRef","lastPointRef","lastPointWasOutsideRef","isSpacePressed","setIsSpacePressed","currentIndexRef","brushSize","setBrushSize","drawColor","setDrawColor","canvasRef","brushCanvasRef","renderRequestRef","pixelsRef","previewPixelsRef","fps","setFps","frameCountRef","lastFpsTimeRef","performance","now","historyRef","historyIndexRef","canUndo","setCanUndo","canRedo","setCanRedo","addToHistory","newState","newHistory","current","slice","push","length","shift","undo","state","redo","renderCanvas","canvas","ctx","getContext","alpha","imageData","createImageData","data","currentPixels","currentPreview","i","offset","putImageData","scheduleRender","requestAnimationFrame","isFreeformActive","getLinePoints","start","end","points","x0","Math","max","min","x","y0","y","x1","y1","steep","abs","dx","dy","yStep","error","currentX","currentY","index","getCirclePoints","center","point","radius","floor","sqrt","pow","coords","forEach","px","py","getRectPoints","startX","startY","endX","endY","getBrushPoints","centerX","centerY","size","pixelX","round","pixelY","getCanvasCoordinates","e","rect","getBoundingClientRect","scaleX","width","scaleY","height","clientX","left","clientY","top","handleBucketFill","targetColor","fillColor","newPixels","stack","visited","Set","currentIndex","pop","has","add","handleCanvasMouseDown","button","clampedX","clampedY","isInBounds","prev","idx","handleCanvasMouseMove","updateBrushOutline","linePoints","allPoints","newPreview","handleMouseUp","setTimeout","handleGlobalMouseMove","handleGlobalMouseUp","window","addEventListener","removeEventListener","handleKeyDown","code","preventDefault","ctrlKey","metaKey","key","toLowerCase","shiftKey","handleKeyUp","brushCanvas","style","display","clearRect","strokeStyle","lineWidth","strokeRect","diamondPixels","newX","newY","beginPath","side","nx","ny","some","p","moveTo","lineTo","stroke","margin","right","bottom","handleReset","pixelsAsBoolArray","Array","from","map","handleBMPPixelUpdate","isArray","uint8Pixels","val","showBrushSizeControl","className","children","position","transform","backgroundColor","color","padding","borderRadius","fontFamily","fontSize","zIndex","fileName","_jsxFileName","lineNumber","columnNumber","pixelData","onPixelUpdate","visibility","htmlFor","minWidth","type","id","value","onChange","Number","target","justifyContent","boxSizing","marginLeft","marginRight","onClick","disabled","flexDirection","gap","border","cursor","boxShadow","title","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onContextMenu","ref","imageRendering","pointerEvents","onReset","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/ESP32_OLED_Drawing/src/components/pixelGrid/index.jsx"],"sourcesContent":["import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\r\nimport { drawLine } from './utils';\r\nimport ESP32Connection from '../ESP32Connection';\r\nimport BMPHandler from '../BMPHandler';\r\nimport ResetButton from './ResetButton';\r\n\r\nconst GRID_WIDTH = 128;\r\nconst GRID_HEIGHT = 64;\r\nconst PIXEL_SIZE = 8;\r\nconst TOTAL_PIXELS = GRID_WIDTH * GRID_HEIGHT;\r\n\r\nconst PixelGrid = () => {\r\n  // Use Uint8Array for better performance (0 = black, 1 = white)\r\n  const [pixels, setPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\r\n  const [previewPixels, setPreviewPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\r\n  \r\n  const [isLineModeActive, setIsLineModeActive] = useState(false);\r\n  const [isCircleModeActive, setIsCircleModeActive] = useState(false);\r\n  const [isBucketFillModeActive, setIsBucketFillModeActive] = useState(false);\r\n  const [isRectangleModeActive, setIsRectangleModeActive] = useState(false);\r\n  \r\n  const isDrawingRef = useRef(false);\r\n  const startPointRef = useRef(null);\r\n  const lastPointRef = useRef(null);\r\n  const lastPointWasOutsideRef = useRef(false);\r\n  const [isSpacePressed, setIsSpacePressed] = useState(false);\r\n  const currentIndexRef = useRef(null);\r\n  const [brushSize, setBrushSize] = useState(1);\r\n  const [drawColor, setDrawColor] = useState(true);\r\n  \r\n  // Canvas refs\r\n  const canvasRef = useRef(null);\r\n  const brushCanvasRef = useRef(null);\r\n  const renderRequestRef = useRef(null);\r\n  const pixelsRef = useRef(pixels);\r\n  const previewPixelsRef = useRef(previewPixels);\r\n  \r\n  // FPS counter\r\n  const [fps, setFps] = useState(0);\r\n  const frameCountRef = useRef(0);\r\n  const lastFpsTimeRef = useRef(performance.now());\r\n\r\n  // History for undo/redo - optimized\r\n  const historyRef = useRef([new Uint8Array(TOTAL_PIXELS)]);\r\n  const historyIndexRef = useRef(0);\r\n  const [canUndo, setCanUndo] = useState(false);\r\n  const [canRedo, setCanRedo] = useState(false);\r\n\r\n  const addToHistory = useCallback((newState) => {\r\n    const newHistory = historyRef.current.slice(0, historyIndexRef.current + 1);\r\n    newHistory.push(new Uint8Array(newState));\r\n    if (newHistory.length > 100) newHistory.shift();\r\n    historyRef.current = newHistory;\r\n    historyIndexRef.current = newHistory.length - 1;\r\n    setCanUndo(historyIndexRef.current > 0);\r\n    setCanRedo(false);\r\n  }, []);\r\n\r\n  const undo = useCallback(() => {\r\n    if (historyIndexRef.current > 0) {\r\n      historyIndexRef.current--;\r\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\r\n      setPixels(state);\r\n      setCanUndo(historyIndexRef.current > 0);\r\n      setCanRedo(true);\r\n    }\r\n  }, []);\r\n\r\n  const redo = useCallback(() => {\r\n    if (historyIndexRef.current < historyRef.current.length - 1) {\r\n      historyIndexRef.current++;\r\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\r\n      setPixels(state);\r\n      setCanUndo(true);\r\n      setCanRedo(historyIndexRef.current < historyRef.current.length - 1);\r\n    }\r\n  }, []);\r\n\r\n  // Keep pixelsRef in sync\r\n  useEffect(() => {\r\n    pixelsRef.current = pixels;\r\n  }, [pixels]);\r\n  \r\n  useEffect(() => {\r\n    previewPixelsRef.current = previewPixels;\r\n  }, [previewPixels]);\r\n\r\n  // Optimized canvas render function\r\n  const renderCanvas = useCallback(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    \r\n    const ctx = canvas.getContext('2d', { alpha: false });\r\n    const imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);\r\n    const data = imageData.data;\r\n    \r\n    const currentPixels = pixelsRef.current;\r\n    const currentPreview = previewPixelsRef.current;\r\n    \r\n    for (let i = 0; i < TOTAL_PIXELS; i++) {\r\n      const offset = i * 4;\r\n      if (currentPreview[i] === 1) {\r\n        // White preview\r\n        data[offset] = 255;\r\n        data[offset + 1] = 255;\r\n        data[offset + 2] = 255;\r\n      } else if (currentPreview[i] === 2) {\r\n        // Black preview (dark gray for visibility)\r\n        data[offset] = 34;\r\n        data[offset + 1] = 34;\r\n        data[offset + 2] = 34;\r\n      } else if (currentPixels[i] === 1) {\r\n        // White pixel\r\n        data[offset] = 255;\r\n        data[offset + 1] = 255;\r\n        data[offset + 2] = 255;\r\n      } else {\r\n        // Black pixel (background)\r\n        data[offset] = 17;\r\n        data[offset + 1] = 17;\r\n        data[offset + 2] = 17;\r\n      }\r\n      data[offset + 3] = 255;\r\n    }\r\n    \r\n    ctx.putImageData(imageData, 0, 0);\r\n    \r\n    // FPS counting\r\n    frameCountRef.current++;\r\n    const now = performance.now();\r\n    if (now - lastFpsTimeRef.current >= 1000) {\r\n      setFps(frameCountRef.current);\r\n      frameCountRef.current = 0;\r\n      lastFpsTimeRef.current = now;\r\n    }\r\n  }, []);\r\n\r\n  // Schedule render with requestAnimationFrame\r\n  const scheduleRender = useCallback(() => {\r\n    if (renderRequestRef.current) return;\r\n    renderRequestRef.current = requestAnimationFrame(() => {\r\n      renderCanvas();\r\n      renderRequestRef.current = null;\r\n    });\r\n  }, [renderCanvas]);\r\n\r\n  // Render on pixel changes\r\n  useEffect(() => {\r\n    scheduleRender();\r\n  }, [pixels, previewPixels, scheduleRender]);\r\n\r\n  // Initial render\r\n  useEffect(() => {\r\n    renderCanvas();\r\n  }, [renderCanvas]);\r\n\r\n  const isFreeformActive = !isLineModeActive && !isCircleModeActive && \r\n                           !isBucketFillModeActive && !isRectangleModeActive;\r\n\r\n  // Drawing utility functions\r\n  const getLinePoints = useCallback((start, end) => {\r\n    const points = [];\r\n    let x0 = Math.max(0, Math.min(127, start.x));\r\n    let y0 = Math.max(0, Math.min(63, start.y));\r\n    let x1 = Math.max(0, Math.min(127, end.x));\r\n    let y1 = Math.max(0, Math.min(63, end.y));\r\n\r\n    const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n    if (steep) { [x0, y0] = [y0, x0]; [x1, y1] = [y1, x1]; }\r\n    if (x0 > x1) { [x0, x1] = [x1, x0]; [y0, y1] = [y1, y0]; }\r\n\r\n    const dx = x1 - x0;\r\n    const dy = Math.abs(y1 - y0);\r\n    const yStep = y0 < y1 ? 1 : -1;\r\n    let error = dx / 2;\r\n    let y = y0;\r\n\r\n    for (let x = x0; x <= x1; x++) {\r\n      const currentX = steep ? y : x;\r\n      const currentY = steep ? x : y;\r\n      const index = currentY * GRID_WIDTH + currentX;\r\n      if (index >= 0 && index < TOTAL_PIXELS) points.push(index);\r\n      error -= dy;\r\n      if (error < 0) { y += yStep; error += dx; }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  const getCirclePoints = useCallback((center, point) => {\r\n    const points = [];\r\n    const radius = Math.floor(Math.sqrt(\r\n      Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)\r\n    ));\r\n\r\n    let x = radius, y = 0, error = 0;\r\n    while (x >= y) {\r\n      const coords = [\r\n        [center.x + x, center.y + y], [center.x + y, center.y + x],\r\n        [center.x - y, center.y + x], [center.x - x, center.y + y],\r\n        [center.x - x, center.y - y], [center.x - y, center.y - x],\r\n        [center.x + y, center.y - x], [center.x + x, center.y - y],\r\n      ];\r\n      coords.forEach(([px, py]) => {\r\n        if (px >= 0 && px < GRID_WIDTH && py >= 0 && py < GRID_HEIGHT) {\r\n          points.push(py * GRID_WIDTH + px);\r\n        }\r\n      });\r\n      y++;\r\n      error += 1 + 2 * y;\r\n      if (2 * (error - x) + 1 > 0) { x--; error += 1 - 2 * x; }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  const getRectPoints = useCallback((start, end) => {\r\n    const points = [];\r\n    const startX = Math.max(0, Math.min(start.x, end.x));\r\n    const startY = Math.max(0, Math.min(start.y, end.y));\r\n    const endX = Math.min(127, Math.max(start.x, end.x));\r\n    const endY = Math.min(63, Math.max(start.y, end.y));\r\n    \r\n    for (let x = startX; x <= endX; x++) {\r\n      if (startY >= 0 && startY < GRID_HEIGHT) points.push(startY * GRID_WIDTH + x);\r\n      if (endY >= 0 && endY < GRID_HEIGHT && endY !== startY) points.push(endY * GRID_WIDTH + x);\r\n    }\r\n    for (let y = startY + 1; y < endY; y++) {\r\n      if (startX >= 0 && startX < GRID_WIDTH) points.push(y * GRID_WIDTH + startX);\r\n      if (endX >= 0 && endX < GRID_WIDTH && endX !== startX) points.push(y * GRID_WIDTH + endX);\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  // Get brush pattern points (now accepts non-integer coordinates)\r\n  const getBrushPoints = useCallback((centerX, centerY, size) => {\r\n    const points = [];\r\n    // Round to nearest pixel for center\r\n    const pixelX = Math.round(centerX);\r\n    const pixelY = Math.round(centerY);\r\n    \r\n    for (let offset = 0; offset < size; offset++) {\r\n      for (let i = -offset; i <= offset; i++) {\r\n        const coords = [\r\n          { x: pixelX + i, y: pixelY - (size - 1 - offset) },\r\n          { x: pixelX + i, y: pixelY + (size - 1 - offset) },\r\n          { x: pixelX - (size - 1 - offset), y: pixelY + i },\r\n          { x: pixelX + (size - 1 - offset), y: pixelY + i }\r\n        ];\r\n        coords.forEach(point => {\r\n          if (point.x >= 0 && point.x < GRID_WIDTH && point.y >= 0 && point.y < GRID_HEIGHT) {\r\n            points.push(point.y * GRID_WIDTH + point.x);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  // Get coordinates from canvas position\r\n  const getCanvasCoordinates = useCallback((e) => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return null;\r\n    \r\n    const rect = canvas.getBoundingClientRect();\r\n    const scaleX = GRID_WIDTH / rect.width;\r\n    const scaleY = GRID_HEIGHT / rect.height;\r\n    \r\n    const x = Math.floor((e.clientX - rect.left) * scaleX);\r\n    const y = Math.floor((e.clientY - rect.top) * scaleY);\r\n    \r\n    return { x, y };\r\n  }, []);\r\n\r\n  // Bucket fill\r\n  const handleBucketFill = useCallback((index) => {\r\n    const currentPixels = pixelsRef.current;\r\n    const targetColor = currentPixels[index];\r\n    const fillColor = drawColor ? 1 : 0;\r\n    if (targetColor === fillColor) return;\r\n\r\n    const newPixels = new Uint8Array(currentPixels);\r\n    const stack = [index];\r\n    const visited = new Set();\r\n\r\n    while (stack.length > 0) {\r\n      const currentIndex = stack.pop();\r\n      if (visited.has(currentIndex) || newPixels[currentIndex] !== targetColor) continue;\r\n      visited.add(currentIndex);\r\n      newPixels[currentIndex] = fillColor;\r\n\r\n      const x = currentIndex % GRID_WIDTH;\r\n      const y = Math.floor(currentIndex / GRID_WIDTH);\r\n\r\n      if (x > 0) stack.push(currentIndex - 1);\r\n      if (x < GRID_WIDTH - 1) stack.push(currentIndex + 1);\r\n      if (y > 0) stack.push(currentIndex - GRID_WIDTH);\r\n      if (y < GRID_HEIGHT - 1) stack.push(currentIndex + GRID_WIDTH);\r\n    }\r\n\r\n    setPixels(newPixels);\r\n    addToHistory(newPixels);\r\n  }, [drawColor, addToHistory]);\r\n\r\n  // Mouse event handlers\r\n  const handleCanvasMouseDown = useCallback((e) => {\r\n    if (e.button !== 0) return;\r\n    \r\n    const coords = getCanvasCoordinates(e);\r\n    if (!coords) return;\r\n    \r\n    const clampedX = Math.max(0, Math.min(GRID_WIDTH - 1, coords.x));\r\n    const clampedY = Math.max(0, Math.min(GRID_HEIGHT - 1, coords.y));\r\n    const index = clampedY * GRID_WIDTH + clampedX;\r\n    \r\n    isDrawingRef.current = true;\r\n    currentIndexRef.current = index;\r\n    \r\n    // Check if coords are within bounds\r\n    const isInBounds = coords.x >= 0 && coords.x < GRID_WIDTH && coords.y >= 0 && coords.y < GRID_HEIGHT;\r\n    \r\n    if (isBucketFillModeActive) {\r\n      if (isInBounds) {\r\n        handleBucketFill(index);\r\n      }\r\n      isDrawingRef.current = false;\r\n      return;\r\n    }\r\n    \r\n    if (isFreeformActive) {\r\n      lastPointRef.current = { x: coords.x, y: coords.y };\r\n      lastPointWasOutsideRef.current = !isInBounds;\r\n      // Draw any parts that are visible in the grid\r\n      const points = getBrushPoints(coords.x, coords.y, brushSize);\r\n      if (points.length > 0) {\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          points.forEach(idx => { newPixels[idx] = drawColor ? 1 : 0; });\r\n          return newPixels;\r\n        });\r\n      }\r\n    } else {\r\n      startPointRef.current = coords;\r\n      lastPointRef.current = coords;\r\n    }\r\n  }, [isBucketFillModeActive, isFreeformActive, handleBucketFill, getCanvasCoordinates, getBrushPoints, brushSize, drawColor]);\r\n\r\n  const handleCanvasMouseMove = useCallback((e) => {\r\n    const coords = getCanvasCoordinates(e);\r\n    if (!coords) return;\r\n    \r\n    const clampedX = Math.max(0, Math.min(GRID_WIDTH - 1, coords.x));\r\n    const clampedY = Math.max(0, Math.min(GRID_HEIGHT - 1, coords.y));\r\n    const index = clampedY * GRID_WIDTH + clampedX;\r\n    currentIndexRef.current = index;\r\n    \r\n    // Update brush outline\r\n    updateBrushOutline(e);\r\n    \r\n    if (!isDrawingRef.current) return;\r\n    \r\n    if (isFreeformActive && lastPointRef.current) {\r\n      const isInBounds = coords.x >= 0 && coords.x < GRID_WIDTH && coords.y >= 0 && coords.y < GRID_HEIGHT;\r\n      \r\n      // If we just re-entered from outside, don't connect - start fresh\r\n      if (lastPointWasOutsideRef.current && isInBounds) {\r\n        lastPointRef.current = { x: coords.x, y: coords.y };\r\n        lastPointWasOutsideRef.current = false;\r\n        const points = getBrushPoints(coords.x, coords.y, brushSize);\r\n        if (points.length > 0) {\r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            points.forEach(idx => { newPixels[idx] = drawColor ? 1 : 0; });\r\n            return newPixels;\r\n          });\r\n        }\r\n        return;\r\n      }\r\n      \r\n      // Draw line from last point to current point\r\n      const linePoints = drawLine(lastPointRef.current, { x: coords.x, y: coords.y });\r\n      const allPoints = [];\r\n      linePoints.forEach(idx => {\r\n        const centerX = idx % GRID_WIDTH;\r\n        const centerY = Math.floor(idx / GRID_WIDTH);\r\n        allPoints.push(...getBrushPoints(centerX, centerY, brushSize));\r\n      });\r\n      \r\n      if (allPoints.length > 0) {\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          allPoints.forEach(idx => {\r\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n              newPixels[idx] = drawColor ? 1 : 0;\r\n            }\r\n          });\r\n          return newPixels;\r\n        });\r\n      }\r\n      \r\n      lastPointRef.current = { x: coords.x, y: coords.y };\r\n      lastPointWasOutsideRef.current = !isInBounds;\r\n    } else if (isLineModeActive && startPointRef.current) {\r\n      const points = getLinePoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    } else if (isCircleModeActive && startPointRef.current) {\r\n      const points = getCirclePoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    } else if (isRectangleModeActive && startPointRef.current) {\r\n      const points = getRectPoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    }\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isFreeformActive, isLineModeActive, isCircleModeActive, isRectangleModeActive,\r\n      getCanvasCoordinates, getBrushPoints, getLinePoints, getCirclePoints, getRectPoints,\r\n      brushSize, drawColor]);\r\n\r\n  const handleMouseUp = useCallback(() => {\r\n    if (!isDrawingRef.current) return;\r\n    \r\n    if ((isLineModeActive || isCircleModeActive || isRectangleModeActive) && \r\n        startPointRef.current && lastPointRef.current) {\r\n      \r\n      let points = [];\r\n      if (isLineModeActive) {\r\n        points = getLinePoints(startPointRef.current, lastPointRef.current);\r\n      } else if (isCircleModeActive) {\r\n        points = getCirclePoints(startPointRef.current, lastPointRef.current);\r\n      } else if (isRectangleModeActive) {\r\n        points = getRectPoints(startPointRef.current, lastPointRef.current);\r\n      }\r\n      \r\n      if (points.length > 0) {\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          points.forEach(idx => {\r\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n              newPixels[idx] = drawColor ? 1 : 0;\r\n            }\r\n          });\r\n          // Add to history after state update\r\n          setTimeout(() => addToHistory(newPixels), 0);\r\n          return newPixels;\r\n        });\r\n      }\r\n      setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n    } else if (isFreeformActive) {\r\n      addToHistory(pixelsRef.current);\r\n    }\r\n    \r\n    isDrawingRef.current = false;\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, isFreeformActive,\r\n      drawColor, getLinePoints, getCirclePoints, getRectPoints, addToHistory]);\r\n\r\n  // Global mouse events for drawing outside the grid\r\n  useEffect(() => {\r\n    const handleGlobalMouseMove = (e) => {\r\n      if (isDrawingRef.current && (isLineModeActive || isCircleModeActive || isRectangleModeActive)) {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n        \r\n        const rect = canvas.getBoundingClientRect();\r\n        const scaleX = GRID_WIDTH / rect.width;\r\n        const scaleY = GRID_HEIGHT / rect.height;\r\n        \r\n        // Allow coordinates outside the grid\r\n        const x = Math.floor((e.clientX - rect.left) * scaleX);\r\n        const y = Math.floor((e.clientY - rect.top) * scaleY);\r\n        const coords = { x, y };\r\n        \r\n        let points = [];\r\n        if (isLineModeActive && startPointRef.current) {\r\n          points = getLinePoints(startPointRef.current, coords);\r\n        } else if (isCircleModeActive && startPointRef.current) {\r\n          points = getCirclePoints(startPointRef.current, coords);\r\n        } else if (isRectangleModeActive && startPointRef.current) {\r\n          points = getRectPoints(startPointRef.current, coords);\r\n        }\r\n        \r\n        const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n        points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n        setPreviewPixels(newPreview);\r\n        lastPointRef.current = coords;\r\n      }\r\n    };\r\n\r\n    const handleGlobalMouseUp = () => {\r\n      if (isDrawingRef.current) {\r\n        handleMouseUp();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleGlobalMouseMove);\r\n    window.addEventListener('mouseup', handleGlobalMouseUp);\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\r\n      window.removeEventListener('mouseup', handleGlobalMouseUp);\r\n    };\r\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, drawColor,\r\n      getLinePoints, getCirclePoints, getRectPoints, handleMouseUp]);\r\n\r\n  // Keyboard shortcuts\r\n  useEffect(() => {\r\n    const handleKeyDown = (e) => {\r\n      if (e.code === 'Space' && !isSpacePressed && currentIndexRef.current !== null) {\r\n        e.preventDefault();\r\n        setIsSpacePressed(true);\r\n        // Trigger drawing at current position\r\n        const index = currentIndexRef.current;\r\n        isDrawingRef.current = true;\r\n        if (isFreeformActive) {\r\n          const x = index % GRID_WIDTH;\r\n          const y = Math.floor(index / GRID_WIDTH);\r\n          lastPointRef.current = { x, y };\r\n          const points = getBrushPoints(x, y, brushSize);\r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            points.forEach(idx => { newPixels[idx] = drawColor ? 1 : 0; });\r\n            return newPixels;\r\n          });\r\n        }\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\r\n        e.preventDefault();\r\n        if (e.shiftKey) {\r\n          redo();\r\n        } else {\r\n          undo();\r\n        }\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\r\n        e.preventDefault();\r\n        redo();\r\n      } else if (e.key === 'b') {\r\n        e.preventDefault();\r\n        setIsLineModeActive(false);\r\n        setIsCircleModeActive(false);\r\n        setIsBucketFillModeActive(false);\r\n        setIsRectangleModeActive(false);\r\n      }\r\n    };\r\n\r\n    const handleKeyUp = (e) => {\r\n      if (e.code === 'Space') {\r\n        e.preventDefault();\r\n        setIsSpacePressed(false);\r\n        if (isDrawingRef.current) {\r\n          addToHistory(pixelsRef.current);\r\n          isDrawingRef.current = false;\r\n          lastPointRef.current = null;\r\n        }\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, [isSpacePressed, isFreeformActive, brushSize, drawColor, getBrushPoints, undo, redo, addToHistory]);\r\n\r\n  // Brush outline rendering\r\n  const updateBrushOutline = useCallback((e) => {\r\n    const brushCanvas = brushCanvasRef.current;\r\n    if (!brushCanvas || !isFreeformActive) {\r\n      if (brushCanvas) brushCanvas.style.display = 'none';\r\n      return;\r\n    }\r\n\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const rect = canvas.getBoundingClientRect();\r\n    \r\n    // Calculate pixel position (allow outside bounds)\r\n    const scaleX = GRID_WIDTH / rect.width;\r\n    const scaleY = GRID_HEIGHT / rect.height;\r\n    const pixelX = Math.floor((e.clientX - rect.left) * scaleX);\r\n    const pixelY = Math.floor((e.clientY - rect.top) * scaleY);\r\n\r\n    const ctx = brushCanvas.getContext('2d');\r\n    ctx.clearRect(0, 0, brushCanvas.width, brushCanvas.height);\r\n    ctx.strokeStyle = drawColor ? '#fff' : '#f00';\r\n    ctx.lineWidth = 1;\r\n\r\n    if (brushSize === 1) {\r\n      // Only draw if any part would be visible in the grid\r\n      if (pixelX >= 0 && pixelX < GRID_WIDTH && pixelY >= 0 && pixelY < GRID_HEIGHT) {\r\n        ctx.strokeRect(pixelX * PIXEL_SIZE + 0.5, pixelY * PIXEL_SIZE + 0.5, PIXEL_SIZE - 1, PIXEL_SIZE - 1);\r\n      }\r\n    } else {\r\n      const diamondPixels = [];\r\n      for (let y = -brushSize + 1; y < brushSize; y++) {\r\n        for (let x = -brushSize + 1; x < brushSize; x++) {\r\n          if (Math.abs(x) + Math.abs(y) < brushSize) {\r\n            const newX = pixelX + x;\r\n            const newY = pixelY + y;\r\n            // Include pixels even outside grid for outline calculation\r\n            if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) {\r\n              diamondPixels.push({ x: newX, y: newY });\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (diamondPixels.length > 0) {\r\n        ctx.beginPath();\r\n        diamondPixels.forEach(({ x, y }) => {\r\n          [{ dx: 0, dy: -1, side: 'top' }, { dx: 1, dy: 0, side: 'right' },\r\n           { dx: 0, dy: 1, side: 'bottom' }, { dx: -1, dy: 0, side: 'left' }]\r\n          .forEach(({ dx, dy, side }) => {\r\n            const nx = x + dx;\r\n            const ny = y + dy;\r\n            if (!diamondPixels.some(p => p.x === nx && p.y === ny)) {\r\n              const px = x * PIXEL_SIZE;\r\n              const py = y * PIXEL_SIZE;\r\n              if (side === 'top') { ctx.moveTo(px, py); ctx.lineTo(px + PIXEL_SIZE, py); }\r\n              else if (side === 'right') { ctx.moveTo(px + PIXEL_SIZE, py); ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE); }\r\n              else if (side === 'bottom') { ctx.moveTo(px, py + PIXEL_SIZE); ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE); }\r\n              else if (side === 'left') { ctx.moveTo(px, py); ctx.lineTo(px, py + PIXEL_SIZE); }\r\n            }\r\n          });\r\n        });\r\n        ctx.stroke();\r\n      }\r\n    }\r\n\r\n    brushCanvas.style.display = 'block';\r\n  }, [isFreeformActive, brushSize, drawColor]);\r\n\r\n  // Update brush outline on global mouse move for freeform mode\r\n  useEffect(() => {\r\n    if (!isFreeformActive) return;\r\n\r\n    const handleGlobalMouseMove = (e) => {\r\n      const canvas = canvasRef.current;\r\n      if (!canvas) return;\r\n\r\n      const rect = canvas.getBoundingClientRect();\r\n      // Determine if we're reasonably close to the canvas\r\n      const margin = brushSize * PIXEL_SIZE * 2; // Allow brush size distance from edges\r\n      if (\r\n        e.clientX >= rect.left - margin &&\r\n        e.clientX <= rect.right + margin &&\r\n        e.clientY >= rect.top - margin &&\r\n        e.clientY <= rect.bottom + margin\r\n      ) {\r\n        updateBrushOutline(e);\r\n      } else {\r\n        // Hide if too far from canvas\r\n        const brushCanvas = brushCanvasRef.current;\r\n        if (brushCanvas) brushCanvas.style.display = 'none';\r\n      }\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleGlobalMouseMove);\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\r\n    };\r\n  }, [isFreeformActive, brushSize, updateBrushOutline]);\r\n\r\n  const handleReset = useCallback(() => {\r\n    const newState = new Uint8Array(TOTAL_PIXELS);\r\n    setPixels(newState);\r\n    setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n    isDrawingRef.current = false;\r\n    addToHistory(newState);\r\n  }, [addToHistory]);\r\n\r\n  // Convert Uint8Array to boolean array for ESP32Connection and BMPHandler compatibility\r\n  const pixelsAsBoolArray = useMemo(() => {\r\n    return Array.from(pixels).map(p => p === 1);\r\n  }, [pixels]);\r\n\r\n  const handleBMPPixelUpdate = useCallback((newPixels) => {\r\n    if (Array.isArray(newPixels)) {\r\n      const uint8Pixels = new Uint8Array(TOTAL_PIXELS);\r\n      newPixels.forEach((val, i) => {\r\n        uint8Pixels[i] = val ? 1 : 0;\r\n      });\r\n      setPixels(uint8Pixels);\r\n      addToHistory(uint8Pixels);\r\n    }\r\n  }, [addToHistory]);\r\n\r\n  const showBrushSizeControl = isFreeformActive;\r\n\r\n  return (\r\n    <div className=\"pixel-grid-container\">\r\n      {/* FPS Counter */}\r\n      <div style={{\r\n        position: 'absolute',\r\n        top: '10px',\r\n        left: '50%',\r\n        transform: 'translateX(-50%)',\r\n        backgroundColor: 'rgba(0,0,0,0.7)',\r\n        color: fps < 30 ? '#ff4444' : fps < 50 ? '#ffaa00' : '#44ff44',\r\n        padding: '5px 15px',\r\n        borderRadius: '4px',\r\n        fontFamily: 'monospace',\r\n        fontSize: '14px',\r\n        zIndex: 1001\r\n      }}>\r\n        FPS: {fps}\r\n      </div>\r\n\r\n      {/* ESP32 Button */}\r\n      <div className=\"esp32-container\" style={{ position: 'fixed', top: '10px', left: '10px', zIndex: 1000 }}>\r\n        <ESP32Connection pixelData={pixelsAsBoolArray} />\r\n      </div>\r\n      \r\n      {/* BMP Buttons */}\r\n      <div className=\"bmp-container\" style={{ position: 'fixed', top: '10px', right: '10px', zIndex: 1000 }}>\r\n        <BMPHandler pixelData={pixelsAsBoolArray} onPixelUpdate={handleBMPPixelUpdate} />\r\n      </div>\r\n\r\n      {/* Brush size control */}\r\n      <div className=\"brush-size-control\" style={{ visibility: showBrushSizeControl ? 'visible' : 'hidden' }}>\r\n        <label htmlFor=\"brushSize\" style={{ color: 'white', minWidth: '100px' }}>\r\n          Brush Size: {brushSize}\r\n        </label>\r\n        <input\r\n          type=\"range\"\r\n          id=\"brushSize\"\r\n          className=\"brush-size-slider\"\r\n          min=\"1\"\r\n          max=\"5\"\r\n          value={brushSize}\r\n          onChange={(e) => setBrushSize(Number(e.target.value))}\r\n        />\r\n      </div>\r\n      \r\n      {/* Mode buttons */}\r\n      <div style={{ display: 'flex', justifyContent: 'center', width: '100%', position: 'relative' }}>\r\n        <div className=\"mode-buttons-container\" style={{\r\n          position: 'relative', left: '22px', width: '1024px',\r\n          boxSizing: 'border-box', marginLeft: 'auto', marginRight: 'auto'\r\n        }}>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n              setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n            }}\r\n            className={`mode-button ${isFreeformActive ? 'active' : ''}`}\r\n          >\r\n            Freeform Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(true);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isLineModeActive ? 'active' : ''}`}\r\n          >\r\n            Line Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(true);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isCircleModeActive ? 'active' : ''}`}\r\n          >\r\n            Circle Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(true);\r\n            }}\r\n            className={`mode-button ${isRectangleModeActive ? 'active' : ''}`}\r\n          >\r\n            Rectangle Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(true);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isBucketFillModeActive ? 'active' : ''}`}\r\n          >\r\n            Bucket Fill\r\n          </button>\r\n          <button onClick={undo} className=\"mode-button\" disabled={!canUndo} style={{ marginLeft: 'auto' }}>\r\n            Undo\r\n          </button>\r\n          <button onClick={redo} className=\"mode-button\" disabled={!canRedo}>\r\n            Redo\r\n          </button>\r\n        </div>\r\n      </div>\r\n      \r\n      <div className=\"drawing-area\">\r\n        {/* Color selection */}\r\n        <div className=\"color-selector\" style={{ display: 'flex', flexDirection: 'column', gap: '15px', marginRight: '15px' }}>\r\n          <div \r\n            onClick={() => setDrawColor(true)}\r\n            style={{\r\n              width: '30px', height: '30px', backgroundColor: '#fff',\r\n              border: drawColor ? '3px solid #2196F3' : '1px solid #666',\r\n              borderRadius: '4px', cursor: 'pointer', boxSizing: 'border-box',\r\n              boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\r\n            }}\r\n            title=\"White (Draw)\"\r\n          />\r\n          <div \r\n            onClick={() => setDrawColor(false)}\r\n            style={{\r\n              width: '30px', height: '30px', backgroundColor: '#000',\r\n              border: !drawColor ? '3px solid #ff4444' : '1px solid #666',\r\n              borderRadius: '4px', cursor: 'pointer', boxSizing: 'border-box',\r\n              boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\r\n            }}\r\n            title=\"Black (Eraser)\"\r\n          />\r\n        </div>\r\n        \r\n        {/* Canvas-based pixel grid */}\r\n        <div \r\n          className=\"canvas-container\"\r\n          style={{ position: 'relative', width: `${GRID_WIDTH * PIXEL_SIZE}px`, height: `${GRID_HEIGHT * PIXEL_SIZE}px` }}\r\n          onMouseDown={handleCanvasMouseDown}\r\n          onMouseMove={handleCanvasMouseMove}\r\n          onMouseUp={handleMouseUp}\r\n          onMouseLeave={() => {\r\n            if (brushCanvasRef.current) brushCanvasRef.current.style.display = 'none';\r\n          }}\r\n          onContextMenu={(e) => e.preventDefault()}\r\n        >\r\n          <canvas\r\n            ref={canvasRef}\r\n            width={GRID_WIDTH}\r\n            height={GRID_HEIGHT}\r\n            style={{\r\n              width: '100%',\r\n              height: '100%',\r\n              imageRendering: 'pixelated',\r\n              cursor: isFreeformActive ? 'none' : isBucketFillModeActive ? 'cell' : 'crosshair',\r\n              border: '1px solid #666'\r\n            }}\r\n          />\r\n          <canvas\r\n            ref={brushCanvasRef}\r\n            width={GRID_WIDTH * PIXEL_SIZE}\r\n            height={GRID_HEIGHT * PIXEL_SIZE}\r\n            style={{\r\n              position: 'absolute',\r\n              top: 0,\r\n              left: 0,\r\n              width: '100%',\r\n              height: '100%',\r\n              pointerEvents: 'none',\r\n              display: 'none'\r\n            }}\r\n          />\r\n        </div>\r\n      </div>\r\n      \r\n      <ResetButton onReset={handleReset} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PixelGrid;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}