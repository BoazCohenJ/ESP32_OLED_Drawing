{"ast":null,"code":"import React from 'react';\nimport { getIndex } from './utils';\nconst EraserMode = ({\n  isActive,\n  onPixelUpdate,\n  brushSize = 1\n}) => {\n  // Calculate all points within the brush radius\n  const getPointsInRadius = (centerIndex, radius) => {\n    const centerX = centerIndex % 128;\n    const centerY = Math.floor(centerIndex / 128);\n    const points = [];\n    for (let y = -radius; y <= radius; y++) {\n      for (let x = -radius; x <= radius; x++) {\n        // Check if point is within circular brush area\n        if (x * x + y * y <= radius * radius) {\n          const newX = centerX + x;\n          const newY = centerY + y;\n\n          // Make sure we're within bounds\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\n            const index = getIndex(newX, newY);\n            points.push(index);\n          }\n        }\n      }\n    }\n    return points;\n  };\n\n  // Replace the existing getPointsForBrush function with this one\n  const getPointsForBrush = centerIndex => {\n    const centerX = centerIndex % 128;\n    const centerY = Math.floor(centerIndex / 128);\n    const points = [];\n\n    // For a single pixel\n    if (brushSize === 1) {\n      points.push(centerIndex);\n      return points;\n    }\n\n    // For larger brush sizes, use a diamond pattern\n    for (let y = -brushSize + 1; y < brushSize; y++) {\n      for (let x = -brushSize + 1; x < brushSize; x++) {\n        // Use Manhattan distance for diamond shape\n        if (Math.abs(x) + Math.abs(y) < brushSize) {\n          const newX = centerX + x;\n          const newY = centerY + y;\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\n            const index = getIndex(newX, newY);\n            points.push(index);\n          }\n        }\n      }\n    }\n    return points;\n  };\n  const erase = index => {\n    if (!isActive) return;\n    const radius = Math.floor(brushSize / 2);\n    const pointsToErase = getPointsInRadius(index, radius);\n    onPixelUpdate(prevPixels => {\n      const newPixels = [...prevPixels];\n      pointsToErase.forEach(idx => {\n        newPixels[idx] = false; // Set to false to erase\n      });\n      return newPixels;\n    });\n  };\n  const drawLine = (start, end) => {\n    if (!isActive) return start;\n    const startX = start.x;\n    const startY = start.y;\n    const endX = end.x;\n    const endY = end.y;\n\n    // Calculate the distance between the points\n    const dx = Math.abs(endX - startX);\n    const dy = Math.abs(endY - startY);\n    const sx = startX < endX ? 1 : -1;\n    const sy = startY < endY ? 1 : -1;\n    let err = dx - dy;\n    let currentX = startX;\n    let currentY = startY;\n    while (true) {\n      // Erase at the current position\n      const index = getIndex(currentX, currentY);\n      erase(index);\n\n      // Check if we've reached the end\n      if (currentX === endX && currentY === endY) break;\n\n      // Calculate the next position\n      const e2 = 2 * err;\n      if (e2 > -dy) {\n        err -= dy;\n        currentX += sx;\n      }\n      if (e2 < dx) {\n        err += dx;\n        currentY += sy;\n      }\n    }\n    return {\n      x: endX,\n      y: endY\n    };\n  };\n  const handleStart = index => {\n    if (!isActive) return;\n    erase(index);\n  };\n  const handleDraw = (startPoint, endIndex) => {\n    if (!isActive || !startPoint) return startPoint;\n    const endX = endIndex % 128;\n    const endY = Math.floor(endIndex / 128);\n    const endPoint = {\n      x: endX,\n      y: endY\n    };\n    return drawLine(startPoint, endPoint);\n  };\n  return {\n    handleStart,\n    handleDraw,\n    modeName: 'Eraser',\n    isActive\n  };\n};\n_c = EraserMode;\nexport default EraserMode;\nvar _c;\n$RefreshReg$(_c, \"EraserMode\");","map":{"version":3,"names":["React","getIndex","EraserMode","isActive","onPixelUpdate","brushSize","getPointsInRadius","centerIndex","radius","centerX","centerY","Math","floor","points","y","x","newX","newY","index","push","getPointsForBrush","abs","erase","pointsToErase","prevPixels","newPixels","forEach","idx","drawLine","start","end","startX","startY","endX","endY","dx","dy","sx","sy","err","currentX","currentY","e2","handleStart","handleDraw","startPoint","endIndex","endPoint","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/EraserMode.jsx"],"sourcesContent":["import React from 'react';\r\nimport { getIndex } from './utils';\r\n\r\nconst EraserMode = ({ isActive, onPixelUpdate, brushSize = 1 }) => {\r\n  // Calculate all points within the brush radius\r\n  const getPointsInRadius = (centerIndex, radius) => {\r\n    const centerX = centerIndex % 128;\r\n    const centerY = Math.floor(centerIndex / 128);\r\n    const points = [];\r\n\r\n    for (let y = -radius; y <= radius; y++) {\r\n      for (let x = -radius; x <= radius; x++) {\r\n        // Check if point is within circular brush area\r\n        if (x*x + y*y <= radius*radius) {\r\n          const newX = centerX + x;\r\n          const newY = centerY + y;\r\n          \r\n          // Make sure we're within bounds\r\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\r\n            const index = getIndex(newX, newY);\r\n            points.push(index);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return points;\r\n  };\r\n\r\n  // Replace the existing getPointsForBrush function with this one\r\n  const getPointsForBrush = (centerIndex) => {\r\n    const centerX = centerIndex % 128;\r\n    const centerY = Math.floor(centerIndex / 128);\r\n    const points = [];\r\n\r\n    // For a single pixel\r\n    if (brushSize === 1) {\r\n      points.push(centerIndex);\r\n      return points;\r\n    }\r\n\r\n    // For larger brush sizes, use a diamond pattern\r\n    for (let y = -brushSize + 1; y < brushSize; y++) {\r\n      for (let x = -brushSize + 1; x < brushSize; x++) {\r\n        // Use Manhattan distance for diamond shape\r\n        if (Math.abs(x) + Math.abs(y) < brushSize) {\r\n          const newX = centerX + x;\r\n          const newY = centerY + y;\r\n          \r\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\r\n            const index = getIndex(newX, newY);\r\n            points.push(index);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return points;\r\n  };\r\n\r\n  const erase = (index) => {\r\n    if (!isActive) return;\r\n\r\n    const radius = Math.floor(brushSize / 2);\r\n    const pointsToErase = getPointsInRadius(index, radius);\r\n    \r\n    onPixelUpdate(prevPixels => {\r\n      const newPixels = [...prevPixels];\r\n      pointsToErase.forEach(idx => {\r\n        newPixels[idx] = false; // Set to false to erase\r\n      });\r\n      return newPixels;\r\n    });\r\n  };\r\n\r\n  const drawLine = (start, end) => {\r\n    if (!isActive) return start;\r\n    \r\n    const startX = start.x;\r\n    const startY = start.y;\r\n    const endX = end.x;\r\n    const endY = end.y;\r\n    \r\n    // Calculate the distance between the points\r\n    const dx = Math.abs(endX - startX);\r\n    const dy = Math.abs(endY - startY);\r\n    const sx = startX < endX ? 1 : -1;\r\n    const sy = startY < endY ? 1 : -1;\r\n    let err = dx - dy;\r\n    \r\n    let currentX = startX;\r\n    let currentY = startY;\r\n    \r\n    while (true) {\r\n      // Erase at the current position\r\n      const index = getIndex(currentX, currentY);\r\n      erase(index);\r\n      \r\n      // Check if we've reached the end\r\n      if (currentX === endX && currentY === endY) break;\r\n      \r\n      // Calculate the next position\r\n      const e2 = 2 * err;\r\n      if (e2 > -dy) {\r\n        err -= dy;\r\n        currentX += sx;\r\n      }\r\n      if (e2 < dx) {\r\n        err += dx;\r\n        currentY += sy;\r\n      }\r\n    }\r\n    \r\n    return { x: endX, y: endY };\r\n  };\r\n\r\n  const handleStart = (index) => {\r\n    if (!isActive) return;\r\n    erase(index);\r\n  };\r\n\r\n  const handleDraw = (startPoint, endIndex) => {\r\n    if (!isActive || !startPoint) return startPoint;\r\n    \r\n    const endX = endIndex % 128;\r\n    const endY = Math.floor(endIndex / 128);\r\n    const endPoint = { x: endX, y: endY };\r\n    \r\n    return drawLine(startPoint, endPoint);\r\n  };\r\n\r\n  return {\r\n    handleStart,\r\n    handleDraw,\r\n    modeName: 'Eraser',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default EraserMode;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}