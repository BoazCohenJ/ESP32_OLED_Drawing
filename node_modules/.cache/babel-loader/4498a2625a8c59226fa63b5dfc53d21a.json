{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wikx3\\\\Documents\\\\VS_code\\\\React\\\\ESP32_OLED_Drawing\\\\src\\\\components\\\\pixelGrid\\\\index.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\nimport { drawLine } from './utils';\nimport ESP32Connection from '../ESP32Connection';\nimport BMPHandler from '../BMPHandler';\nimport ResetButton from './ResetButton';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GRID_WIDTH = 128;\nconst GRID_HEIGHT = 64;\nconst PIXEL_SIZE = 8;\nconst TOTAL_PIXELS = GRID_WIDTH * GRID_HEIGHT;\nconst PixelGrid = () => {\n  _s();\n  // Use Uint8Array for better performance (0 = black, 1 = white)\n  const [pixels, setPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\n  const [previewPixels, setPreviewPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\n  const [isLineModeActive, setIsLineModeActive] = useState(false);\n  const [isCircleModeActive, setIsCircleModeActive] = useState(false);\n  const [isBucketFillModeActive, setIsBucketFillModeActive] = useState(false);\n  const [isRectangleModeActive, setIsRectangleModeActive] = useState(false);\n  const isDrawingRef = useRef(false);\n  const startPointRef = useRef(null);\n  const lastPointRef = useRef(null);\n  const [isSpacePressed, setIsSpacePressed] = useState(false);\n  const currentIndexRef = useRef(null);\n  const [brushSize, setBrushSize] = useState(1);\n  const [drawColor, setDrawColor] = useState(true);\n\n  // Canvas refs\n  const canvasRef = useRef(null);\n  const brushCanvasRef = useRef(null);\n  const renderRequestRef = useRef(null);\n  const pixelsRef = useRef(pixels);\n  const previewPixelsRef = useRef(previewPixels);\n\n  // FPS counter\n  const [fps, setFps] = useState(0);\n  const frameCountRef = useRef(0);\n  const lastFpsTimeRef = useRef(performance.now());\n\n  // History for undo/redo - optimized\n  const historyRef = useRef([new Uint8Array(TOTAL_PIXELS)]);\n  const historyIndexRef = useRef(0);\n  const [canUndo, setCanUndo] = useState(false);\n  const [canRedo, setCanRedo] = useState(false);\n  const addToHistory = useCallback(newState => {\n    const newHistory = historyRef.current.slice(0, historyIndexRef.current + 1);\n    newHistory.push(new Uint8Array(newState));\n    if (newHistory.length > 100) newHistory.shift();\n    historyRef.current = newHistory;\n    historyIndexRef.current = newHistory.length - 1;\n    setCanUndo(historyIndexRef.current > 0);\n    setCanRedo(false);\n  }, []);\n  const undo = useCallback(() => {\n    if (historyIndexRef.current > 0) {\n      historyIndexRef.current--;\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\n      setPixels(state);\n      setCanUndo(historyIndexRef.current > 0);\n      setCanRedo(true);\n    }\n  }, []);\n  const redo = useCallback(() => {\n    if (historyIndexRef.current < historyRef.current.length - 1) {\n      historyIndexRef.current++;\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\n      setPixels(state);\n      setCanUndo(true);\n      setCanRedo(historyIndexRef.current < historyRef.current.length - 1);\n    }\n  }, []);\n\n  // Keep pixelsRef in sync\n  useEffect(() => {\n    pixelsRef.current = pixels;\n  }, [pixels]);\n  useEffect(() => {\n    previewPixelsRef.current = previewPixels;\n  }, [previewPixels]);\n\n  // Optimized canvas render function\n  const renderCanvas = useCallback(() => {\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const ctx = canvas.getContext('2d', {\n      alpha: false\n    });\n    const imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);\n    const data = imageData.data;\n    const currentPixels = pixelsRef.current;\n    const currentPreview = previewPixelsRef.current;\n    for (let i = 0; i < TOTAL_PIXELS; i++) {\n      const offset = i * 4;\n      if (currentPreview[i] === 1) {\n        // White preview\n        data[offset] = 255;\n        data[offset + 1] = 255;\n        data[offset + 2] = 255;\n      } else if (currentPreview[i] === 2) {\n        // Black preview (dark gray for visibility)\n        data[offset] = 34;\n        data[offset + 1] = 34;\n        data[offset + 2] = 34;\n      } else if (currentPixels[i] === 1) {\n        // White pixel\n        data[offset] = 255;\n        data[offset + 1] = 255;\n        data[offset + 2] = 255;\n      } else {\n        // Black pixel (background)\n        data[offset] = 17;\n        data[offset + 1] = 17;\n        data[offset + 2] = 17;\n      }\n      data[offset + 3] = 255;\n    }\n    ctx.putImageData(imageData, 0, 0);\n\n    // FPS counting\n    frameCountRef.current++;\n    const now = performance.now();\n    if (now - lastFpsTimeRef.current >= 1000) {\n      setFps(frameCountRef.current);\n      frameCountRef.current = 0;\n      lastFpsTimeRef.current = now;\n    }\n  }, []);\n\n  // Schedule render with requestAnimationFrame\n  const scheduleRender = useCallback(() => {\n    if (renderRequestRef.current) return;\n    renderRequestRef.current = requestAnimationFrame(() => {\n      renderCanvas();\n      renderRequestRef.current = null;\n    });\n  }, [renderCanvas]);\n\n  // Render on pixel changes\n  useEffect(() => {\n    scheduleRender();\n  }, [pixels, previewPixels, scheduleRender]);\n\n  // Initial render\n  useEffect(() => {\n    renderCanvas();\n  }, [renderCanvas]);\n  const isFreeformActive = !isLineModeActive && !isCircleModeActive && !isBucketFillModeActive && !isRectangleModeActive;\n\n  // Drawing utility functions\n  const getLinePoints = useCallback((start, end) => {\n    const points = [];\n    let x0 = Math.max(0, Math.min(127, start.x));\n    let y0 = Math.max(0, Math.min(63, start.y));\n    let x1 = Math.max(0, Math.min(127, end.x));\n    let y1 = Math.max(0, Math.min(63, end.y));\n    const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\n    if (steep) {\n      [x0, y0] = [y0, x0];\n      [x1, y1] = [y1, x1];\n    }\n    if (x0 > x1) {\n      [x0, x1] = [x1, x0];\n      [y0, y1] = [y1, y0];\n    }\n    const dx = x1 - x0;\n    const dy = Math.abs(y1 - y0);\n    const yStep = y0 < y1 ? 1 : -1;\n    let error = dx / 2;\n    let y = y0;\n    for (let x = x0; x <= x1; x++) {\n      const currentX = steep ? y : x;\n      const currentY = steep ? x : y;\n      const index = currentY * GRID_WIDTH + currentX;\n      if (index >= 0 && index < TOTAL_PIXELS) points.push(index);\n      error -= dy;\n      if (error < 0) {\n        y += yStep;\n        error += dx;\n      }\n    }\n    return points;\n  }, []);\n  const getCirclePoints = useCallback((center, point) => {\n    const points = [];\n    const radius = Math.floor(Math.sqrt(Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)));\n    let x = radius,\n      y = 0,\n      error = 0;\n    while (x >= y) {\n      const coords = [[center.x + x, center.y + y], [center.x + y, center.y + x], [center.x - y, center.y + x], [center.x - x, center.y + y], [center.x - x, center.y - y], [center.x - y, center.y - x], [center.x + y, center.y - x], [center.x + x, center.y - y]];\n      coords.forEach(([px, py]) => {\n        if (px >= 0 && px < GRID_WIDTH && py >= 0 && py < GRID_HEIGHT) {\n          points.push(py * GRID_WIDTH + px);\n        }\n      });\n      y++;\n      error += 1 + 2 * y;\n      if (2 * (error - x) + 1 > 0) {\n        x--;\n        error += 1 - 2 * x;\n      }\n    }\n    return points;\n  }, []);\n  const getRectPoints = useCallback((start, end) => {\n    const points = [];\n    const startX = Math.max(0, Math.min(start.x, end.x));\n    const startY = Math.max(0, Math.min(start.y, end.y));\n    const endX = Math.min(127, Math.max(start.x, end.x));\n    const endY = Math.min(63, Math.max(start.y, end.y));\n    for (let x = startX; x <= endX; x++) {\n      if (startY >= 0 && startY < GRID_HEIGHT) points.push(startY * GRID_WIDTH + x);\n      if (endY >= 0 && endY < GRID_HEIGHT && endY !== startY) points.push(endY * GRID_WIDTH + x);\n    }\n    for (let y = startY + 1; y < endY; y++) {\n      if (startX >= 0 && startX < GRID_WIDTH) points.push(y * GRID_WIDTH + startX);\n      if (endX >= 0 && endX < GRID_WIDTH && endX !== startX) points.push(y * GRID_WIDTH + endX);\n    }\n    return points;\n  }, []);\n\n  // Get brush pattern points\n  const getBrushPoints = useCallback((centerX, centerY, size) => {\n    const points = [];\n    for (let offset = 0; offset < size; offset++) {\n      for (let i = -offset; i <= offset; i++) {\n        const coords = [{\n          x: centerX + i,\n          y: centerY - (size - 1 - offset)\n        }, {\n          x: centerX + i,\n          y: centerY + (size - 1 - offset)\n        }, {\n          x: centerX - (size - 1 - offset),\n          y: centerY + i\n        }, {\n          x: centerX + (size - 1 - offset),\n          y: centerY + i\n        }];\n        coords.forEach(point => {\n          if (point.x >= 0 && point.x < GRID_WIDTH && point.y >= 0 && point.y < GRID_HEIGHT) {\n            points.push(point.y * GRID_WIDTH + point.x);\n          }\n        });\n      }\n    }\n    return points;\n  }, []);\n\n  // Get coordinates from canvas position\n  const getCanvasCoordinates = useCallback(e => {\n    const canvas = canvasRef.current;\n    if (!canvas) return null;\n    const rect = canvas.getBoundingClientRect();\n    const scaleX = GRID_WIDTH / rect.width;\n    const scaleY = GRID_HEIGHT / rect.height;\n    const x = Math.floor((e.clientX - rect.left) * scaleX);\n    const y = Math.floor((e.clientY - rect.top) * scaleY);\n    return {\n      x,\n      y\n    };\n  }, []);\n\n  // Bucket fill\n  const handleBucketFill = useCallback(index => {\n    const currentPixels = pixelsRef.current;\n    const targetColor = currentPixels[index];\n    const fillColor = drawColor ? 1 : 0;\n    if (targetColor === fillColor) return;\n    const newPixels = new Uint8Array(currentPixels);\n    const stack = [index];\n    const visited = new Set();\n    while (stack.length > 0) {\n      const currentIndex = stack.pop();\n      if (visited.has(currentIndex) || newPixels[currentIndex] !== targetColor) continue;\n      visited.add(currentIndex);\n      newPixels[currentIndex] = fillColor;\n      const x = currentIndex % GRID_WIDTH;\n      const y = Math.floor(currentIndex / GRID_WIDTH);\n      if (x > 0) stack.push(currentIndex - 1);\n      if (x < GRID_WIDTH - 1) stack.push(currentIndex + 1);\n      if (y > 0) stack.push(currentIndex - GRID_WIDTH);\n      if (y < GRID_HEIGHT - 1) stack.push(currentIndex + GRID_WIDTH);\n    }\n    setPixels(newPixels);\n    addToHistory(newPixels);\n  }, [drawColor, addToHistory]);\n\n  // Mouse event handlers\n  const handleCanvasMouseDown = useCallback(e => {\n    if (e.button !== 0) return;\n    const coords = getCanvasCoordinates(e);\n    if (!coords) return;\n    isDrawingRef.current = true;\n    if (isBucketFillModeActive) {\n      // Only bucket fill if click is within grid\n      if (coords.x >= 0 && coords.x < GRID_WIDTH && coords.y >= 0 && coords.y < GRID_HEIGHT) {\n        const index = coords.y * GRID_WIDTH + coords.x;\n        currentIndexRef.current = index;\n        handleBucketFill(index);\n      }\n      isDrawingRef.current = false;\n      return;\n    }\n    if (isFreeformActive) {\n      // Allow drawing even if mouse is outside grid - draw any pixels that fall within grid\n      lastPointRef.current = {\n        x: coords.x,\n        y: coords.y\n      };\n      const points = getBrushPoints(coords.x, coords.y, brushSize);\n      if (points.length > 0) {\n        setPixels(prev => {\n          const newPixels = new Uint8Array(prev);\n          points.forEach(idx => {\n            newPixels[idx] = drawColor ? 1 : 0;\n          });\n          return newPixels;\n        });\n      }\n    } else {\n      startPointRef.current = coords;\n      lastPointRef.current = coords;\n    }\n  }, [isBucketFillModeActive, isFreeformActive, handleBucketFill, getCanvasCoordinates, getBrushPoints, brushSize, drawColor]);\n  const handleCanvasMouseMove = useCallback(e => {\n    const coords = getCanvasCoordinates(e);\n    if (!coords) return;\n\n    // Update brush outline\n    updateBrushOutline(e);\n    if (!isDrawingRef.current) return;\n    if (isFreeformActive && lastPointRef.current) {\n      // Check if we have any pixels within the grid from the brush at current position\n      const currentPoints = getBrushPoints(coords.x, coords.y, brushSize);\n      const lastPoints = getBrushPoints(lastPointRef.current.x, lastPointRef.current.y, brushSize);\n\n      // Determine if we should draw a connecting line or start fresh\n      const lastWasInGrid = lastPoints.length > 0;\n      const currentIsInGrid = currentPoints.length > 0;\n      if (!currentIsInGrid) {\n        // Outside grid, just update position without drawing\n        lastPointRef.current = {\n          x: coords.x,\n          y: coords.y\n        };\n      } else if (!lastWasInGrid) {\n        // Re-entering grid from outside - start fresh without connecting line\n        setPixels(prev => {\n          const newPixels = new Uint8Array(prev);\n          currentPoints.forEach(idx => {\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\n              newPixels[idx] = drawColor ? 1 : 0;\n            }\n          });\n          return newPixels;\n        });\n        lastPointRef.current = {\n          x: coords.x,\n          y: coords.y\n        };\n      } else {\n        // Both last and current positions are in grid - draw connecting line\n        // Only draw line between points that are both within reasonable grid bounds\n        const lastInBounds = lastPointRef.current.x >= -brushSize && lastPointRef.current.x < GRID_WIDTH + brushSize && lastPointRef.current.y >= -brushSize && lastPointRef.current.y < GRID_HEIGHT + brushSize;\n        const currentInBounds = coords.x >= -brushSize && coords.x < GRID_WIDTH + brushSize && coords.y >= -brushSize && coords.y < GRID_HEIGHT + brushSize;\n        if (lastInBounds && currentInBounds) {\n          const linePoints = drawLine(lastPointRef.current, {\n            x: coords.x,\n            y: coords.y\n          });\n          const allPoints = [];\n          linePoints.forEach(idx => {\n            const centerX = idx % GRID_WIDTH;\n            const centerY = Math.floor(idx / GRID_WIDTH);\n            if (centerX >= 0 && centerX < GRID_WIDTH && centerY >= 0 && centerY < GRID_HEIGHT) {\n              allPoints.push(...getBrushPoints(centerX, centerY, brushSize));\n            }\n          });\n          setPixels(prev => {\n            const newPixels = new Uint8Array(prev);\n            allPoints.forEach(idx => {\n              if (idx >= 0 && idx < TOTAL_PIXELS) {\n                newPixels[idx] = drawColor ? 1 : 0;\n              }\n            });\n            return newPixels;\n          });\n        } else {\n          // If coordinates are too far out of bounds, just draw current position\n          setPixels(prev => {\n            const newPixels = new Uint8Array(prev);\n            currentPoints.forEach(idx => {\n              if (idx >= 0 && idx < TOTAL_PIXELS) {\n                newPixels[idx] = drawColor ? 1 : 0;\n              }\n            });\n            return newPixels;\n          });\n        }\n        lastPointRef.current = {\n          x: coords.x,\n          y: coords.y\n        };\n      }\n    } else if (isLineModeActive && startPointRef.current) {\n      const points = getLinePoints(startPointRef.current, coords);\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\n      points.forEach(idx => {\n        newPreview[idx] = drawColor ? 1 : 2;\n      });\n      setPreviewPixels(newPreview);\n      lastPointRef.current = coords;\n    } else if (isCircleModeActive && startPointRef.current) {\n      const points = getCirclePoints(startPointRef.current, coords);\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\n      points.forEach(idx => {\n        newPreview[idx] = drawColor ? 1 : 2;\n      });\n      setPreviewPixels(newPreview);\n      lastPointRef.current = coords;\n    } else if (isRectangleModeActive && startPointRef.current) {\n      const points = getRectPoints(startPointRef.current, coords);\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\n      points.forEach(idx => {\n        newPreview[idx] = drawColor ? 1 : 2;\n      });\n      setPreviewPixels(newPreview);\n      lastPointRef.current = coords;\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isFreeformActive, isLineModeActive, isCircleModeActive, isRectangleModeActive, getCanvasCoordinates, getBrushPoints, getLinePoints, getCirclePoints, getRectPoints, brushSize, drawColor]);\n  const handleMouseUp = useCallback(() => {\n    if (!isDrawingRef.current) return;\n    if ((isLineModeActive || isCircleModeActive || isRectangleModeActive) && startPointRef.current && lastPointRef.current) {\n      let points = [];\n      if (isLineModeActive) {\n        points = getLinePoints(startPointRef.current, lastPointRef.current);\n      } else if (isCircleModeActive) {\n        points = getCirclePoints(startPointRef.current, lastPointRef.current);\n      } else if (isRectangleModeActive) {\n        points = getRectPoints(startPointRef.current, lastPointRef.current);\n      }\n      if (points.length > 0) {\n        setPixels(prev => {\n          const newPixels = new Uint8Array(prev);\n          points.forEach(idx => {\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\n              newPixels[idx] = drawColor ? 1 : 0;\n            }\n          });\n          // Add to history after state update\n          setTimeout(() => addToHistory(newPixels), 0);\n          return newPixels;\n        });\n      }\n      setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\n    } else if (isFreeformActive) {\n      addToHistory(pixelsRef.current);\n    }\n    isDrawingRef.current = false;\n    startPointRef.current = null;\n    lastPointRef.current = null;\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, isFreeformActive, drawColor, getLinePoints, getCirclePoints, getRectPoints, addToHistory]);\n\n  // Global mouse events for drawing outside the grid\n  useEffect(() => {\n    const handleGlobalMouseMove = e => {\n      if (isDrawingRef.current && (isLineModeActive || isCircleModeActive || isRectangleModeActive)) {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n        const rect = canvas.getBoundingClientRect();\n        const scaleX = GRID_WIDTH / rect.width;\n        const scaleY = GRID_HEIGHT / rect.height;\n\n        // Allow coordinates outside the grid\n        const x = Math.floor((e.clientX - rect.left) * scaleX);\n        const y = Math.floor((e.clientY - rect.top) * scaleY);\n        const coords = {\n          x,\n          y\n        };\n        let points = [];\n        if (isLineModeActive && startPointRef.current) {\n          points = getLinePoints(startPointRef.current, coords);\n        } else if (isCircleModeActive && startPointRef.current) {\n          points = getCirclePoints(startPointRef.current, coords);\n        } else if (isRectangleModeActive && startPointRef.current) {\n          points = getRectPoints(startPointRef.current, coords);\n        }\n        const newPreview = new Uint8Array(TOTAL_PIXELS);\n        points.forEach(idx => {\n          newPreview[idx] = drawColor ? 1 : 2;\n        });\n        setPreviewPixels(newPreview);\n        lastPointRef.current = coords;\n      }\n    };\n    const handleGlobalMouseUp = () => {\n      if (isDrawingRef.current) {\n        handleMouseUp();\n      }\n    };\n    window.addEventListener('mousemove', handleGlobalMouseMove);\n    window.addEventListener('mouseup', handleGlobalMouseUp);\n    return () => {\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\n      window.removeEventListener('mouseup', handleGlobalMouseUp);\n    };\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, drawColor, getLinePoints, getCirclePoints, getRectPoints, handleMouseUp]);\n\n  // Keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = e => {\n      if (e.code === 'Space' && !isSpacePressed && currentIndexRef.current !== null) {\n        e.preventDefault();\n        setIsSpacePressed(true);\n        // Trigger drawing at current position\n        const index = currentIndexRef.current;\n        isDrawingRef.current = true;\n        if (isFreeformActive) {\n          const x = index % GRID_WIDTH;\n          const y = Math.floor(index / GRID_WIDTH);\n          lastPointRef.current = {\n            x,\n            y\n          };\n          const points = getBrushPoints(x, y, brushSize);\n          setPixels(prev => {\n            const newPixels = new Uint8Array(prev);\n            points.forEach(idx => {\n              newPixels[idx] = drawColor ? 1 : 0;\n            });\n            return newPixels;\n          });\n        }\n      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\n        e.preventDefault();\n        if (e.shiftKey) {\n          redo();\n        } else {\n          undo();\n        }\n      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\n        e.preventDefault();\n        redo();\n      } else if (e.key === 'b') {\n        e.preventDefault();\n        setIsLineModeActive(false);\n        setIsCircleModeActive(false);\n        setIsBucketFillModeActive(false);\n        setIsRectangleModeActive(false);\n      }\n    };\n    const handleKeyUp = e => {\n      if (e.code === 'Space') {\n        e.preventDefault();\n        setIsSpacePressed(false);\n        if (isDrawingRef.current) {\n          addToHistory(pixelsRef.current);\n          isDrawingRef.current = false;\n          lastPointRef.current = null;\n        }\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [isSpacePressed, isFreeformActive, brushSize, drawColor, getBrushPoints, undo, redo, addToHistory]);\n\n  // Brush outline rendering\n  const updateBrushOutline = useCallback(e => {\n    const brushCanvas = brushCanvasRef.current;\n    if (!brushCanvas || !isFreeformActive) {\n      if (brushCanvas) brushCanvas.style.display = 'none';\n      return;\n    }\n    const canvas = canvasRef.current;\n    if (!canvas) return;\n    const rect = canvas.getBoundingClientRect();\n\n    // Calculate pixel position (allow outside bounds)\n    const scaleX = GRID_WIDTH / rect.width;\n    const scaleY = GRID_HEIGHT / rect.height;\n    const pixelX = Math.floor((e.clientX - rect.left) * scaleX);\n    const pixelY = Math.floor((e.clientY - rect.top) * scaleY);\n    const ctx = brushCanvas.getContext('2d');\n    ctx.clearRect(0, 0, brushCanvas.width, brushCanvas.height);\n    ctx.strokeStyle = drawColor ? '#fff' : '#f00';\n    ctx.lineWidth = 1;\n    if (brushSize === 1) {\n      // Only draw if any part would be visible in the grid\n      if (pixelX >= 0 && pixelX < GRID_WIDTH && pixelY >= 0 && pixelY < GRID_HEIGHT) {\n        ctx.strokeRect(pixelX * PIXEL_SIZE + 0.5, pixelY * PIXEL_SIZE + 0.5, PIXEL_SIZE - 1, PIXEL_SIZE - 1);\n      }\n    } else {\n      const diamondPixels = [];\n      for (let y = -brushSize + 1; y < brushSize; y++) {\n        for (let x = -brushSize + 1; x < brushSize; x++) {\n          if (Math.abs(x) + Math.abs(y) < brushSize) {\n            const newX = pixelX + x;\n            const newY = pixelY + y;\n            // Include pixels even outside grid for outline calculation\n            if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) {\n              diamondPixels.push({\n                x: newX,\n                y: newY\n              });\n            }\n          }\n        }\n      }\n      if (diamondPixels.length > 0) {\n        ctx.beginPath();\n        diamondPixels.forEach(({\n          x,\n          y\n        }) => {\n          [{\n            dx: 0,\n            dy: -1,\n            side: 'top'\n          }, {\n            dx: 1,\n            dy: 0,\n            side: 'right'\n          }, {\n            dx: 0,\n            dy: 1,\n            side: 'bottom'\n          }, {\n            dx: -1,\n            dy: 0,\n            side: 'left'\n          }].forEach(({\n            dx,\n            dy,\n            side\n          }) => {\n            const nx = x + dx;\n            const ny = y + dy;\n            if (!diamondPixels.some(p => p.x === nx && p.y === ny)) {\n              const px = x * PIXEL_SIZE;\n              const py = y * PIXEL_SIZE;\n              if (side === 'top') {\n                ctx.moveTo(px, py);\n                ctx.lineTo(px + PIXEL_SIZE, py);\n              } else if (side === 'right') {\n                ctx.moveTo(px + PIXEL_SIZE, py);\n                ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE);\n              } else if (side === 'bottom') {\n                ctx.moveTo(px, py + PIXEL_SIZE);\n                ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE);\n              } else if (side === 'left') {\n                ctx.moveTo(px, py);\n                ctx.lineTo(px, py + PIXEL_SIZE);\n              }\n            }\n          });\n        });\n        ctx.stroke();\n      }\n    }\n    brushCanvas.style.display = 'block';\n  }, [isFreeformActive, brushSize, drawColor]);\n\n  // Update brush outline on global mouse move for freeform mode\n  useEffect(() => {\n    if (!isFreeformActive) return;\n    const handleGlobalMouseMove = e => {\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const rect = canvas.getBoundingClientRect();\n      // Determine if we're reasonably close to the canvas\n      const margin = brushSize * PIXEL_SIZE * 2; // Allow brush size distance from edges\n      if (e.clientX >= rect.left - margin && e.clientX <= rect.right + margin && e.clientY >= rect.top - margin && e.clientY <= rect.bottom + margin) {\n        updateBrushOutline(e);\n      } else {\n        // Hide if too far from canvas and break any in-progress freeform stroke so re-entry doesn't connect\n        const brushCanvas = brushCanvasRef.current;\n        if (brushCanvas) brushCanvas.style.display = 'none';\n        if (isDrawingRef.current) {\n          lastPointRef.current = null;\n        }\n      }\n    };\n    window.addEventListener('mousemove', handleGlobalMouseMove);\n    return () => {\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\n    };\n  }, [isFreeformActive, brushSize, updateBrushOutline, getBrushPoints, drawColor]);\n\n  // Allow drawing when the user presses outside the canvas if part of the brush overlaps the grid\n  useEffect(() => {\n    if (!isFreeformActive) return;\n    const handleGlobalMouseDown = e => {\n      if (e.button !== 0) return;\n      const canvas = canvasRef.current;\n      if (!canvas) return;\n      const rect = canvas.getBoundingClientRect();\n      const scaleX = GRID_WIDTH / rect.width;\n      const scaleY = GRID_HEIGHT / rect.height;\n      const pixelX = Math.floor((e.clientX - rect.left) * scaleX);\n      const pixelY = Math.floor((e.clientY - rect.top) * scaleY);\n\n      // Get brush pixels (this will only include points inside the grid)\n      const points = getBrushPoints(pixelX, pixelY, brushSize);\n      if (points.length === 0) return;\n      isDrawingRef.current = true;\n      currentIndexRef.current = points[0];\n      setPixels(prev => {\n        const newPixels = new Uint8Array(prev);\n        points.forEach(idx => {\n          if (idx >= 0 && idx < TOTAL_PIXELS) newPixels[idx] = drawColor ? 1 : 0;\n        });\n        return newPixels;\n      });\n\n      // Set last point to the clicked logical position (may be outside bounds)\n      lastPointRef.current = {\n        x: pixelX,\n        y: pixelY\n      };\n    };\n    window.addEventListener('mousedown', handleGlobalMouseDown);\n    return () => window.removeEventListener('mousedown', handleGlobalMouseDown);\n  }, [isFreeformActive, brushSize, getBrushPoints, drawColor]);\n  const handleReset = useCallback(() => {\n    const newState = new Uint8Array(TOTAL_PIXELS);\n    setPixels(newState);\n    setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\n    startPointRef.current = null;\n    lastPointRef.current = null;\n    isDrawingRef.current = false;\n    addToHistory(newState);\n  }, [addToHistory]);\n\n  // Convert Uint8Array to boolean array for ESP32Connection and BMPHandler compatibility\n  const pixelsAsBoolArray = useMemo(() => {\n    return Array.from(pixels).map(p => p === 1);\n  }, [pixels]);\n  const handleBMPPixelUpdate = useCallback(newPixels => {\n    if (Array.isArray(newPixels)) {\n      const uint8Pixels = new Uint8Array(TOTAL_PIXELS);\n      newPixels.forEach((val, i) => {\n        uint8Pixels[i] = val ? 1 : 0;\n      });\n      setPixels(uint8Pixels);\n      addToHistory(uint8Pixels);\n    }\n  }, [addToHistory]);\n  const showBrushSizeControl = isFreeformActive;\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"pixel-grid-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'absolute',\n        top: '10px',\n        left: '50%',\n        transform: 'translateX(-50%)',\n        backgroundColor: 'rgba(0,0,0,0.7)',\n        color: fps < 30 ? '#ff4444' : fps < 50 ? '#ffaa00' : '#44ff44',\n        padding: '5px 15px',\n        borderRadius: '4px',\n        fontFamily: 'monospace',\n        fontSize: '14px',\n        zIndex: 1001\n      },\n      children: [\"FPS: \", fps]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 754,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"esp32-container\",\n      style: {\n        position: 'fixed',\n        top: '10px',\n        left: '10px',\n        zIndex: 1000\n      },\n      children: /*#__PURE__*/_jsxDEV(ESP32Connection, {\n        pixelData: pixelsAsBoolArray\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 772,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 771,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"bmp-container\",\n      style: {\n        position: 'fixed',\n        top: '10px',\n        right: '10px',\n        zIndex: 1000\n      },\n      children: /*#__PURE__*/_jsxDEV(BMPHandler, {\n        pixelData: pixelsAsBoolArray,\n        onPixelUpdate: handleBMPPixelUpdate\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 777,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 776,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"brush-size-control\",\n      style: {\n        visibility: showBrushSizeControl ? 'visible' : 'hidden'\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"brushSize\",\n        style: {\n          color: 'white',\n          minWidth: '100px'\n        },\n        children: [\"Brush Size: \", brushSize]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 782,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"range\",\n        id: \"brushSize\",\n        className: \"brush-size-slider\",\n        min: \"1\",\n        max: \"5\",\n        value: brushSize,\n        onChange: e => setBrushSize(Number(e.target.value))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 785,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 781,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        display: 'flex',\n        justifyContent: 'center',\n        width: '100%',\n        position: 'relative'\n      },\n      children: /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"mode-buttons-container\",\n        style: {\n          position: 'relative',\n          left: '22px',\n          width: '1024px',\n          boxSizing: 'border-box',\n          marginLeft: 'auto',\n          marginRight: 'auto'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(false);\n            setIsCircleModeActive(false);\n            setIsBucketFillModeActive(false);\n            setIsRectangleModeActive(false);\n            setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\n          },\n          className: `mode-button ${isFreeformActive ? 'active' : ''}`,\n          children: \"Freeform Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 802,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(true);\n            setIsCircleModeActive(false);\n            setIsBucketFillModeActive(false);\n            setIsRectangleModeActive(false);\n          },\n          className: `mode-button ${isLineModeActive ? 'active' : ''}`,\n          children: \"Line Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 814,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(false);\n            setIsCircleModeActive(true);\n            setIsBucketFillModeActive(false);\n            setIsRectangleModeActive(false);\n          },\n          className: `mode-button ${isCircleModeActive ? 'active' : ''}`,\n          children: \"Circle Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 825,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(false);\n            setIsCircleModeActive(false);\n            setIsBucketFillModeActive(false);\n            setIsRectangleModeActive(true);\n          },\n          className: `mode-button ${isRectangleModeActive ? 'active' : ''}`,\n          children: \"Rectangle Mode\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 836,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: () => {\n            setIsLineModeActive(false);\n            setIsCircleModeActive(false);\n            setIsBucketFillModeActive(true);\n            setIsRectangleModeActive(false);\n          },\n          className: `mode-button ${isBucketFillModeActive ? 'active' : ''}`,\n          children: \"Bucket Fill\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 847,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: undo,\n          className: \"mode-button\",\n          disabled: !canUndo,\n          style: {\n            marginLeft: 'auto'\n          },\n          children: \"Undo\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 858,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: redo,\n          className: \"mode-button\",\n          disabled: !canRedo,\n          children: \"Redo\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 861,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 798,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 797,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"drawing-area\",\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"color-selector\",\n        style: {\n          display: 'flex',\n          flexDirection: 'column',\n          gap: '15px',\n          marginRight: '15px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => setDrawColor(true),\n          style: {\n            width: '30px',\n            height: '30px',\n            backgroundColor: '#fff',\n            border: drawColor ? '3px solid #2196F3' : '1px solid #666',\n            borderRadius: '4px',\n            cursor: 'pointer',\n            boxSizing: 'border-box',\n            boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\n          },\n          title: \"White (Draw)\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 870,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => setDrawColor(false),\n          style: {\n            width: '30px',\n            height: '30px',\n            backgroundColor: '#000',\n            border: !drawColor ? '3px solid #ff4444' : '1px solid #666',\n            borderRadius: '4px',\n            cursor: 'pointer',\n            boxSizing: 'border-box',\n            boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\n          },\n          title: \"Black (Eraser)\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 880,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 869,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"canvas-container\",\n        style: {\n          position: 'relative',\n          width: `${GRID_WIDTH * PIXEL_SIZE}px`,\n          height: `${GRID_HEIGHT * PIXEL_SIZE}px`\n        },\n        onMouseDown: handleCanvasMouseDown,\n        onMouseMove: handleCanvasMouseMove,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: () => {\n          if (brushCanvasRef.current) brushCanvasRef.current.style.display = 'none';\n          // When the mouse leaves the canvas while freeform-drawing, break the stroke so re-entry doesn't connect\n          if (isFreeformActive && isDrawingRef.current) {\n            lastPointRef.current = null;\n          }\n        },\n        onContextMenu: e => e.preventDefault(),\n        children: [/*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: canvasRef,\n          width: GRID_WIDTH,\n          height: GRID_HEIGHT,\n          style: {\n            width: '100%',\n            height: '100%',\n            imageRendering: 'pixelated',\n            cursor: isFreeformActive ? 'none' : isBucketFillModeActive ? 'cell' : 'crosshair',\n            border: '1px solid #666'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 908,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"canvas\", {\n          ref: brushCanvasRef,\n          width: GRID_WIDTH * PIXEL_SIZE,\n          height: GRID_HEIGHT * PIXEL_SIZE,\n          style: {\n            position: 'absolute',\n            top: 0,\n            left: 0,\n            width: '100%',\n            height: '100%',\n            pointerEvents: 'none',\n            display: 'none'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 920,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 893,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 867,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ResetButton, {\n      onReset: handleReset\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 937,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 752,\n    columnNumber: 5\n  }, this);\n};\n_s(PixelGrid, \"bnGurMdqsoR+vlbJwy08AddV2Tw=\");\n_c = PixelGrid;\nexport default PixelGrid;\nvar _c;\n$RefreshReg$(_c, \"PixelGrid\");","map":{"version":3,"names":["React","useState","useRef","useEffect","useCallback","useMemo","drawLine","ESP32Connection","BMPHandler","ResetButton","jsxDEV","_jsxDEV","GRID_WIDTH","GRID_HEIGHT","PIXEL_SIZE","TOTAL_PIXELS","PixelGrid","_s","pixels","setPixels","Uint8Array","previewPixels","setPreviewPixels","isLineModeActive","setIsLineModeActive","isCircleModeActive","setIsCircleModeActive","isBucketFillModeActive","setIsBucketFillModeActive","isRectangleModeActive","setIsRectangleModeActive","isDrawingRef","startPointRef","lastPointRef","isSpacePressed","setIsSpacePressed","currentIndexRef","brushSize","setBrushSize","drawColor","setDrawColor","canvasRef","brushCanvasRef","renderRequestRef","pixelsRef","previewPixelsRef","fps","setFps","frameCountRef","lastFpsTimeRef","performance","now","historyRef","historyIndexRef","canUndo","setCanUndo","canRedo","setCanRedo","addToHistory","newState","newHistory","current","slice","push","length","shift","undo","state","redo","renderCanvas","canvas","ctx","getContext","alpha","imageData","createImageData","data","currentPixels","currentPreview","i","offset","putImageData","scheduleRender","requestAnimationFrame","isFreeformActive","getLinePoints","start","end","points","x0","Math","max","min","x","y0","y","x1","y1","steep","abs","dx","dy","yStep","error","currentX","currentY","index","getCirclePoints","center","point","radius","floor","sqrt","pow","coords","forEach","px","py","getRectPoints","startX","startY","endX","endY","getBrushPoints","centerX","centerY","size","getCanvasCoordinates","e","rect","getBoundingClientRect","scaleX","width","scaleY","height","clientX","left","clientY","top","handleBucketFill","targetColor","fillColor","newPixels","stack","visited","Set","currentIndex","pop","has","add","handleCanvasMouseDown","button","prev","idx","handleCanvasMouseMove","updateBrushOutline","currentPoints","lastPoints","lastWasInGrid","currentIsInGrid","lastInBounds","currentInBounds","linePoints","allPoints","newPreview","handleMouseUp","setTimeout","handleGlobalMouseMove","handleGlobalMouseUp","window","addEventListener","removeEventListener","handleKeyDown","code","preventDefault","ctrlKey","metaKey","key","toLowerCase","shiftKey","handleKeyUp","brushCanvas","style","display","pixelX","pixelY","clearRect","strokeStyle","lineWidth","strokeRect","diamondPixels","newX","newY","beginPath","side","nx","ny","some","p","moveTo","lineTo","stroke","margin","right","bottom","handleGlobalMouseDown","handleReset","pixelsAsBoolArray","Array","from","map","handleBMPPixelUpdate","isArray","uint8Pixels","val","showBrushSizeControl","className","children","position","transform","backgroundColor","color","padding","borderRadius","fontFamily","fontSize","zIndex","fileName","_jsxFileName","lineNumber","columnNumber","pixelData","onPixelUpdate","visibility","htmlFor","minWidth","type","id","value","onChange","Number","target","justifyContent","boxSizing","marginLeft","marginRight","onClick","disabled","flexDirection","gap","border","cursor","boxShadow","title","onMouseDown","onMouseMove","onMouseUp","onMouseLeave","onContextMenu","ref","imageRendering","pointerEvents","onReset","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/ESP32_OLED_Drawing/src/components/pixelGrid/index.jsx"],"sourcesContent":["import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\r\nimport { drawLine } from './utils';\r\nimport ESP32Connection from '../ESP32Connection';\r\nimport BMPHandler from '../BMPHandler';\r\nimport ResetButton from './ResetButton';\r\n\r\nconst GRID_WIDTH = 128;\r\nconst GRID_HEIGHT = 64;\r\nconst PIXEL_SIZE = 8;\r\nconst TOTAL_PIXELS = GRID_WIDTH * GRID_HEIGHT;\r\n\r\nconst PixelGrid = () => {\r\n  // Use Uint8Array for better performance (0 = black, 1 = white)\r\n  const [pixels, setPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\r\n  const [previewPixels, setPreviewPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\r\n  \r\n  const [isLineModeActive, setIsLineModeActive] = useState(false);\r\n  const [isCircleModeActive, setIsCircleModeActive] = useState(false);\r\n  const [isBucketFillModeActive, setIsBucketFillModeActive] = useState(false);\r\n  const [isRectangleModeActive, setIsRectangleModeActive] = useState(false);\r\n  \r\n  const isDrawingRef = useRef(false);\r\n  const startPointRef = useRef(null);\r\n  const lastPointRef = useRef(null);\r\n  const [isSpacePressed, setIsSpacePressed] = useState(false);\r\n  const currentIndexRef = useRef(null);\r\n  const [brushSize, setBrushSize] = useState(1);\r\n  const [drawColor, setDrawColor] = useState(true);\r\n  \r\n  // Canvas refs\r\n  const canvasRef = useRef(null);\r\n  const brushCanvasRef = useRef(null);\r\n  const renderRequestRef = useRef(null);\r\n  const pixelsRef = useRef(pixels);\r\n  const previewPixelsRef = useRef(previewPixels);\r\n  \r\n  // FPS counter\r\n  const [fps, setFps] = useState(0);\r\n  const frameCountRef = useRef(0);\r\n  const lastFpsTimeRef = useRef(performance.now());\r\n\r\n  // History for undo/redo - optimized\r\n  const historyRef = useRef([new Uint8Array(TOTAL_PIXELS)]);\r\n  const historyIndexRef = useRef(0);\r\n  const [canUndo, setCanUndo] = useState(false);\r\n  const [canRedo, setCanRedo] = useState(false);\r\n\r\n  const addToHistory = useCallback((newState) => {\r\n    const newHistory = historyRef.current.slice(0, historyIndexRef.current + 1);\r\n    newHistory.push(new Uint8Array(newState));\r\n    if (newHistory.length > 100) newHistory.shift();\r\n    historyRef.current = newHistory;\r\n    historyIndexRef.current = newHistory.length - 1;\r\n    setCanUndo(historyIndexRef.current > 0);\r\n    setCanRedo(false);\r\n  }, []);\r\n\r\n  const undo = useCallback(() => {\r\n    if (historyIndexRef.current > 0) {\r\n      historyIndexRef.current--;\r\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\r\n      setPixels(state);\r\n      setCanUndo(historyIndexRef.current > 0);\r\n      setCanRedo(true);\r\n    }\r\n  }, []);\r\n\r\n  const redo = useCallback(() => {\r\n    if (historyIndexRef.current < historyRef.current.length - 1) {\r\n      historyIndexRef.current++;\r\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\r\n      setPixels(state);\r\n      setCanUndo(true);\r\n      setCanRedo(historyIndexRef.current < historyRef.current.length - 1);\r\n    }\r\n  }, []);\r\n\r\n  // Keep pixelsRef in sync\r\n  useEffect(() => {\r\n    pixelsRef.current = pixels;\r\n  }, [pixels]);\r\n  \r\n  useEffect(() => {\r\n    previewPixelsRef.current = previewPixels;\r\n  }, [previewPixels]);\r\n\r\n  // Optimized canvas render function\r\n  const renderCanvas = useCallback(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    \r\n    const ctx = canvas.getContext('2d', { alpha: false });\r\n    const imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);\r\n    const data = imageData.data;\r\n    \r\n    const currentPixels = pixelsRef.current;\r\n    const currentPreview = previewPixelsRef.current;\r\n    \r\n    for (let i = 0; i < TOTAL_PIXELS; i++) {\r\n      const offset = i * 4;\r\n      if (currentPreview[i] === 1) {\r\n        // White preview\r\n        data[offset] = 255;\r\n        data[offset + 1] = 255;\r\n        data[offset + 2] = 255;\r\n      } else if (currentPreview[i] === 2) {\r\n        // Black preview (dark gray for visibility)\r\n        data[offset] = 34;\r\n        data[offset + 1] = 34;\r\n        data[offset + 2] = 34;\r\n      } else if (currentPixels[i] === 1) {\r\n        // White pixel\r\n        data[offset] = 255;\r\n        data[offset + 1] = 255;\r\n        data[offset + 2] = 255;\r\n      } else {\r\n        // Black pixel (background)\r\n        data[offset] = 17;\r\n        data[offset + 1] = 17;\r\n        data[offset + 2] = 17;\r\n      }\r\n      data[offset + 3] = 255;\r\n    }\r\n    \r\n    ctx.putImageData(imageData, 0, 0);\r\n    \r\n    // FPS counting\r\n    frameCountRef.current++;\r\n    const now = performance.now();\r\n    if (now - lastFpsTimeRef.current >= 1000) {\r\n      setFps(frameCountRef.current);\r\n      frameCountRef.current = 0;\r\n      lastFpsTimeRef.current = now;\r\n    }\r\n  }, []);\r\n\r\n  // Schedule render with requestAnimationFrame\r\n  const scheduleRender = useCallback(() => {\r\n    if (renderRequestRef.current) return;\r\n    renderRequestRef.current = requestAnimationFrame(() => {\r\n      renderCanvas();\r\n      renderRequestRef.current = null;\r\n    });\r\n  }, [renderCanvas]);\r\n\r\n  // Render on pixel changes\r\n  useEffect(() => {\r\n    scheduleRender();\r\n  }, [pixels, previewPixels, scheduleRender]);\r\n\r\n  // Initial render\r\n  useEffect(() => {\r\n    renderCanvas();\r\n  }, [renderCanvas]);\r\n\r\n  const isFreeformActive = !isLineModeActive && !isCircleModeActive && \r\n                           !isBucketFillModeActive && !isRectangleModeActive;\r\n\r\n  // Drawing utility functions\r\n  const getLinePoints = useCallback((start, end) => {\r\n    const points = [];\r\n    let x0 = Math.max(0, Math.min(127, start.x));\r\n    let y0 = Math.max(0, Math.min(63, start.y));\r\n    let x1 = Math.max(0, Math.min(127, end.x));\r\n    let y1 = Math.max(0, Math.min(63, end.y));\r\n\r\n    const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n    if (steep) { [x0, y0] = [y0, x0]; [x1, y1] = [y1, x1]; }\r\n    if (x0 > x1) { [x0, x1] = [x1, x0]; [y0, y1] = [y1, y0]; }\r\n\r\n    const dx = x1 - x0;\r\n    const dy = Math.abs(y1 - y0);\r\n    const yStep = y0 < y1 ? 1 : -1;\r\n    let error = dx / 2;\r\n    let y = y0;\r\n\r\n    for (let x = x0; x <= x1; x++) {\r\n      const currentX = steep ? y : x;\r\n      const currentY = steep ? x : y;\r\n      const index = currentY * GRID_WIDTH + currentX;\r\n      if (index >= 0 && index < TOTAL_PIXELS) points.push(index);\r\n      error -= dy;\r\n      if (error < 0) { y += yStep; error += dx; }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  const getCirclePoints = useCallback((center, point) => {\r\n    const points = [];\r\n    const radius = Math.floor(Math.sqrt(\r\n      Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)\r\n    ));\r\n\r\n    let x = radius, y = 0, error = 0;\r\n    while (x >= y) {\r\n      const coords = [\r\n        [center.x + x, center.y + y], [center.x + y, center.y + x],\r\n        [center.x - y, center.y + x], [center.x - x, center.y + y],\r\n        [center.x - x, center.y - y], [center.x - y, center.y - x],\r\n        [center.x + y, center.y - x], [center.x + x, center.y - y],\r\n      ];\r\n      coords.forEach(([px, py]) => {\r\n        if (px >= 0 && px < GRID_WIDTH && py >= 0 && py < GRID_HEIGHT) {\r\n          points.push(py * GRID_WIDTH + px);\r\n        }\r\n      });\r\n      y++;\r\n      error += 1 + 2 * y;\r\n      if (2 * (error - x) + 1 > 0) { x--; error += 1 - 2 * x; }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  const getRectPoints = useCallback((start, end) => {\r\n    const points = [];\r\n    const startX = Math.max(0, Math.min(start.x, end.x));\r\n    const startY = Math.max(0, Math.min(start.y, end.y));\r\n    const endX = Math.min(127, Math.max(start.x, end.x));\r\n    const endY = Math.min(63, Math.max(start.y, end.y));\r\n    \r\n    for (let x = startX; x <= endX; x++) {\r\n      if (startY >= 0 && startY < GRID_HEIGHT) points.push(startY * GRID_WIDTH + x);\r\n      if (endY >= 0 && endY < GRID_HEIGHT && endY !== startY) points.push(endY * GRID_WIDTH + x);\r\n    }\r\n    for (let y = startY + 1; y < endY; y++) {\r\n      if (startX >= 0 && startX < GRID_WIDTH) points.push(y * GRID_WIDTH + startX);\r\n      if (endX >= 0 && endX < GRID_WIDTH && endX !== startX) points.push(y * GRID_WIDTH + endX);\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  // Get brush pattern points\r\n  const getBrushPoints = useCallback((centerX, centerY, size) => {\r\n    const points = [];\r\n    for (let offset = 0; offset < size; offset++) {\r\n      for (let i = -offset; i <= offset; i++) {\r\n        const coords = [\r\n          { x: centerX + i, y: centerY - (size - 1 - offset) },\r\n          { x: centerX + i, y: centerY + (size - 1 - offset) },\r\n          { x: centerX - (size - 1 - offset), y: centerY + i },\r\n          { x: centerX + (size - 1 - offset), y: centerY + i }\r\n        ];\r\n        coords.forEach(point => {\r\n          if (point.x >= 0 && point.x < GRID_WIDTH && point.y >= 0 && point.y < GRID_HEIGHT) {\r\n            points.push(point.y * GRID_WIDTH + point.x);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  // Get coordinates from canvas position\r\n  const getCanvasCoordinates = useCallback((e) => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return null;\r\n    \r\n    const rect = canvas.getBoundingClientRect();\r\n    const scaleX = GRID_WIDTH / rect.width;\r\n    const scaleY = GRID_HEIGHT / rect.height;\r\n    \r\n    const x = Math.floor((e.clientX - rect.left) * scaleX);\r\n    const y = Math.floor((e.clientY - rect.top) * scaleY);\r\n    \r\n    return { x, y };\r\n  }, []);\r\n\r\n  // Bucket fill\r\n  const handleBucketFill = useCallback((index) => {\r\n    const currentPixels = pixelsRef.current;\r\n    const targetColor = currentPixels[index];\r\n    const fillColor = drawColor ? 1 : 0;\r\n    if (targetColor === fillColor) return;\r\n\r\n    const newPixels = new Uint8Array(currentPixels);\r\n    const stack = [index];\r\n    const visited = new Set();\r\n\r\n    while (stack.length > 0) {\r\n      const currentIndex = stack.pop();\r\n      if (visited.has(currentIndex) || newPixels[currentIndex] !== targetColor) continue;\r\n      visited.add(currentIndex);\r\n      newPixels[currentIndex] = fillColor;\r\n\r\n      const x = currentIndex % GRID_WIDTH;\r\n      const y = Math.floor(currentIndex / GRID_WIDTH);\r\n\r\n      if (x > 0) stack.push(currentIndex - 1);\r\n      if (x < GRID_WIDTH - 1) stack.push(currentIndex + 1);\r\n      if (y > 0) stack.push(currentIndex - GRID_WIDTH);\r\n      if (y < GRID_HEIGHT - 1) stack.push(currentIndex + GRID_WIDTH);\r\n    }\r\n\r\n    setPixels(newPixels);\r\n    addToHistory(newPixels);\r\n  }, [drawColor, addToHistory]);\r\n\r\n  // Mouse event handlers\r\n  const handleCanvasMouseDown = useCallback((e) => {\r\n    if (e.button !== 0) return;\r\n    \r\n    const coords = getCanvasCoordinates(e);\r\n    if (!coords) return;\r\n    \r\n    isDrawingRef.current = true;\r\n    \r\n    if (isBucketFillModeActive) {\r\n      // Only bucket fill if click is within grid\r\n      if (coords.x >= 0 && coords.x < GRID_WIDTH && coords.y >= 0 && coords.y < GRID_HEIGHT) {\r\n        const index = coords.y * GRID_WIDTH + coords.x;\r\n        currentIndexRef.current = index;\r\n        handleBucketFill(index);\r\n      }\r\n      isDrawingRef.current = false;\r\n      return;\r\n    }\r\n    \r\n    if (isFreeformActive) {\r\n      // Allow drawing even if mouse is outside grid - draw any pixels that fall within grid\r\n      lastPointRef.current = { x: coords.x, y: coords.y };\r\n      const points = getBrushPoints(coords.x, coords.y, brushSize);\r\n      if (points.length > 0) {\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          points.forEach(idx => { newPixels[idx] = drawColor ? 1 : 0; });\r\n          return newPixels;\r\n        });\r\n      }\r\n    } else {\r\n      startPointRef.current = coords;\r\n      lastPointRef.current = coords;\r\n    }\r\n  }, [isBucketFillModeActive, isFreeformActive, handleBucketFill, getCanvasCoordinates, getBrushPoints, brushSize, drawColor]);\r\n\r\n  const handleCanvasMouseMove = useCallback((e) => {\r\n    const coords = getCanvasCoordinates(e);\r\n    if (!coords) return;\r\n    \r\n    // Update brush outline\r\n    updateBrushOutline(e);\r\n    \r\n    if (!isDrawingRef.current) return;\r\n    \r\n    if (isFreeformActive && lastPointRef.current) {\r\n      // Check if we have any pixels within the grid from the brush at current position\r\n      const currentPoints = getBrushPoints(coords.x, coords.y, brushSize);\r\n      const lastPoints = getBrushPoints(lastPointRef.current.x, lastPointRef.current.y, brushSize);\r\n      \r\n      // Determine if we should draw a connecting line or start fresh\r\n      const lastWasInGrid = lastPoints.length > 0;\r\n      const currentIsInGrid = currentPoints.length > 0;\r\n      \r\n      if (!currentIsInGrid) {\r\n        // Outside grid, just update position without drawing\r\n        lastPointRef.current = { x: coords.x, y: coords.y };\r\n      } else if (!lastWasInGrid) {\r\n        // Re-entering grid from outside - start fresh without connecting line\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          currentPoints.forEach(idx => {\r\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n              newPixels[idx] = drawColor ? 1 : 0;\r\n            }\r\n          });\r\n          return newPixels;\r\n        });\r\n        lastPointRef.current = { x: coords.x, y: coords.y };\r\n      } else {\r\n        // Both last and current positions are in grid - draw connecting line\r\n        // Only draw line between points that are both within reasonable grid bounds\r\n        const lastInBounds = lastPointRef.current.x >= -brushSize && lastPointRef.current.x < GRID_WIDTH + brushSize &&\r\n                             lastPointRef.current.y >= -brushSize && lastPointRef.current.y < GRID_HEIGHT + brushSize;\r\n        const currentInBounds = coords.x >= -brushSize && coords.x < GRID_WIDTH + brushSize &&\r\n                                coords.y >= -brushSize && coords.y < GRID_HEIGHT + brushSize;\r\n        \r\n        if (lastInBounds && currentInBounds) {\r\n          const linePoints = drawLine(lastPointRef.current, { x: coords.x, y: coords.y });\r\n          const allPoints = [];\r\n          linePoints.forEach(idx => {\r\n            const centerX = idx % GRID_WIDTH;\r\n            const centerY = Math.floor(idx / GRID_WIDTH);\r\n            if (centerX >= 0 && centerX < GRID_WIDTH && centerY >= 0 && centerY < GRID_HEIGHT) {\r\n              allPoints.push(...getBrushPoints(centerX, centerY, brushSize));\r\n            }\r\n          });\r\n          \r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            allPoints.forEach(idx => {\r\n              if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n                newPixels[idx] = drawColor ? 1 : 0;\r\n              }\r\n            });\r\n            return newPixels;\r\n          });\r\n        } else {\r\n          // If coordinates are too far out of bounds, just draw current position\r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            currentPoints.forEach(idx => {\r\n              if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n                newPixels[idx] = drawColor ? 1 : 0;\r\n              }\r\n            });\r\n            return newPixels;\r\n          });\r\n        }\r\n        lastPointRef.current = { x: coords.x, y: coords.y };\r\n      }\r\n    } else if (isLineModeActive && startPointRef.current) {\r\n      const points = getLinePoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    } else if (isCircleModeActive && startPointRef.current) {\r\n      const points = getCirclePoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    } else if (isRectangleModeActive && startPointRef.current) {\r\n      const points = getRectPoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    }\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isFreeformActive, isLineModeActive, isCircleModeActive, isRectangleModeActive,\r\n      getCanvasCoordinates, getBrushPoints, getLinePoints, getCirclePoints, getRectPoints,\r\n      brushSize, drawColor]);\r\n\r\n  const handleMouseUp = useCallback(() => {\r\n    if (!isDrawingRef.current) return;\r\n    \r\n    if ((isLineModeActive || isCircleModeActive || isRectangleModeActive) && \r\n        startPointRef.current && lastPointRef.current) {\r\n      \r\n      let points = [];\r\n      if (isLineModeActive) {\r\n        points = getLinePoints(startPointRef.current, lastPointRef.current);\r\n      } else if (isCircleModeActive) {\r\n        points = getCirclePoints(startPointRef.current, lastPointRef.current);\r\n      } else if (isRectangleModeActive) {\r\n        points = getRectPoints(startPointRef.current, lastPointRef.current);\r\n      }\r\n      \r\n      if (points.length > 0) {\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          points.forEach(idx => {\r\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n              newPixels[idx] = drawColor ? 1 : 0;\r\n            }\r\n          });\r\n          // Add to history after state update\r\n          setTimeout(() => addToHistory(newPixels), 0);\r\n          return newPixels;\r\n        });\r\n      }\r\n      setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n    } else if (isFreeformActive) {\r\n      addToHistory(pixelsRef.current);\r\n    }\r\n    \r\n    isDrawingRef.current = false;\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, isFreeformActive,\r\n      drawColor, getLinePoints, getCirclePoints, getRectPoints, addToHistory]);\r\n\r\n  // Global mouse events for drawing outside the grid\r\n  useEffect(() => {\r\n    const handleGlobalMouseMove = (e) => {\r\n      if (isDrawingRef.current && (isLineModeActive || isCircleModeActive || isRectangleModeActive)) {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n        \r\n        const rect = canvas.getBoundingClientRect();\r\n        const scaleX = GRID_WIDTH / rect.width;\r\n        const scaleY = GRID_HEIGHT / rect.height;\r\n        \r\n        // Allow coordinates outside the grid\r\n        const x = Math.floor((e.clientX - rect.left) * scaleX);\r\n        const y = Math.floor((e.clientY - rect.top) * scaleY);\r\n        const coords = { x, y };\r\n        \r\n        let points = [];\r\n        if (isLineModeActive && startPointRef.current) {\r\n          points = getLinePoints(startPointRef.current, coords);\r\n        } else if (isCircleModeActive && startPointRef.current) {\r\n          points = getCirclePoints(startPointRef.current, coords);\r\n        } else if (isRectangleModeActive && startPointRef.current) {\r\n          points = getRectPoints(startPointRef.current, coords);\r\n        }\r\n        \r\n        const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n        points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n        setPreviewPixels(newPreview);\r\n        lastPointRef.current = coords;\r\n      }\r\n    };\r\n\r\n    const handleGlobalMouseUp = () => {\r\n      if (isDrawingRef.current) {\r\n        handleMouseUp();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleGlobalMouseMove);\r\n    window.addEventListener('mouseup', handleGlobalMouseUp);\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\r\n      window.removeEventListener('mouseup', handleGlobalMouseUp);\r\n    };\r\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, drawColor,\r\n      getLinePoints, getCirclePoints, getRectPoints, handleMouseUp]);\r\n\r\n  // Keyboard shortcuts\r\n  useEffect(() => {\r\n    const handleKeyDown = (e) => {\r\n      if (e.code === 'Space' && !isSpacePressed && currentIndexRef.current !== null) {\r\n        e.preventDefault();\r\n        setIsSpacePressed(true);\r\n        // Trigger drawing at current position\r\n        const index = currentIndexRef.current;\r\n        isDrawingRef.current = true;\r\n        if (isFreeformActive) {\r\n          const x = index % GRID_WIDTH;\r\n          const y = Math.floor(index / GRID_WIDTH);\r\n          lastPointRef.current = { x, y };\r\n          const points = getBrushPoints(x, y, brushSize);\r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            points.forEach(idx => { newPixels[idx] = drawColor ? 1 : 0; });\r\n            return newPixels;\r\n          });\r\n        }\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\r\n        e.preventDefault();\r\n        if (e.shiftKey) {\r\n          redo();\r\n        } else {\r\n          undo();\r\n        }\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\r\n        e.preventDefault();\r\n        redo();\r\n      } else if (e.key === 'b') {\r\n        e.preventDefault();\r\n        setIsLineModeActive(false);\r\n        setIsCircleModeActive(false);\r\n        setIsBucketFillModeActive(false);\r\n        setIsRectangleModeActive(false);\r\n      }\r\n    };\r\n\r\n    const handleKeyUp = (e) => {\r\n      if (e.code === 'Space') {\r\n        e.preventDefault();\r\n        setIsSpacePressed(false);\r\n        if (isDrawingRef.current) {\r\n          addToHistory(pixelsRef.current);\r\n          isDrawingRef.current = false;\r\n          lastPointRef.current = null;\r\n        }\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, [isSpacePressed, isFreeformActive, brushSize, drawColor, getBrushPoints, undo, redo, addToHistory]);\r\n\r\n  // Brush outline rendering\r\n  const updateBrushOutline = useCallback((e) => {\r\n    const brushCanvas = brushCanvasRef.current;\r\n    if (!brushCanvas || !isFreeformActive) {\r\n      if (brushCanvas) brushCanvas.style.display = 'none';\r\n      return;\r\n    }\r\n\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const rect = canvas.getBoundingClientRect();\r\n    \r\n    // Calculate pixel position (allow outside bounds)\r\n    const scaleX = GRID_WIDTH / rect.width;\r\n    const scaleY = GRID_HEIGHT / rect.height;\r\n    const pixelX = Math.floor((e.clientX - rect.left) * scaleX);\r\n    const pixelY = Math.floor((e.clientY - rect.top) * scaleY);\r\n\r\n    const ctx = brushCanvas.getContext('2d');\r\n    ctx.clearRect(0, 0, brushCanvas.width, brushCanvas.height);\r\n    ctx.strokeStyle = drawColor ? '#fff' : '#f00';\r\n    ctx.lineWidth = 1;\r\n\r\n    if (brushSize === 1) {\r\n      // Only draw if any part would be visible in the grid\r\n      if (pixelX >= 0 && pixelX < GRID_WIDTH && pixelY >= 0 && pixelY < GRID_HEIGHT) {\r\n        ctx.strokeRect(pixelX * PIXEL_SIZE + 0.5, pixelY * PIXEL_SIZE + 0.5, PIXEL_SIZE - 1, PIXEL_SIZE - 1);\r\n      }\r\n    } else {\r\n      const diamondPixels = [];\r\n      for (let y = -brushSize + 1; y < brushSize; y++) {\r\n        for (let x = -brushSize + 1; x < brushSize; x++) {\r\n          if (Math.abs(x) + Math.abs(y) < brushSize) {\r\n            const newX = pixelX + x;\r\n            const newY = pixelY + y;\r\n            // Include pixels even outside grid for outline calculation\r\n            if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) {\r\n              diamondPixels.push({ x: newX, y: newY });\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (diamondPixels.length > 0) {\r\n        ctx.beginPath();\r\n        diamondPixels.forEach(({ x, y }) => {\r\n          [{ dx: 0, dy: -1, side: 'top' }, { dx: 1, dy: 0, side: 'right' },\r\n           { dx: 0, dy: 1, side: 'bottom' }, { dx: -1, dy: 0, side: 'left' }]\r\n          .forEach(({ dx, dy, side }) => {\r\n            const nx = x + dx;\r\n            const ny = y + dy;\r\n            if (!diamondPixels.some(p => p.x === nx && p.y === ny)) {\r\n              const px = x * PIXEL_SIZE;\r\n              const py = y * PIXEL_SIZE;\r\n              if (side === 'top') { ctx.moveTo(px, py); ctx.lineTo(px + PIXEL_SIZE, py); }\r\n              else if (side === 'right') { ctx.moveTo(px + PIXEL_SIZE, py); ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE); }\r\n              else if (side === 'bottom') { ctx.moveTo(px, py + PIXEL_SIZE); ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE); }\r\n              else if (side === 'left') { ctx.moveTo(px, py); ctx.lineTo(px, py + PIXEL_SIZE); }\r\n            }\r\n          });\r\n        });\r\n        ctx.stroke();\r\n      }\r\n    }\r\n\r\n    brushCanvas.style.display = 'block';\r\n  }, [isFreeformActive, brushSize, drawColor]);\r\n\r\n  // Update brush outline on global mouse move for freeform mode\r\n  useEffect(() => {\r\n    if (!isFreeformActive) return;\r\n\r\n    const handleGlobalMouseMove = (e) => {\r\n      const canvas = canvasRef.current;\r\n      if (!canvas) return;\r\n\r\n      const rect = canvas.getBoundingClientRect();\r\n      // Determine if we're reasonably close to the canvas\r\n      const margin = brushSize * PIXEL_SIZE * 2; // Allow brush size distance from edges\r\n      if (\r\n        e.clientX >= rect.left - margin &&\r\n        e.clientX <= rect.right + margin &&\r\n        e.clientY >= rect.top - margin &&\r\n        e.clientY <= rect.bottom + margin\r\n      ) {\r\n        updateBrushOutline(e);\r\n      } else {\r\n        // Hide if too far from canvas and break any in-progress freeform stroke so re-entry doesn't connect\r\n        const brushCanvas = brushCanvasRef.current;\r\n        if (brushCanvas) brushCanvas.style.display = 'none';\r\n        if (isDrawingRef.current) {\r\n          lastPointRef.current = null;\r\n        }\r\n      }\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleGlobalMouseMove);\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\r\n    };\r\n  }, [isFreeformActive, brushSize, updateBrushOutline, getBrushPoints, drawColor]);\r\n\r\n  // Allow drawing when the user presses outside the canvas if part of the brush overlaps the grid\r\n  useEffect(() => {\r\n    if (!isFreeformActive) return;\r\n\r\n    const handleGlobalMouseDown = (e) => {\r\n      if (e.button !== 0) return;\r\n      const canvas = canvasRef.current;\r\n      if (!canvas) return;\r\n\r\n      const rect = canvas.getBoundingClientRect();\r\n      const scaleX = GRID_WIDTH / rect.width;\r\n      const scaleY = GRID_HEIGHT / rect.height;\r\n      const pixelX = Math.floor((e.clientX - rect.left) * scaleX);\r\n      const pixelY = Math.floor((e.clientY - rect.top) * scaleY);\r\n\r\n      // Get brush pixels (this will only include points inside the grid)\r\n      const points = getBrushPoints(pixelX, pixelY, brushSize);\r\n      if (points.length === 0) return;\r\n\r\n      isDrawingRef.current = true;\r\n      currentIndexRef.current = points[0];\r\n\r\n      setPixels(prev => {\r\n        const newPixels = new Uint8Array(prev);\r\n        points.forEach(idx => {\r\n          if (idx >= 0 && idx < TOTAL_PIXELS) newPixels[idx] = drawColor ? 1 : 0;\r\n        });\r\n        return newPixels;\r\n      });\r\n\r\n      // Set last point to the clicked logical position (may be outside bounds)\r\n      lastPointRef.current = { x: pixelX, y: pixelY };\r\n    };\r\n\r\n    window.addEventListener('mousedown', handleGlobalMouseDown);\r\n    return () => window.removeEventListener('mousedown', handleGlobalMouseDown);\r\n  }, [isFreeformActive, brushSize, getBrushPoints, drawColor]);\r\n\r\n  const handleReset = useCallback(() => {\r\n    const newState = new Uint8Array(TOTAL_PIXELS);\r\n    setPixels(newState);\r\n    setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n    isDrawingRef.current = false;\r\n    addToHistory(newState);\r\n  }, [addToHistory]);\r\n\r\n  // Convert Uint8Array to boolean array for ESP32Connection and BMPHandler compatibility\r\n  const pixelsAsBoolArray = useMemo(() => {\r\n    return Array.from(pixels).map(p => p === 1);\r\n  }, [pixels]);\r\n\r\n  const handleBMPPixelUpdate = useCallback((newPixels) => {\r\n    if (Array.isArray(newPixels)) {\r\n      const uint8Pixels = new Uint8Array(TOTAL_PIXELS);\r\n      newPixels.forEach((val, i) => {\r\n        uint8Pixels[i] = val ? 1 : 0;\r\n      });\r\n      setPixels(uint8Pixels);\r\n      addToHistory(uint8Pixels);\r\n    }\r\n  }, [addToHistory]);\r\n\r\n  const showBrushSizeControl = isFreeformActive;\r\n\r\n  return (\r\n    <div className=\"pixel-grid-container\">\r\n      {/* FPS Counter */}\r\n      <div style={{\r\n        position: 'absolute',\r\n        top: '10px',\r\n        left: '50%',\r\n        transform: 'translateX(-50%)',\r\n        backgroundColor: 'rgba(0,0,0,0.7)',\r\n        color: fps < 30 ? '#ff4444' : fps < 50 ? '#ffaa00' : '#44ff44',\r\n        padding: '5px 15px',\r\n        borderRadius: '4px',\r\n        fontFamily: 'monospace',\r\n        fontSize: '14px',\r\n        zIndex: 1001\r\n      }}>\r\n        FPS: {fps}\r\n      </div>\r\n\r\n      {/* ESP32 Button */}\r\n      <div className=\"esp32-container\" style={{ position: 'fixed', top: '10px', left: '10px', zIndex: 1000 }}>\r\n        <ESP32Connection pixelData={pixelsAsBoolArray} />\r\n      </div>\r\n      \r\n      {/* BMP Buttons */}\r\n      <div className=\"bmp-container\" style={{ position: 'fixed', top: '10px', right: '10px', zIndex: 1000 }}>\r\n        <BMPHandler pixelData={pixelsAsBoolArray} onPixelUpdate={handleBMPPixelUpdate} />\r\n      </div>\r\n\r\n      {/* Brush size control */}\r\n      <div className=\"brush-size-control\" style={{ visibility: showBrushSizeControl ? 'visible' : 'hidden' }}>\r\n        <label htmlFor=\"brushSize\" style={{ color: 'white', minWidth: '100px' }}>\r\n          Brush Size: {brushSize}\r\n        </label>\r\n        <input\r\n          type=\"range\"\r\n          id=\"brushSize\"\r\n          className=\"brush-size-slider\"\r\n          min=\"1\"\r\n          max=\"5\"\r\n          value={brushSize}\r\n          onChange={(e) => setBrushSize(Number(e.target.value))}\r\n        />\r\n      </div>\r\n      \r\n      {/* Mode buttons */}\r\n      <div style={{ display: 'flex', justifyContent: 'center', width: '100%', position: 'relative' }}>\r\n        <div className=\"mode-buttons-container\" style={{\r\n          position: 'relative', left: '22px', width: '1024px',\r\n          boxSizing: 'border-box', marginLeft: 'auto', marginRight: 'auto'\r\n        }}>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n              setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n            }}\r\n            className={`mode-button ${isFreeformActive ? 'active' : ''}`}\r\n          >\r\n            Freeform Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(true);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isLineModeActive ? 'active' : ''}`}\r\n          >\r\n            Line Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(true);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isCircleModeActive ? 'active' : ''}`}\r\n          >\r\n            Circle Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(true);\r\n            }}\r\n            className={`mode-button ${isRectangleModeActive ? 'active' : ''}`}\r\n          >\r\n            Rectangle Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(true);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isBucketFillModeActive ? 'active' : ''}`}\r\n          >\r\n            Bucket Fill\r\n          </button>\r\n          <button onClick={undo} className=\"mode-button\" disabled={!canUndo} style={{ marginLeft: 'auto' }}>\r\n            Undo\r\n          </button>\r\n          <button onClick={redo} className=\"mode-button\" disabled={!canRedo}>\r\n            Redo\r\n          </button>\r\n        </div>\r\n      </div>\r\n      \r\n      <div className=\"drawing-area\">\r\n        {/* Color selection */}\r\n        <div className=\"color-selector\" style={{ display: 'flex', flexDirection: 'column', gap: '15px', marginRight: '15px' }}>\r\n          <div \r\n            onClick={() => setDrawColor(true)}\r\n            style={{\r\n              width: '30px', height: '30px', backgroundColor: '#fff',\r\n              border: drawColor ? '3px solid #2196F3' : '1px solid #666',\r\n              borderRadius: '4px', cursor: 'pointer', boxSizing: 'border-box',\r\n              boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\r\n            }}\r\n            title=\"White (Draw)\"\r\n          />\r\n          <div \r\n            onClick={() => setDrawColor(false)}\r\n            style={{\r\n              width: '30px', height: '30px', backgroundColor: '#000',\r\n              border: !drawColor ? '3px solid #ff4444' : '1px solid #666',\r\n              borderRadius: '4px', cursor: 'pointer', boxSizing: 'border-box',\r\n              boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\r\n            }}\r\n            title=\"Black (Eraser)\"\r\n          />\r\n        </div>\r\n        \r\n        {/* Canvas-based pixel grid */}\r\n        <div \r\n          className=\"canvas-container\"\r\n          style={{ position: 'relative', width: `${GRID_WIDTH * PIXEL_SIZE}px`, height: `${GRID_HEIGHT * PIXEL_SIZE}px` }}\r\n          onMouseDown={handleCanvasMouseDown}\r\n          onMouseMove={handleCanvasMouseMove}\r\n          onMouseUp={handleMouseUp}\r\n          onMouseLeave={() => {\r\n            if (brushCanvasRef.current) brushCanvasRef.current.style.display = 'none';\r\n            // When the mouse leaves the canvas while freeform-drawing, break the stroke so re-entry doesn't connect\r\n            if (isFreeformActive && isDrawingRef.current) {\r\n              lastPointRef.current = null;\r\n            }\r\n          }}\r\n          onContextMenu={(e) => e.preventDefault()}\r\n        >\r\n          <canvas\r\n            ref={canvasRef}\r\n            width={GRID_WIDTH}\r\n            height={GRID_HEIGHT}\r\n            style={{\r\n              width: '100%',\r\n              height: '100%',\r\n              imageRendering: 'pixelated',\r\n              cursor: isFreeformActive ? 'none' : isBucketFillModeActive ? 'cell' : 'crosshair',\r\n              border: '1px solid #666'\r\n            }}\r\n          />\r\n          <canvas\r\n            ref={brushCanvasRef}\r\n            width={GRID_WIDTH * PIXEL_SIZE}\r\n            height={GRID_HEIGHT * PIXEL_SIZE}\r\n            style={{\r\n              position: 'absolute',\r\n              top: 0,\r\n              left: 0,\r\n              width: '100%',\r\n              height: '100%',\r\n              pointerEvents: 'none',\r\n              display: 'none'\r\n            }}\r\n          />\r\n        </div>\r\n      </div>\r\n      \r\n      <ResetButton onReset={handleReset} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PixelGrid;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}