{"ast":null,"code":"import React from 'react';\nimport { getCoordinates, drawLine } from './utils';\nconst FreeformMode = ({\n  isActive,\n  onPixelUpdate,\n  brushSize,\n  drawColor = true\n}) => {\n  // Create cached points for brush shapes of different sizes\n  const getBrushPattern = (size, centerX, centerY) => {\n    // Use a pre-calculated pattern based on size\n    const points = [];\n\n    // For size 1, just return the center point\n    if (size === 1) {\n      return [{\n        x: centerX,\n        y: centerY\n      }];\n    }\n\n    // Efficiently calculate diamond pattern\n    for (let y = -size + 1; y < size; y++) {\n      for (let x = -size + 1; x < size; x++) {\n        if (Math.abs(x) + Math.abs(y) < size) {\n          const newX = centerX + x;\n          const newY = centerY + y;\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\n            points.push({\n              x: newX,\n              y: newY\n            });\n          }\n        }\n      }\n    }\n    return points;\n  };\n  const handleDraw = (lastPoint, currentIndex) => {\n    const currentPoint = getCoordinates(currentIndex);\n    if (!lastPoint) return currentPoint;\n\n    // Create a set to avoid duplicate pixel updates for performance\n    const pointsSet = new Set();\n\n    // Draw line between the two points\n    const linePoints = drawLine(lastPoint, currentPoint);\n\n    // For each point on the line, apply the brush pattern\n    linePoints.forEach(idx => {\n      const centerX = idx % 128;\n      const centerY = Math.floor(idx / 128);\n\n      // Apply brush pattern at this point\n      const brushPattern = getBrushPattern(brushSize, centerX, centerY);\n      brushPattern.forEach(point => {\n        if (point.x >= 0 && point.x < 128 && point.y >= 0 && point.y < 64) {\n          const pixelIndex = point.y * 128 + point.x;\n          pointsSet.add(pixelIndex);\n        }\n      });\n    });\n\n    // Convert set to array for the update\n    const pointsToUpdate = Array.from(pointsSet);\n\n    // Only update if we have points\n    if (pointsToUpdate.length > 0) {\n      onPixelUpdate(prev => {\n        const newPixels = [...prev];\n        pointsToUpdate.forEach(idx => {\n          newPixels[idx] = drawColor;\n        });\n        return newPixels;\n      });\n    }\n    return currentPoint;\n  };\n  const handleStart = index => {\n    const centerX = index % 128;\n    const centerY = Math.floor(index / 128);\n\n    // Get brush pattern for this point\n    const brushPattern = getBrushPattern(brushSize, centerX, centerY);\n\n    // Convert pattern to indices\n    const pointsToUpdate = brushPattern.map(point => point.y * 128 + point.x);\n    onPixelUpdate(prev => {\n      const newPixels = [...prev];\n      pointsToUpdate.forEach(idx => {\n        newPixels[idx] = drawColor;\n      });\n      return newPixels;\n    });\n  };\n  return {\n    handleDraw,\n    handleStart,\n    modeName: 'Freeform Mode',\n    isActive\n  };\n};\n_c = FreeformMode;\nexport default FreeformMode;\nvar _c;\n$RefreshReg$(_c, \"FreeformMode\");","map":{"version":3,"names":["React","getCoordinates","drawLine","FreeformMode","isActive","onPixelUpdate","brushSize","drawColor","getBrushPattern","size","centerX","centerY","points","x","y","Math","abs","newX","newY","push","handleDraw","lastPoint","currentIndex","currentPoint","pointsSet","Set","linePoints","forEach","idx","floor","brushPattern","point","pixelIndex","add","pointsToUpdate","Array","from","length","prev","newPixels","handleStart","index","map","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/FreeFormMode.jsx"],"sourcesContent":["import React from 'react';\r\nimport { getCoordinates, drawLine } from './utils';\r\n\r\nconst FreeformMode = ({ isActive, onPixelUpdate, brushSize, drawColor = true }) => {\r\n  // Create cached points for brush shapes of different sizes\r\n  const getBrushPattern = (size, centerX, centerY) => {\r\n    // Use a pre-calculated pattern based on size\r\n    const points = [];\r\n    \r\n    // For size 1, just return the center point\r\n    if (size === 1) {\r\n      return [{ x: centerX, y: centerY }];\r\n    }\r\n    \r\n    // Efficiently calculate diamond pattern\r\n    for (let y = -size + 1; y < size; y++) {\r\n      for (let x = -size + 1; x < size; x++) {\r\n        if (Math.abs(x) + Math.abs(y) < size) {\r\n          const newX = centerX + x;\r\n          const newY = centerY + y;\r\n          \r\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\r\n            points.push({ x: newX, y: newY });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return points;\r\n  };\r\n\r\n  const handleDraw = (lastPoint, currentIndex) => {\r\n    const currentPoint = getCoordinates(currentIndex);\r\n    if (!lastPoint) return currentPoint;\r\n\r\n    // Create a set to avoid duplicate pixel updates for performance\r\n    const pointsSet = new Set();\r\n\r\n    // Draw line between the two points\r\n    const linePoints = drawLine(lastPoint, currentPoint);\r\n    \r\n    // For each point on the line, apply the brush pattern\r\n    linePoints.forEach(idx => {\r\n      const centerX = idx % 128;\r\n      const centerY = Math.floor(idx / 128);\r\n      \r\n      // Apply brush pattern at this point\r\n      const brushPattern = getBrushPattern(brushSize, centerX, centerY);\r\n      \r\n      brushPattern.forEach(point => {\r\n        if (point.x >= 0 && point.x < 128 && point.y >= 0 && point.y < 64) {\r\n          const pixelIndex = point.y * 128 + point.x;\r\n          pointsSet.add(pixelIndex);\r\n        }\r\n      });\r\n    });\r\n\r\n    // Convert set to array for the update\r\n    const pointsToUpdate = Array.from(pointsSet);\r\n    \r\n    // Only update if we have points\r\n    if (pointsToUpdate.length > 0) {\r\n      onPixelUpdate(prev => {\r\n        const newPixels = [...prev];\r\n        pointsToUpdate.forEach(idx => {\r\n          newPixels[idx] = drawColor;\r\n        });\r\n        return newPixels;\r\n      });\r\n    }\r\n    \r\n    return currentPoint;\r\n  };\r\n\r\n  const handleStart = (index) => {\r\n    const centerX = index % 128;\r\n    const centerY = Math.floor(index / 128);\r\n    \r\n    // Get brush pattern for this point\r\n    const brushPattern = getBrushPattern(brushSize, centerX, centerY);\r\n    \r\n    // Convert pattern to indices\r\n    const pointsToUpdate = brushPattern.map(point => point.y * 128 + point.x);\r\n    \r\n    onPixelUpdate(prev => {\r\n      const newPixels = [...prev];\r\n      pointsToUpdate.forEach(idx => {\r\n        newPixels[idx] = drawColor;\r\n      });\r\n      return newPixels;\r\n    });\r\n  };\r\n\r\n  return {\r\n    handleDraw,\r\n    handleStart,\r\n    modeName: 'Freeform Mode',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default FreeformMode;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}