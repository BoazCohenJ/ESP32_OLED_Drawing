{"ast":null,"code":"import React from 'react';\nimport { getIndex } from './utils';\nconst EraserMode = ({\n  isActive,\n  onPixelUpdate,\n  brushSize = 1\n}) => {\n  // Calculate all points within the brush radius\n  const getPointsInRadius = (centerIndex, radius) => {\n    const centerX = centerIndex % 128;\n    const centerY = Math.floor(centerIndex / 128);\n    const points = [];\n    for (let y = -radius; y <= radius; y++) {\n      for (let x = -radius; x <= radius; x++) {\n        // Check if point is within circular brush area\n        if (x * x + y * y <= radius * radius) {\n          const newX = centerX + x;\n          const newY = centerY + y;\n\n          // Make sure we're within bounds\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\n            const index = getIndex(newX, newY);\n            points.push(index);\n          }\n        }\n      }\n    }\n    return points;\n  };\n  const erase = index => {\n    if (!isActive) return;\n    const radius = Math.floor(brushSize / 2);\n    const pointsToErase = getPointsInRadius(index, radius);\n    onPixelUpdate(prevPixels => {\n      const newPixels = [...prevPixels];\n      pointsToErase.forEach(idx => {\n        newPixels[idx] = false; // Set to false to erase\n      });\n      return newPixels;\n    });\n  };\n  const drawLine = (start, end) => {\n    if (!isActive) return start;\n    const startX = start.x;\n    const startY = start.y;\n    const endX = end.x;\n    const endY = end.y;\n\n    // Calculate the distance between the points\n    const dx = Math.abs(endX - startX);\n    const dy = Math.abs(endY - startY);\n    const sx = startX < endX ? 1 : -1;\n    const sy = startY < endY ? 1 : -1;\n    let err = dx - dy;\n    let currentX = startX;\n    let currentY = startY;\n    while (true) {\n      // Erase at the current position\n      const index = getIndex(currentX, currentY);\n      erase(index);\n\n      // Check if we've reached the end\n      if (currentX === endX && currentY === endY) break;\n\n      // Calculate the next position\n      const e2 = 2 * err;\n      if (e2 > -dy) {\n        err -= dy;\n        currentX += sx;\n      }\n      if (e2 < dx) {\n        err += dx;\n        currentY += sy;\n      }\n    }\n    return {\n      x: endX,\n      y: endY\n    };\n  };\n  const handleStart = index => {\n    if (!isActive) return;\n    erase(index);\n  };\n  const handleDraw = (startPoint, endIndex) => {\n    if (!isActive || !startPoint) return startPoint;\n    const endX = endIndex % 128;\n    const endY = Math.floor(endIndex / 128);\n    const endPoint = {\n      x: endX,\n      y: endY\n    };\n    return drawLine(startPoint, endPoint);\n  };\n  return {\n    handleStart,\n    handleDraw,\n    modeName: 'Eraser',\n    isActive\n  };\n};\n_c = EraserMode;\nexport default EraserMode;\nvar _c;\n$RefreshReg$(_c, \"EraserMode\");","map":{"version":3,"names":["React","getIndex","EraserMode","isActive","onPixelUpdate","brushSize","getPointsInRadius","centerIndex","radius","centerX","centerY","Math","floor","points","y","x","newX","newY","index","push","erase","pointsToErase","prevPixels","newPixels","forEach","idx","drawLine","start","end","startX","startY","endX","endY","dx","abs","dy","sx","sy","err","currentX","currentY","e2","handleStart","handleDraw","startPoint","endIndex","endPoint","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/EraserMode.jsx"],"sourcesContent":["import React from 'react';\r\nimport { getIndex } from './utils';\r\n\r\nconst EraserMode = ({ isActive, onPixelUpdate, brushSize = 1 }) => {\r\n  // Calculate all points within the brush radius\r\n  const getPointsInRadius = (centerIndex, radius) => {\r\n    const centerX = centerIndex % 128;\r\n    const centerY = Math.floor(centerIndex / 128);\r\n    const points = [];\r\n\r\n    for (let y = -radius; y <= radius; y++) {\r\n      for (let x = -radius; x <= radius; x++) {\r\n        // Check if point is within circular brush area\r\n        if (x*x + y*y <= radius*radius) {\r\n          const newX = centerX + x;\r\n          const newY = centerY + y;\r\n          \r\n          // Make sure we're within bounds\r\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\r\n            const index = getIndex(newX, newY);\r\n            points.push(index);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return points;\r\n  };\r\n\r\n  const erase = (index) => {\r\n    if (!isActive) return;\r\n\r\n    const radius = Math.floor(brushSize / 2);\r\n    const pointsToErase = getPointsInRadius(index, radius);\r\n    \r\n    onPixelUpdate(prevPixels => {\r\n      const newPixels = [...prevPixels];\r\n      pointsToErase.forEach(idx => {\r\n        newPixels[idx] = false; // Set to false to erase\r\n      });\r\n      return newPixels;\r\n    });\r\n  };\r\n\r\n  const drawLine = (start, end) => {\r\n    if (!isActive) return start;\r\n    \r\n    const startX = start.x;\r\n    const startY = start.y;\r\n    const endX = end.x;\r\n    const endY = end.y;\r\n    \r\n    // Calculate the distance between the points\r\n    const dx = Math.abs(endX - startX);\r\n    const dy = Math.abs(endY - startY);\r\n    const sx = startX < endX ? 1 : -1;\r\n    const sy = startY < endY ? 1 : -1;\r\n    let err = dx - dy;\r\n    \r\n    let currentX = startX;\r\n    let currentY = startY;\r\n    \r\n    while (true) {\r\n      // Erase at the current position\r\n      const index = getIndex(currentX, currentY);\r\n      erase(index);\r\n      \r\n      // Check if we've reached the end\r\n      if (currentX === endX && currentY === endY) break;\r\n      \r\n      // Calculate the next position\r\n      const e2 = 2 * err;\r\n      if (e2 > -dy) {\r\n        err -= dy;\r\n        currentX += sx;\r\n      }\r\n      if (e2 < dx) {\r\n        err += dx;\r\n        currentY += sy;\r\n      }\r\n    }\r\n    \r\n    return { x: endX, y: endY };\r\n  };\r\n\r\n  const handleStart = (index) => {\r\n    if (!isActive) return;\r\n    erase(index);\r\n  };\r\n\r\n  const handleDraw = (startPoint, endIndex) => {\r\n    if (!isActive || !startPoint) return startPoint;\r\n    \r\n    const endX = endIndex % 128;\r\n    const endY = Math.floor(endIndex / 128);\r\n    const endPoint = { x: endX, y: endY };\r\n    \r\n    return drawLine(startPoint, endPoint);\r\n  };\r\n\r\n  return {\r\n    handleStart,\r\n    handleDraw,\r\n    modeName: 'Eraser',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default EraserMode;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}