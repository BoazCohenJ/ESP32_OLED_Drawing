{"ast":null,"code":"import React from 'react';\nconst getCoordinates = index => ({\n  x: index % 128,\n  y: Math.floor(index / 128)\n});\nconst getIndex = (x, y) => y * 128 + x;\nconst bucketFill = (startIndex, pixels) => {\n  const targetColor = pixels[startIndex];\n  if (targetColor === true) return [];\n  const width = 128;\n  const height = 64;\n  const stack = [startIndex];\n  const filledPoints = [];\n  const visited = new Set();\n  while (stack.length > 0) {\n    const currentIndex = stack.pop();\n    if (visited.has(currentIndex)) continue;\n    visited.add(currentIndex);\n    if (pixels[currentIndex] !== targetColor) continue;\n    filledPoints.push(currentIndex);\n    const {\n      x,\n      y\n    } = getCoordinates(currentIndex);\n    const neighbors = [{\n      dx: 0,\n      dy: -1\n    }, {\n      dx: 1,\n      dy: 0\n    }, {\n      dx: 0,\n      dy: 1\n    }, {\n      dx: -1,\n      dy: 0\n    }];\n    for (const {\n      dx,\n      dy\n    } of neighbors) {\n      const newX = x + dx;\n      const newY = y + dy;\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n        const neighborIndex = getIndex(newX, newY);\n        if (!visited.has(neighborIndex) && pixels[neighborIndex] === targetColor) {\n          stack.push(neighborIndex);\n        }\n      }\n    }\n  }\n  return filledPoints;\n};\nconst outlineFill = (startIndex, pixels) => {\n  if (pixels[startIndex] !== true) return [];\n  const width = 128;\n  const height = 64;\n  const stack = [startIndex];\n  const filledPoints = [];\n  const edgePoints = new Set();\n  const visited = new Set();\n  while (stack.length > 0) {\n    const currentIndex = stack.pop();\n    if (visited.has(currentIndex)) continue;\n    visited.add(currentIndex);\n    if (pixels[currentIndex] !== true) continue;\n    filledPoints.push(currentIndex);\n    const {\n      x,\n      y\n    } = getCoordinates(currentIndex);\n    const neighbors = [{\n      dx: 0,\n      dy: -1\n    }, {\n      dx: 1,\n      dy: 0\n    }, {\n      dx: 0,\n      dy: 1\n    }, {\n      dx: -1,\n      dy: 0\n    }];\n    let isEdge = false;\n    for (const {\n      dx,\n      dy\n    } of neighbors) {\n      const newX = x + dx;\n      const newY = y + dy;\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n        const neighborIndex = getIndex(newX, newY);\n        if (pixels[neighborIndex] === true) {\n          if (!visited.has(neighborIndex)) {\n            stack.push(neighborIndex);\n          }\n        } else {\n          isEdge = true;\n        }\n      } else {\n        isEdge = true;\n      }\n    }\n    if (isEdge) {\n      edgePoints.add(currentIndex);\n    }\n  }\n  return filledPoints.filter(idx => !edgePoints.has(idx));\n};\nconst BucketFillMode = ({\n  isActive,\n  onPixelUpdate,\n  drawColor = true\n}) => {\n  const handleFill = (index, pixels) => {\n    if (!isActive) return;\n    let pointsToModify;\n    if (!drawColor && pixels[index] === true) {\n      pointsToModify = outlineFill(index, pixels);\n    } else {\n      pointsToModify = bucketFill(index, pixels);\n    }\n    if (pointsToModify.length > 0) {\n      onPixelUpdate(prev => {\n        const newPixels = [...prev];\n        pointsToModify.forEach(idx => {\n          newPixels[idx] = drawColor;\n        });\n        return newPixels;\n      });\n      return pointsToModify;\n    }\n    return [];\n  };\n  return {\n    handleFill,\n    modeName: 'Bucket Fill',\n    isActive\n  };\n};\n_c = BucketFillMode;\nexport default BucketFillMode;\nvar _c;\n$RefreshReg$(_c, \"BucketFillMode\");","map":{"version":3,"names":["React","getCoordinates","index","x","y","Math","floor","getIndex","bucketFill","startIndex","pixels","targetColor","width","height","stack","filledPoints","visited","Set","length","currentIndex","pop","has","add","push","neighbors","dx","dy","newX","newY","neighborIndex","outlineFill","edgePoints","isEdge","filter","idx","BucketFillMode","isActive","onPixelUpdate","drawColor","handleFill","pointsToModify","prev","newPixels","forEach","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/BucketFillMode.jsx"],"sourcesContent":["import React from 'react';\r\n\r\nconst getCoordinates = (index) => ({\r\n  x: index % 128,\r\n  y: Math.floor(index / 128)\r\n});\r\n\r\nconst getIndex = (x, y) => y * 128 + x;\r\n\r\nconst bucketFill = (startIndex, pixels) => {\r\n  const targetColor = pixels[startIndex];\r\n  if (targetColor === true) return [];\r\n  const width = 128;\r\n  const height = 64;\r\n  const stack = [startIndex];\r\n  const filledPoints = [];\r\n  const visited = new Set();\r\n  while (stack.length > 0) {\r\n    const currentIndex = stack.pop();\r\n    if (visited.has(currentIndex)) continue;\r\n    visited.add(currentIndex);\r\n    if (pixels[currentIndex] !== targetColor) continue;\r\n    filledPoints.push(currentIndex);\r\n    const { x, y } = getCoordinates(currentIndex);\r\n    const neighbors = [\r\n      { dx: 0, dy: -1 },\r\n      { dx: 1, dy: 0 },\r\n      { dx: 0, dy: 1 },\r\n      { dx: -1, dy: 0 }\r\n    ];\r\n    for (const { dx, dy } of neighbors) {\r\n      const newX = x + dx;\r\n      const newY = y + dy;\r\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\r\n        const neighborIndex = getIndex(newX, newY);\r\n        if (!visited.has(neighborIndex) && pixels[neighborIndex] === targetColor) {\r\n          stack.push(neighborIndex);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  return filledPoints;\r\n};\r\n\r\nconst outlineFill = (startIndex, pixels) => {\r\n  if (pixels[startIndex] !== true) return [];\r\n  const width = 128;\r\n  const height = 64;\r\n  const stack = [startIndex];\r\n  const filledPoints = [];\r\n  const edgePoints = new Set();\r\n  const visited = new Set();\r\n  while (stack.length > 0) {\r\n    const currentIndex = stack.pop();\r\n    if (visited.has(currentIndex)) continue;\r\n    visited.add(currentIndex);\r\n    if (pixels[currentIndex] !== true) continue;\r\n    filledPoints.push(currentIndex);\r\n    const { x, y } = getCoordinates(currentIndex);\r\n    const neighbors = [\r\n      { dx: 0, dy: -1 },\r\n      { dx: 1, dy: 0 },\r\n      { dx: 0, dy: 1 },\r\n      { dx: -1, dy: 0 }\r\n    ];\r\n    let isEdge = false;\r\n    for (const { dx, dy } of neighbors) {\r\n      const newX = x + dx;\r\n      const newY = y + dy;\r\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\r\n        const neighborIndex = getIndex(newX, newY);\r\n        if (pixels[neighborIndex] === true) {\r\n          if (!visited.has(neighborIndex)) {\r\n            stack.push(neighborIndex);\r\n          }\r\n        } else {\r\n          isEdge = true;\r\n        }\r\n      } else {\r\n        isEdge = true;\r\n      }\r\n    }\r\n    if (isEdge) {\r\n      edgePoints.add(currentIndex);\r\n    }\r\n  }\r\n  return filledPoints.filter(idx => !edgePoints.has(idx));\r\n};\r\n\r\nconst BucketFillMode = ({ isActive, onPixelUpdate, drawColor = true }) => {\r\n  const handleFill = (index, pixels) => {\r\n    if (!isActive) return;\r\n    let pointsToModify;\r\n    if (!drawColor && pixels[index] === true) {\r\n      pointsToModify = outlineFill(index, pixels);\r\n    } else {\r\n      pointsToModify = bucketFill(index, pixels);\r\n    }\r\n    if (pointsToModify.length > 0) {\r\n      onPixelUpdate(prev => {\r\n        const newPixels = [...prev];\r\n        pointsToModify.forEach(idx => {\r\n          newPixels[idx] = drawColor;\r\n        });\r\n        return newPixels;\r\n      });\r\n      return pointsToModify;\r\n    }\r\n    return [];\r\n  };\r\n\r\n  return {\r\n    handleFill,\r\n    modeName: 'Bucket Fill',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default BucketFillMode;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}