{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\wikx3\\\\Documents\\\\VS_code\\\\React\\\\AOD\\\\src\\\\components\\\\pixelGrid\\\\index.jsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\nimport FreeformMode from './FreeFormMode';\nimport LineMode from './LineMode';\nimport ResetButton from './ResetButton';\nimport { getCoordinates } from './utils';\nimport CircleMode from './CircleMode';\nimport BucketFillMode from './BucketFillMode';\nimport { useUndoRedo } from './useUndoRedo';\nimport RectangleMode from './RectangleMode';\nimport ESP32Connection from '../ESP32Connection';\nimport BMPHandler from '../BMPHandler';\n\n// Create a memoized Pixel component to prevent unnecessary re-renders\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst Pixel = /*#__PURE__*/React.memo(_c = ({\n  index,\n  isWhite,\n  previewState,\n  onMouseDown,\n  onMouseEnter,\n  cursorStyle\n}) => {\n  let className = 'pixel';\n  if (previewState === true) {\n    className += ' white';\n  } else if (previewState === 'black-preview') {\n    className += ' black-preview';\n  } else if (isWhite) {\n    className += ' white';\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: className,\n    onMouseDown: () => onMouseDown(index),\n    onMouseEnter: () => onMouseEnter(index),\n    style: {\n      cursor: cursorStyle\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 25,\n    columnNumber: 5\n  }, this);\n});\n_c2 = Pixel;\nconst PixelGrid = () => {\n  _s();\n  const [pixels, setPixels] = useState(Array(8192).fill(false));\n  const [isLineModeActive, setIsLineModeActive] = useState(false);\n  const [isCircleModeActive, setIsCircleModeActive] = useState(false);\n  const [isBucketFillModeActive, setIsBucketFillModeActive] = useState(false);\n  const [isRectangleModeActive, setIsRectangleModeActive] = useState(false);\n  const [previewPixels, setPreviewPixels] = useState(Array(8192).fill(false));\n  const isDrawingRef = useRef(false);\n  const startPointRef = useRef(null);\n  const lastPointRef = useRef(null);\n  const [isSpacePressed, setIsSpacePressed] = useState(false);\n  const currentIndexRef = useRef(null);\n  const [brushSize, setBrushSize] = useState(1);\n  const [drawColor, setDrawColor] = useState(true); // true for white, false for black\n  const rafRef = useRef(null); // For requestAnimationFrame\n  const pendingUpdatesRef = useRef(null); // Store pending pixel updates\n\n  const {\n    addToHistory,\n    undo,\n    redo,\n    canUndo,\n    canRedo\n  } = useUndoRedo(Array(8192).fill(false));\n\n  // Add these new states for brush outline\n  const outlineRef = useRef(null);\n  const [showOutline, setShowOutline] = useState(false);\n\n  // Batch update pixels with requestAnimationFrame for better performance\n  const batchPixelUpdate = useCallback(updateFn => {\n    if (rafRef.current) return; // Already have a pending update\n\n    pendingUpdatesRef.current = updateFn;\n    rafRef.current = requestAnimationFrame(() => {\n      if (pendingUpdatesRef.current) {\n        setPixels(prevPixels => pendingUpdatesRef.current(prevPixels));\n        pendingUpdatesRef.current = null;\n      }\n      rafRef.current = null;\n    });\n  }, []);\n\n  // Batch update preview pixels with requestAnimationFrame\n  const batchPreviewUpdate = useCallback(updateFn => {\n    if (!updateFn) return;\n    requestAnimationFrame(() => {\n      setPreviewPixels(updateFn);\n    });\n  }, []);\n  useEffect(() => {\n    const handleKeyDown = e => {\n      if (e.code === 'Space' && !isSpacePressed && currentIndexRef.current !== null) {\n        e.preventDefault();\n        setIsSpacePressed(true);\n        handleMouseDown(currentIndexRef.current);\n      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\n        e.preventDefault();\n        if (e.shiftKey) {\n          // Handle Ctrl+Shift+Z (Windows) or Cmd+Shift+Z (Mac)\n          handleRedo();\n        } else {\n          // Handle Ctrl+Z (Windows) or Cmd+Z (Mac)\n          handleUndo();\n        }\n      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\n        // Add alternative redo shortcut (Ctrl+Y)\n        e.preventDefault();\n        handleRedo();\n      } else if (e.key === 'b') {\n        // Shortcut for brush (freeform)\n        e.preventDefault();\n        setIsLineModeActive(false);\n        setIsCircleModeActive(false);\n        setIsBucketFillModeActive(false);\n      }\n    };\n    const handleKeyUp = e => {\n      if (e.code === 'Space') {\n        e.preventDefault();\n        setIsSpacePressed(false);\n        // Add state to history when space drawing ends\n        if (isDrawingRef.current) {\n          addToHistory([...pixels]);\n        }\n        handleMouseUp();\n      }\n    };\n    window.addEventListener('keydown', handleKeyDown);\n    window.addEventListener('keyup', handleKeyUp);\n    return () => {\n      window.removeEventListener('keydown', handleKeyDown);\n      window.removeEventListener('keyup', handleKeyUp);\n    };\n  }, [isSpacePressed, pixels, addToHistory]); // Add dependencies\n\n  // Clean up RAF on unmount\n  useEffect(() => {\n    return () => {\n      if (rafRef.current) {\n        cancelAnimationFrame(rafRef.current);\n        rafRef.current = null;\n      }\n    };\n  }, []);\n  const handlePixelUpdate = useCallback(updateFn => {\n    batchPixelUpdate(updateFn);\n  }, [batchPixelUpdate]);\n  const handleUndo = () => {\n    const previousState = undo();\n    if (previousState) {\n      setPixels(previousState);\n    }\n  };\n  const handleRedo = () => {\n    const nextState = redo();\n    if (nextState) {\n      setPixels(nextState);\n    }\n  };\n\n  // Use useMemo to calculate active mode only when dependencies change\n  const isFreeformActive = useMemo(() => {\n    return !isLineModeActive && !isCircleModeActive && !isBucketFillModeActive && !isRectangleModeActive;\n  }, [isLineModeActive, isCircleModeActive, isBucketFillModeActive, isRectangleModeActive]);\n\n  // Use useMemo for these mode objects to avoid re-creating on every render\n  const freeformMode = useMemo(() => FreeformMode({\n    isActive: isFreeformActive,\n    onPixelUpdate: handlePixelUpdate,\n    brushSize,\n    drawColor\n  }), [isFreeformActive, handlePixelUpdate, brushSize, drawColor]);\n  const lineMode = useMemo(() => LineMode({\n    isActive: isLineModeActive,\n    onPixelUpdate: handlePixelUpdate,\n    onPreviewUpdate: batchPreviewUpdate,\n    drawColor\n  }), [isLineModeActive, handlePixelUpdate, batchPreviewUpdate, drawColor]);\n  const circleMode = useMemo(() => CircleMode({\n    isActive: isCircleModeActive,\n    onPixelUpdate: handlePixelUpdate,\n    onPreviewUpdate: batchPreviewUpdate,\n    drawColor\n  }), [isCircleModeActive, handlePixelUpdate, batchPreviewUpdate, drawColor]);\n  const bucketFillMode = useMemo(() => BucketFillMode({\n    isActive: isBucketFillModeActive,\n    onPixelUpdate: handlePixelUpdate,\n    drawColor\n  }), [isBucketFillModeActive, handlePixelUpdate, drawColor]);\n  const rectangleMode = useMemo(() => RectangleMode({\n    isActive: isRectangleModeActive,\n    onPixelUpdate: handlePixelUpdate,\n    onPreviewUpdate: batchPreviewUpdate,\n    drawColor\n  }), [isRectangleModeActive, handlePixelUpdate, batchPreviewUpdate, drawColor]);\n  const handleMouseDown = useCallback(index => {\n    isDrawingRef.current = true;\n    if (isBucketFillModeActive) {\n      // For bucket fill, execute fill immediately\n      bucketFillMode.handleFill(index, pixels);\n      addToHistory([...pixels]);\n      isDrawingRef.current = false;\n      return;\n    }\n    if (isFreeformActive) {\n      // For freeform mode, draw immediately on click\n      const point = getCoordinates(index);\n      lastPointRef.current = point;\n      freeformMode.handleStart(index);\n    } else {\n      startPointRef.current = getCoordinates(index);\n      lastPointRef.current = getCoordinates(index);\n    }\n  }, [pixels, bucketFillMode, isBucketFillModeActive, isFreeformActive, freeformMode, addToHistory]);\n  const handleMouseEnter = useCallback(index => {\n    if (!isDrawingRef.current) return;\n    if (isFreeformActive) {\n      // For freeform mode\n      lastPointRef.current = freeformMode.handleDraw(lastPointRef.current, index);\n    } else if (isLineModeActive) {\n      // For line mode\n      lineMode.handlePreview(startPointRef.current, index);\n      lastPointRef.current = getCoordinates(index);\n    } else if (isCircleModeActive) {\n      // For circle mode\n      circleMode.handlePreview(startPointRef.current, index);\n      lastPointRef.current = getCoordinates(index);\n    } else if (isRectangleModeActive) {\n      // For rectangle mode\n      rectangleMode.handlePreview(startPointRef.current, index);\n      lastPointRef.current = getCoordinates(index);\n    }\n  }, [isFreeformActive, freeformMode, isLineModeActive, lineMode, isCircleModeActive, circleMode, isRectangleModeActive, rectangleMode]);\n  const handleMouseUp = useCallback(() => {\n    if (isDrawingRef.current) {\n      if ((isLineModeActive || isCircleModeActive || isRectangleModeActive) && startPointRef.current && lastPointRef.current) {\n        const endIndex = lastPointRef.current.y * 128 + lastPointRef.current.x;\n        let updatedPixels = [...pixels];\n        if (isLineModeActive && lineMode.handleCommit) {\n          const linePoints = lineMode.handleCommit(startPointRef.current, endIndex);\n          if (linePoints) {\n            linePoints.forEach(idx => {\n              updatedPixels[idx] = drawColor;\n            });\n          }\n        } else if (isCircleModeActive && circleMode.handleCommit) {\n          const circlePoints = circleMode.handleCommit(startPointRef.current, endIndex);\n          if (circlePoints) {\n            circlePoints.forEach(idx => {\n              updatedPixels[idx] = drawColor;\n            });\n          }\n        } else if (isRectangleModeActive && rectangleMode.handleCommit) {\n          const rectanglePoints = rectangleMode.handleCommit(startPointRef.current, endIndex);\n          if (rectanglePoints) {\n            rectanglePoints.forEach(idx => {\n              updatedPixels[idx] = drawColor;\n            });\n          }\n        }\n        setPixels(updatedPixels);\n        setPreviewPixels(Array(8192).fill(false));\n        addToHistory(updatedPixels);\n      } else if (!isBucketFillModeActive) {\n        // For freeform, only save on mouse up\n        addToHistory([...pixels]);\n      }\n    }\n    isDrawingRef.current = false;\n    startPointRef.current = null;\n    lastPointRef.current = null;\n  }, [pixels, isLineModeActive, isCircleModeActive, isRectangleModeActive, isBucketFillModeActive, lineMode, circleMode, rectangleMode, drawColor, addToHistory]);\n  const handleReset = useCallback(() => {\n    const newState = Array(8192).fill(false);\n    setPixels(newState);\n    setPreviewPixels(Array(8192).fill(false));\n    startPointRef.current = null;\n    lastPointRef.current = null;\n    isDrawingRef.current = false;\n    addToHistory(newState);\n  }, [addToHistory]);\n  const handlePixelHover = useCallback(index => {\n    currentIndexRef.current = index;\n    if (isDrawingRef.current || isSpacePressed) {\n      handleMouseEnter(index);\n    }\n  }, [isSpacePressed, handleMouseEnter]);\n\n  // Use this cursor style for better performance (avoid style recalculations)\n  const cursorStyle = useMemo(() => {\n    if (isFreeformActive) return 'none';\n    if (isBucketFillModeActive) return 'cell';\n    return 'crosshair';\n  }, [isFreeformActive, isBucketFillModeActive]);\n\n  // Add brush outline effect\n  useEffect(() => {\n    const handleMouseMove = e => {\n      if (!outlineRef.current) return;\n\n      // Only show outline for freeform mode\n      if (isFreeformActive) {\n        const rect = document.querySelector('.pixel-grid').getBoundingClientRect();\n        const mouseX = e.clientX - rect.left;\n        const mouseY = e.clientY - rect.top;\n\n        // Calculate which pixel we're hovering over\n        const pixelX = Math.floor(mouseX / 8);\n        const pixelY = Math.floor(mouseY / 8);\n\n        // Store the current pixel index for consistent drawing\n        const currentIndex = pixelY * 128 + pixelX;\n        currentIndexRef.current = currentIndex;\n        if (brushSize === 1) {\n          // For brush size 1, just show a simple pixel outline\n          if (pixelX >= 0 && pixelX < 128 && pixelY >= 0 && pixelY < 64) {\n            outlineRef.current.innerHTML = '';\n            outlineRef.current.style.left = `${pixelX * 8}px`;\n            outlineRef.current.style.top = `${pixelY * 8}px`;\n            outlineRef.current.style.width = `8px`;\n            outlineRef.current.style.height = `8px`;\n            outlineRef.current.style.display = 'block';\n            outlineRef.current.style.border = `1px solid ${drawColor ? 'white' : 'red'}`;\n            outlineRef.current.style.borderRadius = '0'; // Ensure square shape\n          }\n        } else {\n          // Instead of creating a canvas each time, use pre-calculated DOM elements\n          // This is much more efficient\n          outlineRef.current.style.display = 'block';\n          outlineRef.current.innerHTML = '';\n          const minX = Math.max(0, pixelX - brushSize + 1);\n          const minY = Math.max(0, pixelY - brushSize + 1);\n          const maxX = Math.min(127, pixelX + brushSize - 1);\n          const maxY = Math.min(63, pixelY + brushSize - 1);\n          outlineRef.current.style.left = `${minX * 8}px`;\n          outlineRef.current.style.top = `${minY * 8}px`;\n          outlineRef.current.style.width = `${(maxX - minX + 1) * 8}px`;\n          outlineRef.current.style.height = `${(maxY - minY + 1) * 8}px`;\n          outlineRef.current.style.border = `1px solid ${drawColor ? 'white' : 'red'}`;\n        }\n      } else {\n        outlineRef.current.style.display = 'none';\n      }\n    };\n    const grid = document.querySelector('.pixel-grid');\n    if (grid) {\n      grid.addEventListener('mousemove', handleMouseMove, {\n        passive: true\n      });\n    }\n    return () => {\n      if (grid) {\n        grid.removeEventListener('mousemove', handleMouseMove);\n      }\n    };\n  }, [brushSize, isFreeformActive, drawColor]);\n\n  // Use a more efficient approach to render pixels\n  // Create chunks of pixels to reduce the number of individual components\n  const pixelChunks = useMemo(() => {\n    const chunks = [];\n    // Generate chunks - each chunk contains 100 pixels\n    const chunkSize = 800;\n    for (let i = 0; i < pixels.length; i += chunkSize) {\n      chunks.push(pixels.slice(i, i + chunkSize));\n    }\n    return chunks;\n  }, [pixels]);\n\n  // Centralize the click handler to avoid recreating it for every pixel\n  const handlePixelClick = useCallback(event => {\n    event.preventDefault();\n    if (!currentIndexRef.current && currentIndexRef.current !== 0) return;\n    handleMouseDown(currentIndexRef.current);\n  }, [handleMouseDown]);\n\n  // Fix - Check if the grid is rendered\n  useEffect(() => {\n    console.log(\"Grid should contain:\", pixels.length, \"pixels\");\n    const grid = document.querySelector('.pixel-grid');\n    console.log(\"Grid element exists:\", !!grid);\n  }, []);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"pixel-grid-container\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"esp32-container\",\n      style: {\n        position: 'fixed',\n        top: '10px',\n        left: '10px',\n        zIndex: 1000\n      },\n      children: /*#__PURE__*/_jsxDEV(ESP32Connection, {\n        pixelData: pixels\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 412,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 406,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"bmp-container\",\n      style: {\n        position: 'fixed',\n        top: '10px',\n        right: '10px',\n        zIndex: 1000\n      },\n      children: /*#__PURE__*/_jsxDEV(BMPHandler, {\n        pixelData: pixels,\n        onPixelUpdate: setPixels\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 422,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 416,\n      columnNumber: 7\n    }, this), isFreeformActive && /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"brush-size-control\",\n      children: [/*#__PURE__*/_jsxDEV(\"label\", {\n        htmlFor: \"brushSize\",\n        style: {\n          color: 'white',\n          minWidth: '100px'\n        },\n        children: [\"Brush Size: \", brushSize]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 428,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"range\",\n        id: \"brushSize\",\n        className: \"brush-size-slider\",\n        min: \"1\",\n        max: \"5\",\n        value: brushSize,\n        onChange: e => setBrushSize(Number(e.target.value))\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 431,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 427,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"mode-buttons-container\",\n      children: [/*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          setIsLineModeActive(false);\n          setIsCircleModeActive(false);\n          setIsBucketFillModeActive(false);\n          setIsRectangleModeActive(false);\n          setPreviewPixels(Array(8192).fill(false));\n        },\n        className: `mode-button ${isFreeformActive ? 'active' : ''}`,\n        children: freeformMode.modeName\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 444,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          setIsLineModeActive(true);\n          setIsCircleModeActive(false);\n          setIsBucketFillModeActive(false);\n          setIsRectangleModeActive(false);\n        },\n        className: `mode-button ${isLineModeActive ? 'active' : ''}`,\n        children: lineMode.modeName\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 456,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          setIsLineModeActive(false);\n          setIsCircleModeActive(true);\n          setIsBucketFillModeActive(false);\n          setIsRectangleModeActive(false);\n        },\n        className: `mode-button ${isCircleModeActive ? 'active' : ''}`,\n        children: circleMode.modeName\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 467,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          setIsLineModeActive(false);\n          setIsCircleModeActive(false);\n          setIsBucketFillModeActive(false);\n          setIsRectangleModeActive(true);\n        },\n        className: `mode-button ${isRectangleModeActive ? 'active' : ''}`,\n        children: rectangleMode.modeName\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 478,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => {\n          setIsLineModeActive(false);\n          setIsCircleModeActive(false);\n          setIsBucketFillModeActive(true);\n          setIsRectangleModeActive(false);\n        },\n        className: `mode-button ${isBucketFillModeActive ? 'active' : ''}`,\n        children: bucketFillMode.modeName\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 489,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleUndo,\n        className: \"mode-button\",\n        disabled: !canUndo,\n        style: {\n          marginLeft: 'auto'\n        },\n        children: \"Undo\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 500,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: handleRedo,\n        className: \"mode-button\",\n        disabled: !canRedo,\n        children: \"Redo\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 508,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 443,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'relative',\n        width: '1024px',\n        height: '512px'\n      },\n      children: [\" \", /*#__PURE__*/_jsxDEV(\"div\", {\n        style: {\n          position: 'absolute',\n          left: '-34px',\n          top: 0,\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'center',\n          height: '100%',\n          justifyContent: 'center',\n          zIndex: 1\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => setDrawColor(true),\n          style: {\n            width: '24px',\n            height: '24px',\n            backgroundColor: '#fff',\n            border: drawColor ? '2px solid #2196F3' : '1px solid #666',\n            marginBottom: '10px',\n            cursor: 'pointer',\n            boxSizing: 'border-box'\n          },\n          title: \"White (Draw)\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 530,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n          onClick: () => setDrawColor(false),\n          style: {\n            width: '24px',\n            height: '24px',\n            backgroundColor: '#000',\n            border: !drawColor ? '2px solid red' : '1px solid #666',\n            cursor: 'pointer',\n            boxSizing: 'border-box'\n          },\n          title: \"Black (Eraser)\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 543,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 519,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"pixel-grid\",\n        onMouseDown: handlePixelClick,\n        onMouseUp: handleMouseUp,\n        onMouseLeave: handleMouseUp,\n        style: {\n          display: 'grid',\n          gridTemplateColumns: 'repeat(128, 8px)',\n          gridTemplateRows: 'repeat(64, 8px)',\n          width: '1024px',\n          height: '512px'\n        },\n        children: [/*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"brush-outline\",\n          ref: outlineRef,\n          style: {\n            borderColor: drawColor ? 'white' : 'red'\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 572,\n          columnNumber: 11\n        }, this), pixels.map((isWhite, index) => {\n          const previewState = previewPixels[index];\n          return /*#__PURE__*/_jsxDEV(Pixel, {\n            index: index,\n            isWhite: isWhite,\n            previewState: previewState,\n            onMouseDown: handleMouseDown,\n            onMouseEnter: handlePixelHover,\n            cursorStyle: cursorStyle\n          }, index, false, {\n            fileName: _jsxFileName,\n            lineNumber: 584,\n            columnNumber: 15\n          }, this);\n        })]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 558,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 517,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(ResetButton, {\n      onReset: handleReset\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 597,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 404,\n    columnNumber: 5\n  }, this);\n};\n_s(PixelGrid, \"Y5AFgrqqmJCL02LT70FBHCilbTM=\", false, function () {\n  return [useUndoRedo];\n});\n_c3 = PixelGrid;\nexport default PixelGrid;\nvar _c, _c2, _c3;\n$RefreshReg$(_c, \"Pixel$React.memo\");\n$RefreshReg$(_c2, \"Pixel\");\n$RefreshReg$(_c3, \"PixelGrid\");","map":{"version":3,"names":["React","useState","useRef","useEffect","useCallback","useMemo","FreeformMode","LineMode","ResetButton","getCoordinates","CircleMode","BucketFillMode","useUndoRedo","RectangleMode","ESP32Connection","BMPHandler","jsxDEV","_jsxDEV","Pixel","memo","_c","index","isWhite","previewState","onMouseDown","onMouseEnter","cursorStyle","className","style","cursor","fileName","_jsxFileName","lineNumber","columnNumber","_c2","PixelGrid","_s","pixels","setPixels","Array","fill","isLineModeActive","setIsLineModeActive","isCircleModeActive","setIsCircleModeActive","isBucketFillModeActive","setIsBucketFillModeActive","isRectangleModeActive","setIsRectangleModeActive","previewPixels","setPreviewPixels","isDrawingRef","startPointRef","lastPointRef","isSpacePressed","setIsSpacePressed","currentIndexRef","brushSize","setBrushSize","drawColor","setDrawColor","rafRef","pendingUpdatesRef","addToHistory","undo","redo","canUndo","canRedo","outlineRef","showOutline","setShowOutline","batchPixelUpdate","updateFn","current","requestAnimationFrame","prevPixels","batchPreviewUpdate","handleKeyDown","e","code","preventDefault","handleMouseDown","ctrlKey","metaKey","key","toLowerCase","shiftKey","handleRedo","handleUndo","handleKeyUp","handleMouseUp","window","addEventListener","removeEventListener","cancelAnimationFrame","handlePixelUpdate","previousState","nextState","isFreeformActive","freeformMode","isActive","onPixelUpdate","lineMode","onPreviewUpdate","circleMode","bucketFillMode","rectangleMode","handleFill","point","handleStart","handleMouseEnter","handleDraw","handlePreview","endIndex","y","x","updatedPixels","handleCommit","linePoints","forEach","idx","circlePoints","rectanglePoints","handleReset","newState","handlePixelHover","handleMouseMove","rect","document","querySelector","getBoundingClientRect","mouseX","clientX","left","mouseY","clientY","top","pixelX","Math","floor","pixelY","currentIndex","innerHTML","width","height","display","border","borderRadius","minX","max","minY","maxX","min","maxY","grid","passive","pixelChunks","chunks","chunkSize","i","length","push","slice","handlePixelClick","event","console","log","children","position","zIndex","pixelData","right","htmlFor","color","minWidth","type","id","value","onChange","Number","target","onClick","modeName","disabled","marginLeft","flexDirection","alignItems","justifyContent","backgroundColor","marginBottom","boxSizing","title","onMouseUp","onMouseLeave","gridTemplateColumns","gridTemplateRows","ref","borderColor","map","onReset","_c3","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/index.jsx"],"sourcesContent":["import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\r\nimport FreeformMode from './FreeFormMode';\r\nimport LineMode from './LineMode';\r\nimport ResetButton from './ResetButton';\r\nimport { getCoordinates } from './utils';\r\nimport CircleMode from './CircleMode';\r\nimport BucketFillMode from './BucketFillMode';\r\nimport { useUndoRedo } from './useUndoRedo';\r\nimport RectangleMode from './RectangleMode';\r\nimport ESP32Connection from '../ESP32Connection';\r\nimport BMPHandler from '../BMPHandler';\r\n\r\n// Create a memoized Pixel component to prevent unnecessary re-renders\r\nconst Pixel = React.memo(({ index, isWhite, previewState, onMouseDown, onMouseEnter, cursorStyle }) => {\r\n  let className = 'pixel';\r\n  if (previewState === true) {\r\n    className += ' white';\r\n  } else if (previewState === 'black-preview') {\r\n    className += ' black-preview';\r\n  } else if (isWhite) {\r\n    className += ' white';\r\n  }\r\n\r\n  return (\r\n    <div\r\n      className={className}\r\n      onMouseDown={() => onMouseDown(index)}\r\n      onMouseEnter={() => onMouseEnter(index)}\r\n      style={{ cursor: cursorStyle }}\r\n    />\r\n  );\r\n});\r\n\r\nconst PixelGrid = () => {\r\n  const [pixels, setPixels] = useState(Array(8192).fill(false));\r\n  const [isLineModeActive, setIsLineModeActive] = useState(false);\r\n  const [isCircleModeActive, setIsCircleModeActive] = useState(false);\r\n  const [isBucketFillModeActive, setIsBucketFillModeActive] = useState(false);\r\n  const [isRectangleModeActive, setIsRectangleModeActive] = useState(false);\r\n  const [previewPixels, setPreviewPixels] = useState(Array(8192).fill(false));\r\n  const isDrawingRef = useRef(false);\r\n  const startPointRef = useRef(null);\r\n  const lastPointRef = useRef(null);\r\n  const [isSpacePressed, setIsSpacePressed] = useState(false);\r\n  const currentIndexRef = useRef(null);\r\n  const [brushSize, setBrushSize] = useState(1);\r\n  const [drawColor, setDrawColor] = useState(true); // true for white, false for black\r\n  const rafRef = useRef(null); // For requestAnimationFrame\r\n  const pendingUpdatesRef = useRef(null); // Store pending pixel updates\r\n  \r\n  const { addToHistory, undo, redo, canUndo, canRedo } = useUndoRedo(Array(8192).fill(false));\r\n\r\n  // Add these new states for brush outline\r\n  const outlineRef = useRef(null);\r\n  const [showOutline, setShowOutline] = useState(false);\r\n\r\n  // Batch update pixels with requestAnimationFrame for better performance\r\n  const batchPixelUpdate = useCallback((updateFn) => {\r\n    if (rafRef.current) return; // Already have a pending update\r\n    \r\n    pendingUpdatesRef.current = updateFn;\r\n    \r\n    rafRef.current = requestAnimationFrame(() => {\r\n      if (pendingUpdatesRef.current) {\r\n        setPixels(prevPixels => pendingUpdatesRef.current(prevPixels));\r\n        pendingUpdatesRef.current = null;\r\n      }\r\n      rafRef.current = null;\r\n    });\r\n  }, []);\r\n\r\n  // Batch update preview pixels with requestAnimationFrame\r\n  const batchPreviewUpdate = useCallback((updateFn) => {\r\n    if (!updateFn) return;\r\n    requestAnimationFrame(() => {\r\n      setPreviewPixels(updateFn);\r\n    });\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    const handleKeyDown = (e) => {\r\n      if (e.code === 'Space' && !isSpacePressed && currentIndexRef.current !== null) {\r\n        e.preventDefault();\r\n        setIsSpacePressed(true);\r\n        handleMouseDown(currentIndexRef.current);\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\r\n        e.preventDefault();\r\n        if (e.shiftKey) {\r\n          // Handle Ctrl+Shift+Z (Windows) or Cmd+Shift+Z (Mac)\r\n          handleRedo();\r\n        } else {\r\n          // Handle Ctrl+Z (Windows) or Cmd+Z (Mac)\r\n          handleUndo();\r\n        }\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\r\n        // Add alternative redo shortcut (Ctrl+Y)\r\n        e.preventDefault();\r\n        handleRedo();\r\n      } else if (e.key === 'b') {\r\n        // Shortcut for brush (freeform)\r\n        e.preventDefault();\r\n        setIsLineModeActive(false);\r\n        setIsCircleModeActive(false);\r\n        setIsBucketFillModeActive(false);\r\n      }\r\n    };\r\n\r\n    const handleKeyUp = (e) => {\r\n      if (e.code === 'Space') {\r\n        e.preventDefault();\r\n        setIsSpacePressed(false);\r\n        // Add state to history when space drawing ends\r\n        if (isDrawingRef.current) {\r\n          addToHistory([...pixels]);\r\n        }\r\n        handleMouseUp();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, [isSpacePressed, pixels, addToHistory]); // Add dependencies\r\n\r\n  // Clean up RAF on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      if (rafRef.current) {\r\n        cancelAnimationFrame(rafRef.current);\r\n        rafRef.current = null;\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  const handlePixelUpdate = useCallback((updateFn) => {\r\n    batchPixelUpdate(updateFn);\r\n  }, [batchPixelUpdate]);\r\n\r\n  const handleUndo = () => {\r\n    const previousState = undo();\r\n    if (previousState) {\r\n      setPixels(previousState);\r\n    }\r\n  };\r\n\r\n  const handleRedo = () => {\r\n    const nextState = redo();\r\n    if (nextState) {\r\n      setPixels(nextState);\r\n    }\r\n  };\r\n\r\n  // Use useMemo to calculate active mode only when dependencies change\r\n  const isFreeformActive = useMemo(() => {\r\n    return !isLineModeActive && !isCircleModeActive && \r\n           !isBucketFillModeActive && !isRectangleModeActive;\r\n  }, [isLineModeActive, isCircleModeActive, isBucketFillModeActive, isRectangleModeActive]);\r\n\r\n  // Use useMemo for these mode objects to avoid re-creating on every render\r\n  const freeformMode = useMemo(() => FreeformMode({\r\n    isActive: isFreeformActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    brushSize,\r\n    drawColor\r\n  }), [isFreeformActive, handlePixelUpdate, brushSize, drawColor]);\r\n\r\n  const lineMode = useMemo(() => LineMode({\r\n    isActive: isLineModeActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    onPreviewUpdate: batchPreviewUpdate,\r\n    drawColor\r\n  }), [isLineModeActive, handlePixelUpdate, batchPreviewUpdate, drawColor]);\r\n\r\n  const circleMode = useMemo(() => CircleMode({\r\n    isActive: isCircleModeActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    onPreviewUpdate: batchPreviewUpdate,\r\n    drawColor\r\n  }), [isCircleModeActive, handlePixelUpdate, batchPreviewUpdate, drawColor]);\r\n\r\n  const bucketFillMode = useMemo(() => BucketFillMode({\r\n    isActive: isBucketFillModeActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    drawColor\r\n  }), [isBucketFillModeActive, handlePixelUpdate, drawColor]);\r\n\r\n  const rectangleMode = useMemo(() => RectangleMode({\r\n    isActive: isRectangleModeActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    onPreviewUpdate: batchPreviewUpdate,\r\n    drawColor\r\n  }), [isRectangleModeActive, handlePixelUpdate, batchPreviewUpdate, drawColor]);\r\n\r\n  const handleMouseDown = useCallback((index) => {\r\n    isDrawingRef.current = true;\r\n    \r\n    if (isBucketFillModeActive) {\r\n      // For bucket fill, execute fill immediately\r\n      bucketFillMode.handleFill(index, pixels);\r\n      addToHistory([...pixels]);\r\n      isDrawingRef.current = false;\r\n      return;\r\n    }\r\n    \r\n    if (isFreeformActive) {\r\n      // For freeform mode, draw immediately on click\r\n      const point = getCoordinates(index);\r\n      lastPointRef.current = point;\r\n      freeformMode.handleStart(index);\r\n    } else {\r\n      startPointRef.current = getCoordinates(index);\r\n      lastPointRef.current = getCoordinates(index);\r\n    }\r\n  }, [pixels, bucketFillMode, isBucketFillModeActive, isFreeformActive, freeformMode, addToHistory]);\r\n\r\n  const handleMouseEnter = useCallback((index) => {\r\n    if (!isDrawingRef.current) return;\r\n    \r\n    if (isFreeformActive) {\r\n      // For freeform mode\r\n      lastPointRef.current = freeformMode.handleDraw(lastPointRef.current, index);\r\n    } else if (isLineModeActive) {\r\n      // For line mode\r\n      lineMode.handlePreview(startPointRef.current, index);\r\n      lastPointRef.current = getCoordinates(index);\r\n    } else if (isCircleModeActive) {\r\n      // For circle mode\r\n      circleMode.handlePreview(startPointRef.current, index);\r\n      lastPointRef.current = getCoordinates(index);\r\n    } else if (isRectangleModeActive) {\r\n      // For rectangle mode\r\n      rectangleMode.handlePreview(startPointRef.current, index);\r\n      lastPointRef.current = getCoordinates(index);\r\n    }\r\n  }, [isFreeformActive, freeformMode, isLineModeActive, lineMode, isCircleModeActive, circleMode, isRectangleModeActive, rectangleMode]);\r\n\r\n  const handleMouseUp = useCallback(() => {\r\n    if (isDrawingRef.current) {\r\n      if ((isLineModeActive || isCircleModeActive || isRectangleModeActive) && \r\n          startPointRef.current && lastPointRef.current) {\r\n        \r\n        const endIndex = lastPointRef.current.y * 128 + lastPointRef.current.x;\r\n        let updatedPixels = [...pixels];\r\n        \r\n        if (isLineModeActive && lineMode.handleCommit) {\r\n          const linePoints = lineMode.handleCommit(startPointRef.current, endIndex);\r\n          if (linePoints) {\r\n            linePoints.forEach(idx => {\r\n              updatedPixels[idx] = drawColor;\r\n            });\r\n          }\r\n        } else if (isCircleModeActive && circleMode.handleCommit) {\r\n          const circlePoints = circleMode.handleCommit(startPointRef.current, endIndex);\r\n          if (circlePoints) {\r\n            circlePoints.forEach(idx => {\r\n              updatedPixels[idx] = drawColor;\r\n            });\r\n          }\r\n        } else if (isRectangleModeActive && rectangleMode.handleCommit) {\r\n          const rectanglePoints = rectangleMode.handleCommit(startPointRef.current, endIndex);\r\n          if (rectanglePoints) {\r\n            rectanglePoints.forEach(idx => {\r\n              updatedPixels[idx] = drawColor;\r\n            });\r\n          }\r\n        }\r\n        \r\n        setPixels(updatedPixels);\r\n        setPreviewPixels(Array(8192).fill(false));\r\n        addToHistory(updatedPixels);\r\n      } else if (!isBucketFillModeActive) {\r\n        // For freeform, only save on mouse up\r\n        addToHistory([...pixels]);\r\n      }\r\n    }\r\n    \r\n    isDrawingRef.current = false;\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n  }, [pixels, isLineModeActive, isCircleModeActive, isRectangleModeActive, isBucketFillModeActive, lineMode, circleMode, rectangleMode, drawColor, addToHistory]);\r\n\r\n  const handleReset = useCallback(() => {\r\n    const newState = Array(8192).fill(false);\r\n    setPixels(newState);\r\n    setPreviewPixels(Array(8192).fill(false));\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n    isDrawingRef.current = false;\r\n    addToHistory(newState);\r\n  }, [addToHistory]);\r\n\r\n  const handlePixelHover = useCallback((index) => {\r\n    currentIndexRef.current = index;\r\n    if (isDrawingRef.current || isSpacePressed) {\r\n      handleMouseEnter(index);\r\n    }\r\n  }, [isSpacePressed, handleMouseEnter]);\r\n\r\n  // Use this cursor style for better performance (avoid style recalculations)\r\n  const cursorStyle = useMemo(() => {\r\n    if (isFreeformActive) return 'none';\r\n    if (isBucketFillModeActive) return 'cell';\r\n    return 'crosshair';\r\n  }, [isFreeformActive, isBucketFillModeActive]);\r\n\r\n  // Add brush outline effect\r\n  useEffect(() => {\r\n    const handleMouseMove = (e) => {\r\n      if (!outlineRef.current) return;\r\n      \r\n      // Only show outline for freeform mode\r\n      if (isFreeformActive) {\r\n        const rect = document.querySelector('.pixel-grid').getBoundingClientRect();\r\n        const mouseX = e.clientX - rect.left;\r\n        const mouseY = e.clientY - rect.top;\r\n        \r\n        // Calculate which pixel we're hovering over\r\n        const pixelX = Math.floor(mouseX / 8);\r\n        const pixelY = Math.floor(mouseY / 8);\r\n        \r\n        // Store the current pixel index for consistent drawing\r\n        const currentIndex = pixelY * 128 + pixelX;\r\n        currentIndexRef.current = currentIndex;\r\n        \r\n        if (brushSize === 1) {\r\n          // For brush size 1, just show a simple pixel outline\r\n          if (pixelX >= 0 && pixelX < 128 && pixelY >= 0 && pixelY < 64) {\r\n            outlineRef.current.innerHTML = '';\r\n            outlineRef.current.style.left = `${pixelX * 8}px`;\r\n            outlineRef.current.style.top = `${pixelY * 8}px`;\r\n            outlineRef.current.style.width = `8px`;\r\n            outlineRef.current.style.height = `8px`;\r\n            outlineRef.current.style.display = 'block';\r\n            outlineRef.current.style.border = `1px solid ${drawColor ? 'white' : 'red'}`;\r\n            outlineRef.current.style.borderRadius = '0'; // Ensure square shape\r\n          }\r\n        } else {\r\n          // Instead of creating a canvas each time, use pre-calculated DOM elements\r\n          // This is much more efficient\r\n          outlineRef.current.style.display = 'block';\r\n          outlineRef.current.innerHTML = '';\r\n          \r\n          const minX = Math.max(0, pixelX - brushSize + 1);\r\n          const minY = Math.max(0, pixelY - brushSize + 1);\r\n          const maxX = Math.min(127, pixelX + brushSize - 1);\r\n          const maxY = Math.min(63, pixelY + brushSize - 1);\r\n          \r\n          outlineRef.current.style.left = `${minX * 8}px`;\r\n          outlineRef.current.style.top = `${minY * 8}px`;\r\n          outlineRef.current.style.width = `${(maxX - minX + 1) * 8}px`;\r\n          outlineRef.current.style.height = `${(maxY - minY + 1) * 8}px`;\r\n          outlineRef.current.style.border = `1px solid ${drawColor ? 'white' : 'red'}`;\r\n        }\r\n      } else {\r\n        outlineRef.current.style.display = 'none';\r\n      }\r\n    };\r\n    \r\n    const grid = document.querySelector('.pixel-grid');\r\n    if (grid) {\r\n      grid.addEventListener('mousemove', handleMouseMove, { passive: true });\r\n    }\r\n    \r\n    return () => {\r\n      if (grid) {\r\n        grid.removeEventListener('mousemove', handleMouseMove);\r\n      }\r\n    };\r\n  }, [brushSize, isFreeformActive, drawColor]);\r\n\r\n  // Use a more efficient approach to render pixels\r\n  // Create chunks of pixels to reduce the number of individual components\r\n  const pixelChunks = useMemo(() => {\r\n    const chunks = [];\r\n    // Generate chunks - each chunk contains 100 pixels\r\n    const chunkSize = 800;\r\n    for (let i = 0; i < pixels.length; i += chunkSize) {\r\n      chunks.push(pixels.slice(i, i + chunkSize));\r\n    }\r\n    return chunks;\r\n  }, [pixels]);\r\n\r\n  // Centralize the click handler to avoid recreating it for every pixel\r\n  const handlePixelClick = useCallback((event) => {\r\n    event.preventDefault();\r\n    \r\n    if (!currentIndexRef.current && currentIndexRef.current !== 0) return;\r\n    \r\n    handleMouseDown(currentIndexRef.current);\r\n  }, [handleMouseDown]);\r\n\r\n  // Fix - Check if the grid is rendered\r\n  useEffect(() => {\r\n    console.log(\"Grid should contain:\", pixels.length, \"pixels\");\r\n    const grid = document.querySelector('.pixel-grid');\r\n    console.log(\"Grid element exists:\", !!grid);\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"pixel-grid-container\">\r\n      {/* ESP32 Button - fixed to top left */}\r\n      <div className=\"esp32-container\" style={{ \r\n        position: 'fixed', \r\n        top: '10px', \r\n        left: '10px', \r\n        zIndex: 1000 \r\n      }}>\r\n        <ESP32Connection pixelData={pixels} />\r\n      </div>\r\n      \r\n      {/* BMP Buttons - fixed to top right */}\r\n      <div className=\"bmp-container\" style={{ \r\n        position: 'fixed', \r\n        top: '10px', \r\n        right: '10px', \r\n        zIndex: 1000 \r\n      }}>\r\n        <BMPHandler pixelData={pixels} onPixelUpdate={setPixels} />\r\n      </div>\r\n\r\n      {/* Only show brush size control when in freeform mode */}\r\n      {isFreeformActive && (\r\n        <div className=\"brush-size-control\">\r\n          <label htmlFor=\"brushSize\" style={{ color: 'white', minWidth: '100px' }}>\r\n            Brush Size: {brushSize}\r\n          </label>\r\n          <input\r\n            type=\"range\"\r\n            id=\"brushSize\"\r\n            className=\"brush-size-slider\"\r\n            min=\"1\"\r\n            max=\"5\"\r\n            value={brushSize}\r\n            onChange={(e) => setBrushSize(Number(e.target.value))}\r\n          />\r\n        </div>\r\n      )}\r\n      \r\n      <div className=\"mode-buttons-container\">\r\n        <button \r\n          onClick={() => {\r\n            setIsLineModeActive(false);\r\n            setIsCircleModeActive(false);\r\n            setIsBucketFillModeActive(false);\r\n            setIsRectangleModeActive(false);\r\n            setPreviewPixels(Array(8192).fill(false));\r\n          }}\r\n          className={`mode-button ${isFreeformActive ? 'active' : ''}`}\r\n        >\r\n          {freeformMode.modeName}\r\n        </button>\r\n        <button \r\n          onClick={() => {\r\n            setIsLineModeActive(true);\r\n            setIsCircleModeActive(false);\r\n            setIsBucketFillModeActive(false);\r\n            setIsRectangleModeActive(false);\r\n          }}\r\n          className={`mode-button ${isLineModeActive ? 'active' : ''}`}\r\n        >\r\n          {lineMode.modeName}\r\n        </button>\r\n        <button \r\n          onClick={() => {\r\n            setIsLineModeActive(false);\r\n            setIsCircleModeActive(true);\r\n            setIsBucketFillModeActive(false);\r\n            setIsRectangleModeActive(false);\r\n          }}\r\n          className={`mode-button ${isCircleModeActive ? 'active' : ''}`}\r\n        >\r\n          {circleMode.modeName}\r\n        </button>\r\n        <button \r\n          onClick={() => {\r\n            setIsLineModeActive(false);\r\n            setIsCircleModeActive(false);\r\n            setIsBucketFillModeActive(false);\r\n            setIsRectangleModeActive(true);\r\n          }}\r\n          className={`mode-button ${isRectangleModeActive ? 'active' : ''}`}\r\n        >\r\n          {rectangleMode.modeName}\r\n        </button>\r\n        <button \r\n          onClick={() => {\r\n            setIsLineModeActive(false);\r\n            setIsCircleModeActive(false);\r\n            setIsBucketFillModeActive(true);\r\n            setIsRectangleModeActive(false);\r\n          }}\r\n          className={`mode-button ${isBucketFillModeActive ? 'active' : ''}`}\r\n        >\r\n          {bucketFillMode.modeName}\r\n        </button>\r\n        <button \r\n          onClick={handleUndo}\r\n          className=\"mode-button\"\r\n          disabled={!canUndo}\r\n          style={{ marginLeft: 'auto' }}\r\n        >\r\n          Undo\r\n        </button>\r\n        <button \r\n          onClick={handleRedo}\r\n          className=\"mode-button\"\r\n          disabled={!canRedo}\r\n        >\r\n          Redo\r\n        </button>\r\n      </div>\r\n      \r\n      <div style={{ position: 'relative', width: '1024px', height: '512px' }}> {/* Fixed size container */}\r\n        {/* Color selection squares */}\r\n        <div style={{\r\n          position: 'absolute',\r\n          left: '-34px',\r\n          top: 0,\r\n          display: 'flex',\r\n          flexDirection: 'column',\r\n          alignItems: 'center',\r\n          height: '100%',\r\n          justifyContent: 'center',\r\n          zIndex: 1\r\n        }}>\r\n          <div \r\n            onClick={() => setDrawColor(true)}\r\n            style={{\r\n              width: '24px',\r\n              height: '24px',\r\n              backgroundColor: '#fff',\r\n              border: drawColor ? '2px solid #2196F3' : '1px solid #666',\r\n              marginBottom: '10px',\r\n              cursor: 'pointer',\r\n              boxSizing: 'border-box'\r\n            }}\r\n            title=\"White (Draw)\"\r\n          />\r\n          <div \r\n            onClick={() => setDrawColor(false)}\r\n            style={{\r\n              width: '24px',\r\n              height: '24px',\r\n              backgroundColor: '#000',\r\n              border: !drawColor ? '2px solid red' : '1px solid #666',\r\n              cursor: 'pointer',\r\n              boxSizing: 'border-box'\r\n            }}\r\n            title=\"Black (Eraser)\"\r\n          />\r\n        </div>\r\n        \r\n        {/* Performance optimized pixel grid */}\r\n        <div \r\n          className=\"pixel-grid\"\r\n          onMouseDown={handlePixelClick}\r\n          onMouseUp={handleMouseUp}\r\n          onMouseLeave={handleMouseUp}\r\n          style={{ \r\n            display: 'grid', \r\n            gridTemplateColumns: 'repeat(128, 8px)', \r\n            gridTemplateRows: 'repeat(64, 8px)',\r\n            width: '1024px',\r\n            height: '512px'\r\n          }}\r\n        >\r\n          {/* Brush outline */}\r\n          <div \r\n            className=\"brush-outline\" \r\n            ref={outlineRef}\r\n            style={{ \r\n              borderColor: drawColor ? 'white' : 'red'\r\n            }}\r\n          ></div>\r\n          \r\n          {/* Ensure all pixels are rendered */}\r\n          {pixels.map((isWhite, index) => {\r\n            const previewState = previewPixels[index];\r\n            return (\r\n              <Pixel\r\n                key={index}\r\n                index={index}\r\n                isWhite={isWhite}\r\n                previewState={previewState}\r\n                onMouseDown={handleMouseDown}\r\n                onMouseEnter={handlePixelHover}\r\n                cursorStyle={cursorStyle}\r\n              />\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n      <ResetButton onReset={handleReset} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PixelGrid;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}