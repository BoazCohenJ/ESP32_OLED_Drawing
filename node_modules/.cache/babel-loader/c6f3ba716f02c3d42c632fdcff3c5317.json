{"ast":null,"code":"import React from 'react';\nconst getCoordinates = index => ({\n  x: index % 128,\n  y: Math.floor(index / 128)\n});\nconst getIndex = (x, y) => y * 128 + x;\nconst bucketFill = (startIndex, pixels) => {\n  const targetColor = pixels[startIndex]; // Color we're replacing\n\n  // If target is already filled (white), don't do anything\n  if (targetColor === true) return [];\n  const width = 128;\n  const height = 64;\n  const stack = [startIndex];\n  const filledPoints = [];\n  const visited = new Set();\n  while (stack.length > 0) {\n    const currentIndex = stack.pop();\n    if (visited.has(currentIndex)) continue;\n    visited.add(currentIndex);\n\n    // If this pixel doesn't match the target color, skip it\n    if (pixels[currentIndex] !== targetColor) continue;\n    filledPoints.push(currentIndex);\n    const {\n      x,\n      y\n    } = getCoordinates(currentIndex);\n\n    // Check 4 neighboring pixels (up, right, down, left)\n    const neighbors = [{\n      dx: 0,\n      dy: -1\n    },\n    // up\n    {\n      dx: 1,\n      dy: 0\n    },\n    // right\n    {\n      dx: 0,\n      dy: 1\n    },\n    // down\n    {\n      dx: -1,\n      dy: 0\n    } // left\n    ];\n    for (const {\n      dx,\n      dy\n    } of neighbors) {\n      const newX = x + dx;\n      const newY = y + dy;\n\n      // Check if the new coordinates are within the grid bounds\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n        const neighborIndex = getIndex(newX, newY);\n        if (!visited.has(neighborIndex) && pixels[neighborIndex] === targetColor) {\n          stack.push(neighborIndex);\n        }\n      }\n    }\n  }\n  return filledPoints;\n};\n\n// New function to create outlines\nconst outlineFill = (startIndex, pixels) => {\n  // Only works on white areas\n  if (pixels[startIndex] !== true) return [];\n  const width = 128;\n  const height = 64;\n\n  // First, do a regular fill to find all connected white pixels\n  const stack = [startIndex];\n  const filledPoints = [];\n  const edgePoints = new Set();\n  const visited = new Set();\n  while (stack.length > 0) {\n    const currentIndex = stack.pop();\n    if (visited.has(currentIndex)) continue;\n    visited.add(currentIndex);\n\n    // If this pixel doesn't match the target color (white), skip it\n    if (pixels[currentIndex] !== true) continue;\n    filledPoints.push(currentIndex);\n    const {\n      x,\n      y\n    } = getCoordinates(currentIndex);\n\n    // Check 4 neighboring pixels (up, right, down, left)\n    const neighbors = [{\n      dx: 0,\n      dy: -1\n    },\n    // up\n    {\n      dx: 1,\n      dy: 0\n    },\n    // right\n    {\n      dx: 0,\n      dy: 1\n    },\n    // down\n    {\n      dx: -1,\n      dy: 0\n    } // left\n    ];\n    let isEdge = false;\n    for (const {\n      dx,\n      dy\n    } of neighbors) {\n      const newX = x + dx;\n      const newY = y + dy;\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\n        const neighborIndex = getIndex(newX, newY);\n        if (pixels[neighborIndex] === true) {\n          // If neighbor is white\n          if (!visited.has(neighborIndex)) {\n            stack.push(neighborIndex);\n          }\n        } else {\n          // Found a black neighbor, so this pixel is an edge\n          isEdge = true;\n        }\n      } else {\n        // Edge of canvas - count as an edge pixel\n        isEdge = true;\n      }\n    }\n\n    // If this is an edge pixel, mark it\n    if (isEdge) {\n      edgePoints.add(currentIndex);\n    }\n  }\n\n  // Return non-edge white pixels (to be turned black)\n  return filledPoints.filter(idx => !edgePoints.has(idx));\n};\nconst BucketFillMode = ({\n  isActive,\n  onPixelUpdate,\n  drawColor = true\n}) => {\n  const handleFill = (index, pixels) => {\n    if (!isActive) return;\n    let pointsToModify;\n\n    // Check if we're doing the special outline fill\n    if (!drawColor && pixels[index] === true) {\n      // Black bucket on white area - create outline\n      pointsToModify = outlineFill(index, pixels);\n    } else {\n      // Regular bucket fill\n      pointsToModify = bucketFill(index, pixels);\n    }\n    if (pointsToModify.length > 0) {\n      onPixelUpdate(prev => {\n        const newPixels = [...prev];\n        pointsToModify.forEach(idx => {\n          newPixels[idx] = drawColor; // Set to white or black based on drawColor\n        });\n        return newPixels;\n      });\n      return pointsToModify;\n    }\n    return [];\n  };\n  return {\n    handleFill,\n    modeName: 'Bucket Fill',\n    isActive\n  };\n};\n_c = BucketFillMode;\nexport default BucketFillMode;\nvar _c;\n$RefreshReg$(_c, \"BucketFillMode\");","map":{"version":3,"names":["React","getCoordinates","index","x","y","Math","floor","getIndex","bucketFill","startIndex","pixels","targetColor","width","height","stack","filledPoints","visited","Set","length","currentIndex","pop","has","add","push","neighbors","dx","dy","newX","newY","neighborIndex","outlineFill","edgePoints","isEdge","filter","idx","BucketFillMode","isActive","onPixelUpdate","drawColor","handleFill","pointsToModify","prev","newPixels","forEach","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/BucketFillMode.jsx"],"sourcesContent":["import React from 'react';\r\n\r\nconst getCoordinates = (index) => ({\r\n  x: index % 128,\r\n  y: Math.floor(index / 128)\r\n});\r\n\r\nconst getIndex = (x, y) => y * 128 + x;\r\n\r\nconst bucketFill = (startIndex, pixels) => {\r\n  const targetColor = pixels[startIndex]; // Color we're replacing\r\n  \r\n  // If target is already filled (white), don't do anything\r\n  if (targetColor === true) return [];\r\n  \r\n  const width = 128;\r\n  const height = 64;\r\n  const stack = [startIndex];\r\n  const filledPoints = [];\r\n  const visited = new Set();\r\n  \r\n  while (stack.length > 0) {\r\n    const currentIndex = stack.pop();\r\n    \r\n    if (visited.has(currentIndex)) continue;\r\n    visited.add(currentIndex);\r\n    \r\n    // If this pixel doesn't match the target color, skip it\r\n    if (pixels[currentIndex] !== targetColor) continue;\r\n    \r\n    filledPoints.push(currentIndex);\r\n    \r\n    const { x, y } = getCoordinates(currentIndex);\r\n    \r\n    // Check 4 neighboring pixels (up, right, down, left)\r\n    const neighbors = [\r\n      { dx: 0, dy: -1 }, // up\r\n      { dx: 1, dy: 0 },  // right\r\n      { dx: 0, dy: 1 },  // down\r\n      { dx: -1, dy: 0 }  // left\r\n    ];\r\n    \r\n    for (const { dx, dy } of neighbors) {\r\n      const newX = x + dx;\r\n      const newY = y + dy;\r\n      \r\n      // Check if the new coordinates are within the grid bounds\r\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\r\n        const neighborIndex = getIndex(newX, newY);\r\n        if (!visited.has(neighborIndex) && pixels[neighborIndex] === targetColor) {\r\n          stack.push(neighborIndex);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  return filledPoints;\r\n};\r\n\r\n// New function to create outlines\r\nconst outlineFill = (startIndex, pixels) => {\r\n  // Only works on white areas\r\n  if (pixels[startIndex] !== true) return [];\r\n  \r\n  const width = 128;\r\n  const height = 64;\r\n  \r\n  // First, do a regular fill to find all connected white pixels\r\n  const stack = [startIndex];\r\n  const filledPoints = [];\r\n  const edgePoints = new Set();\r\n  const visited = new Set();\r\n  \r\n  while (stack.length > 0) {\r\n    const currentIndex = stack.pop();\r\n    \r\n    if (visited.has(currentIndex)) continue;\r\n    visited.add(currentIndex);\r\n    \r\n    // If this pixel doesn't match the target color (white), skip it\r\n    if (pixels[currentIndex] !== true) continue;\r\n    \r\n    filledPoints.push(currentIndex);\r\n    \r\n    const { x, y } = getCoordinates(currentIndex);\r\n    \r\n    // Check 4 neighboring pixels (up, right, down, left)\r\n    const neighbors = [\r\n      { dx: 0, dy: -1 }, // up\r\n      { dx: 1, dy: 0 },  // right\r\n      { dx: 0, dy: 1 },  // down\r\n      { dx: -1, dy: 0 }  // left\r\n    ];\r\n    \r\n    let isEdge = false;\r\n    \r\n    for (const { dx, dy } of neighbors) {\r\n      const newX = x + dx;\r\n      const newY = y + dy;\r\n      \r\n      if (newX >= 0 && newX < width && newY >= 0 && newY < height) {\r\n        const neighborIndex = getIndex(newX, newY);\r\n        if (pixels[neighborIndex] === true) { // If neighbor is white\r\n          if (!visited.has(neighborIndex)) {\r\n            stack.push(neighborIndex);\r\n          }\r\n        } else {\r\n          // Found a black neighbor, so this pixel is an edge\r\n          isEdge = true;\r\n        }\r\n      } else {\r\n        // Edge of canvas - count as an edge pixel\r\n        isEdge = true;\r\n      }\r\n    }\r\n    \r\n    // If this is an edge pixel, mark it\r\n    if (isEdge) {\r\n      edgePoints.add(currentIndex);\r\n    }\r\n  }\r\n  \r\n  // Return non-edge white pixels (to be turned black)\r\n  return filledPoints.filter(idx => !edgePoints.has(idx));\r\n};\r\n\r\nconst BucketFillMode = ({ isActive, onPixelUpdate, drawColor = true }) => {\r\n  const handleFill = (index, pixels) => {\r\n    if (!isActive) return;\r\n    \r\n    let pointsToModify;\r\n    \r\n    // Check if we're doing the special outline fill\r\n    if (!drawColor && pixels[index] === true) {\r\n      // Black bucket on white area - create outline\r\n      pointsToModify = outlineFill(index, pixels);\r\n    } else {\r\n      // Regular bucket fill\r\n      pointsToModify = bucketFill(index, pixels);\r\n    }\r\n    \r\n    if (pointsToModify.length > 0) {\r\n      onPixelUpdate(prev => {\r\n        const newPixels = [...prev];\r\n        pointsToModify.forEach(idx => {\r\n          newPixels[idx] = drawColor;  // Set to white or black based on drawColor\r\n        });\r\n        return newPixels;\r\n      });\r\n      \r\n      return pointsToModify;\r\n    }\r\n    \r\n    return [];\r\n  };\r\n\r\n  return {\r\n    handleFill,\r\n    modeName: 'Bucket Fill',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default BucketFillMode;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}