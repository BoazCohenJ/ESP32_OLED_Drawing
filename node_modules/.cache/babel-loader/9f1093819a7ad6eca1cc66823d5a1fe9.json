{"ast":null,"code":"import React from 'react';\nimport { getIndex, drawLine as utilsDrawLine } from './utils';\nconst EraserMode = ({\n  isActive,\n  onPixelUpdate,\n  brushSize = 1\n}) => {\n  const getPointsForBrush = centerIndex => {\n    const centerX = centerIndex % 128;\n    const centerY = Math.floor(centerIndex / 128);\n    const points = [];\n\n    // For a single pixel\n    if (brushSize === 1) {\n      points.push(centerIndex);\n      return points;\n    }\n\n    // For larger brush sizes, use a diamond pattern\n    for (let y = -brushSize + 1; y < brushSize; y++) {\n      for (let x = -brushSize + 1; x < brushSize; x++) {\n        // Use Manhattan distance for diamond shape\n        if (Math.abs(x) + Math.abs(y) < brushSize) {\n          const newX = centerX + x;\n          const newY = centerY + y;\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\n            const index = getIndex(newX, newY);\n            points.push(index);\n          }\n        }\n      }\n    }\n    return points;\n  };\n\n  // Apply erase at a specific point\n  const eraseAtPoint = index => {\n    if (!isActive) return;\n    const pointsToErase = getPointsForBrush(index);\n    onPixelUpdate(prevPixels => {\n      const newPixels = [...prevPixels];\n      pointsToErase.forEach(idx => {\n        newPixels[idx] = false; // Set to false to erase\n      });\n      return newPixels;\n    });\n    return pointsToErase;\n  };\n\n  // Modified drawLine to ensure a continuous eraser stroke\n  const drawLine = (start, end) => {\n    if (!isActive) return start;\n\n    // Get coordinates\n    const startX = start.x;\n    const startY = start.y;\n    const endX = end.x;\n    const endY = end.y;\n\n    // Use the line drawing algorithm from utils to get all points along the line\n    const linePoints = utilsDrawLine(start, end);\n\n    // Apply eraser at each point along the line\n    linePoints.forEach(index => {\n      eraseAtPoint(index);\n    });\n    return {\n      x: endX,\n      y: endY\n    };\n  };\n  const handleStart = index => {\n    if (!isActive) return;\n    eraseAtPoint(index);\n  };\n  const handleDraw = (startPoint, endIndex) => {\n    if (!isActive || !startPoint) return startPoint;\n    const endX = endIndex % 128;\n    const endY = Math.floor(endIndex / 128);\n    const endPoint = {\n      x: endX,\n      y: endY\n    };\n    return drawLine(startPoint, endPoint);\n  };\n  return {\n    handleStart,\n    handleDraw,\n    modeName: 'Eraser',\n    isActive\n  };\n};\n_c = EraserMode;\nexport default EraserMode;\nvar _c;\n$RefreshReg$(_c, \"EraserMode\");","map":{"version":3,"names":["React","getIndex","drawLine","utilsDrawLine","EraserMode","isActive","onPixelUpdate","brushSize","getPointsForBrush","centerIndex","centerX","centerY","Math","floor","points","push","y","x","abs","newX","newY","index","eraseAtPoint","pointsToErase","prevPixels","newPixels","forEach","idx","start","end","startX","startY","endX","endY","linePoints","handleStart","handleDraw","startPoint","endIndex","endPoint","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/AOD/src/components/pixelGrid/EraserMode.jsx"],"sourcesContent":["import React from 'react';\r\nimport { getIndex, drawLine as utilsDrawLine } from './utils';\r\n\r\nconst EraserMode = ({ isActive, onPixelUpdate, brushSize = 1 }) => {\r\n  const getPointsForBrush = (centerIndex) => {\r\n    const centerX = centerIndex % 128;\r\n    const centerY = Math.floor(centerIndex / 128);\r\n    const points = [];\r\n\r\n    // For a single pixel\r\n    if (brushSize === 1) {\r\n      points.push(centerIndex);\r\n      return points;\r\n    }\r\n\r\n    // For larger brush sizes, use a diamond pattern\r\n    for (let y = -brushSize + 1; y < brushSize; y++) {\r\n      for (let x = -brushSize + 1; x < brushSize; x++) {\r\n        // Use Manhattan distance for diamond shape\r\n        if (Math.abs(x) + Math.abs(y) < brushSize) {\r\n          const newX = centerX + x;\r\n          const newY = centerY + y;\r\n          \r\n          if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\r\n            const index = getIndex(newX, newY);\r\n            points.push(index);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return points;\r\n  };\r\n  \r\n  // Apply erase at a specific point\r\n  const eraseAtPoint = (index) => {\r\n    if (!isActive) return;\r\n    const pointsToErase = getPointsForBrush(index);\r\n    onPixelUpdate(prevPixels => {\r\n      const newPixels = [...prevPixels];\r\n      pointsToErase.forEach(idx => {\r\n        newPixels[idx] = false; // Set to false to erase\r\n      });\r\n      return newPixels;\r\n    });\r\n    return pointsToErase;\r\n  };\r\n\r\n  // Modified drawLine to ensure a continuous eraser stroke\r\n  const drawLine = (start, end) => {\r\n    if (!isActive) return start;\r\n    \r\n    // Get coordinates\r\n    const startX = start.x;\r\n    const startY = start.y;\r\n    const endX = end.x;\r\n    const endY = end.y;\r\n    \r\n    // Use the line drawing algorithm from utils to get all points along the line\r\n    const linePoints = utilsDrawLine(start, end);\r\n    \r\n    // Apply eraser at each point along the line\r\n    linePoints.forEach(index => {\r\n      eraseAtPoint(index);\r\n    });\r\n    \r\n    return { x: endX, y: endY };\r\n  };\r\n\r\n  const handleStart = (index) => {\r\n    if (!isActive) return;\r\n    eraseAtPoint(index);\r\n  };\r\n\r\n  const handleDraw = (startPoint, endIndex) => {\r\n    if (!isActive || !startPoint) return startPoint;\r\n    \r\n    const endX = endIndex % 128;\r\n    const endY = Math.floor(endIndex / 128);\r\n    const endPoint = { x: endX, y: endY };\r\n    \r\n    return drawLine(startPoint, endPoint);\r\n  };\r\n\r\n  return {\r\n    handleStart,\r\n    handleDraw,\r\n    modeName: 'Eraser',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default EraserMode;"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,QAAQ,EAAEC,QAAQ,IAAIC,aAAa,QAAQ,SAAS;AAE7D,MAAMC,UAAU,GAAGA,CAAC;EAAEC,QAAQ;EAAEC,aAAa;EAAEC,SAAS,GAAG;AAAE,CAAC,KAAK;EACjE,MAAMC,iBAAiB,GAAIC,WAAW,IAAK;IACzC,MAAMC,OAAO,GAAGD,WAAW,GAAG,GAAG;IACjC,MAAME,OAAO,GAAGC,IAAI,CAACC,KAAK,CAACJ,WAAW,GAAG,GAAG,CAAC;IAC7C,MAAMK,MAAM,GAAG,EAAE;;IAEjB;IACA,IAAIP,SAAS,KAAK,CAAC,EAAE;MACnBO,MAAM,CAACC,IAAI,CAACN,WAAW,CAAC;MACxB,OAAOK,MAAM;IACf;;IAEA;IACA,KAAK,IAAIE,CAAC,GAAG,CAACT,SAAS,GAAG,CAAC,EAAES,CAAC,GAAGT,SAAS,EAAES,CAAC,EAAE,EAAE;MAC/C,KAAK,IAAIC,CAAC,GAAG,CAACV,SAAS,GAAG,CAAC,EAAEU,CAAC,GAAGV,SAAS,EAAEU,CAAC,EAAE,EAAE;QAC/C;QACA,IAAIL,IAAI,CAACM,GAAG,CAACD,CAAC,CAAC,GAAGL,IAAI,CAACM,GAAG,CAACF,CAAC,CAAC,GAAGT,SAAS,EAAE;UACzC,MAAMY,IAAI,GAAGT,OAAO,GAAGO,CAAC;UACxB,MAAMG,IAAI,GAAGT,OAAO,GAAGK,CAAC;UAExB,IAAIG,IAAI,IAAI,CAAC,IAAIA,IAAI,GAAG,GAAG,IAAIC,IAAI,IAAI,CAAC,IAAIA,IAAI,GAAG,EAAE,EAAE;YACrD,MAAMC,KAAK,GAAGpB,QAAQ,CAACkB,IAAI,EAAEC,IAAI,CAAC;YAClCN,MAAM,CAACC,IAAI,CAACM,KAAK,CAAC;UACpB;QACF;MACF;IACF;IAEA,OAAOP,MAAM;EACf,CAAC;;EAED;EACA,MAAMQ,YAAY,GAAID,KAAK,IAAK;IAC9B,IAAI,CAAChB,QAAQ,EAAE;IACf,MAAMkB,aAAa,GAAGf,iBAAiB,CAACa,KAAK,CAAC;IAC9Cf,aAAa,CAACkB,UAAU,IAAI;MAC1B,MAAMC,SAAS,GAAG,CAAC,GAAGD,UAAU,CAAC;MACjCD,aAAa,CAACG,OAAO,CAACC,GAAG,IAAI;QAC3BF,SAAS,CAACE,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC;MAC1B,CAAC,CAAC;MACF,OAAOF,SAAS;IAClB,CAAC,CAAC;IACF,OAAOF,aAAa;EACtB,CAAC;;EAED;EACA,MAAMrB,QAAQ,GAAGA,CAAC0B,KAAK,EAAEC,GAAG,KAAK;IAC/B,IAAI,CAACxB,QAAQ,EAAE,OAAOuB,KAAK;;IAE3B;IACA,MAAME,MAAM,GAAGF,KAAK,CAACX,CAAC;IACtB,MAAMc,MAAM,GAAGH,KAAK,CAACZ,CAAC;IACtB,MAAMgB,IAAI,GAAGH,GAAG,CAACZ,CAAC;IAClB,MAAMgB,IAAI,GAAGJ,GAAG,CAACb,CAAC;;IAElB;IACA,MAAMkB,UAAU,GAAG/B,aAAa,CAACyB,KAAK,EAAEC,GAAG,CAAC;;IAE5C;IACAK,UAAU,CAACR,OAAO,CAACL,KAAK,IAAI;MAC1BC,YAAY,CAACD,KAAK,CAAC;IACrB,CAAC,CAAC;IAEF,OAAO;MAAEJ,CAAC,EAAEe,IAAI;MAAEhB,CAAC,EAAEiB;IAAK,CAAC;EAC7B,CAAC;EAED,MAAME,WAAW,GAAId,KAAK,IAAK;IAC7B,IAAI,CAAChB,QAAQ,EAAE;IACfiB,YAAY,CAACD,KAAK,CAAC;EACrB,CAAC;EAED,MAAMe,UAAU,GAAGA,CAACC,UAAU,EAAEC,QAAQ,KAAK;IAC3C,IAAI,CAACjC,QAAQ,IAAI,CAACgC,UAAU,EAAE,OAAOA,UAAU;IAE/C,MAAML,IAAI,GAAGM,QAAQ,GAAG,GAAG;IAC3B,MAAML,IAAI,GAAGrB,IAAI,CAACC,KAAK,CAACyB,QAAQ,GAAG,GAAG,CAAC;IACvC,MAAMC,QAAQ,GAAG;MAAEtB,CAAC,EAAEe,IAAI;MAAEhB,CAAC,EAAEiB;IAAK,CAAC;IAErC,OAAO/B,QAAQ,CAACmC,UAAU,EAAEE,QAAQ,CAAC;EACvC,CAAC;EAED,OAAO;IACLJ,WAAW;IACXC,UAAU;IACVI,QAAQ,EAAE,QAAQ;IAClBnC;EACF,CAAC;AACH,CAAC;AAACoC,EAAA,GAvFIrC,UAAU;AAyFhB,eAAeA,UAAU;AAAC,IAAAqC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module"}