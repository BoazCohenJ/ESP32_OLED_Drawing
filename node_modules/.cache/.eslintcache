[{"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\LineMode.jsx":"1","C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\ResetButton.jsx":"2","C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\FreeFormMode.jsx":"3","C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\CircleMode.jsx":"4","C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\useUndoRedo.jsx":"5","C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\BucketFillMode.jsx":"6","C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\RectangleMode.jsx":"7","C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\BMPHandler.jsx":"8","C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\ESP32Connection.jsx":"9","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\index.jsx":"10","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\App.jsx":"11","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\index.jsx":"12","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\utils.js":"13","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\LineMode.jsx":"14","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\CircleMode.jsx":"15","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\FreeFormMode.jsx":"16","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\useUndoRedo.jsx":"17","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\ResetButton.jsx":"18","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\RectangleMode.jsx":"19","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\BucketFillMode.jsx":"20","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\ESP32Connection.jsx":"21","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\BMPHandler.jsx":"22"},{"size":2319,"mtime":1748164041385,"results":"23","hashOfConfig":"24"},{"size":1102,"mtime":1748164007844,"results":"25","hashOfConfig":"24"},{"size":2892,"mtime":1748164059215,"results":"26","hashOfConfig":"24"},{"size":2419,"mtime":1748164074112,"results":"27","hashOfConfig":"24"},{"size":1073,"mtime":1748164199764,"results":"28","hashOfConfig":"24"},{"size":3217,"mtime":1748164197054,"results":"29","hashOfConfig":"24"},{"size":2657,"mtime":1748164026986,"results":"30","hashOfConfig":"24"},{"size":4319,"mtime":1748164143556,"results":"31","hashOfConfig":"24"},{"size":6396,"mtime":1748164111550,"results":"32","hashOfConfig":"24"},{"size":237,"mtime":1748162141852,"results":"33","hashOfConfig":"34"},{"size":323,"mtime":1748160810815,"results":"35","hashOfConfig":"34"},{"size":22587,"mtime":1748163796668,"results":"36","hashOfConfig":"34"},{"size":722,"mtime":1748162141872,"results":"37","hashOfConfig":"34"},{"size":2319,"mtime":1748164041385,"results":"38","hashOfConfig":"34"},{"size":2419,"mtime":1748164074112,"results":"39","hashOfConfig":"34"},{"size":2892,"mtime":1748164059215,"results":"40","hashOfConfig":"34"},{"size":1073,"mtime":1748164199764,"results":"41","hashOfConfig":"34"},{"size":1102,"mtime":1748164007844,"results":"42","hashOfConfig":"34"},{"size":2657,"mtime":1748164026986,"results":"43","hashOfConfig":"34"},{"size":3217,"mtime":1748164197054,"results":"44","hashOfConfig":"34"},{"size":6396,"mtime":1748164111550,"results":"45","hashOfConfig":"34"},{"size":4319,"mtime":1748164143556,"results":"46","hashOfConfig":"34"},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},"1tmx1ar",{"filePath":"49","messages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"51","messages":"52","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"53","messages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"55","messages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"57","messages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"59","messages":"60","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"61","messages":"62","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"63","messages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"65","messages":"66","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"j6pyvg",{"filePath":"67","messages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"71"},{"filePath":"72","messages":"73","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"74","messages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76"},{"filePath":"77","messages":"78","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"79"},{"filePath":"80","messages":"81","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"82"},{"filePath":"83","messages":"84","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"85","messages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"87","messages":"88","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"89"},{"filePath":"90","messages":"91","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"92"},{"filePath":"93","messages":"94","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"95"},{"filePath":"96","messages":"97","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\LineMode.jsx",["98"],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\ResetButton.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\FreeFormMode.jsx",["99"],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\CircleMode.jsx",["100"],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\useUndoRedo.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\BucketFillMode.jsx",["101"],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\pixelGrid\\RectangleMode.jsx",["102"],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\BMPHandler.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\AOD\\src\\components\\ESP32Connection.jsx",["103"],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\index.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\App.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\index.jsx",["104","105","106","107","108"],"import React, { useState, useRef, useEffect } from 'react';\r\nimport FreeformMode from './FreeFormMode';\r\nimport LineMode from './LineMode';\r\nimport ResetButton from './ResetButton';\r\nimport { getCoordinates } from './utils';\r\nimport CircleMode from './CircleMode';\r\nimport BucketFillMode from './BucketFillMode';\r\nimport { useUndoRedo } from './useUndoRedo';\r\nimport RectangleMode from './RectangleMode';\r\nimport ESP32Connection from '../ESP32Connection';\r\nimport BMPHandler from '../BMPHandler';\r\n\r\nconst PixelGrid = () => {\r\n  const [pixels, setPixels] = useState(Array(8192).fill(false));\r\n  const [isLineModeActive, setIsLineModeActive] = useState(false);\r\n  const [isCircleModeActive, setIsCircleModeActive] = useState(false);\r\n  const [isBucketFillModeActive, setIsBucketFillModeActive] = useState(false);\r\n  const [isRectangleModeActive, setIsRectangleModeActive] = useState(false);\r\n  const [previewPixels, setPreviewPixels] = useState(Array(8192).fill(false));\r\n  const isDrawingRef = useRef(false);\r\n  const startPointRef = useRef(null);\r\n  const lastPointRef = useRef(null);\r\n  const [isSpacePressed, setIsSpacePressed] = useState(false);\r\n  const currentIndexRef = useRef(null);\r\n  const [brushSize, setBrushSize] = useState(1);\r\n  const [drawColor, setDrawColor] = useState(true); // true for white, false for black\r\n  \r\n  const { addToHistory, undo, redo, canUndo, canRedo } = useUndoRedo(Array(8192).fill(false));\r\n\r\n  // Add these new states for brush outline\r\n  const outlineRef = useRef(null);\r\n  const [showOutline, setShowOutline] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const handleKeyDown = (e) => {\r\n      if (e.code === 'Space' && !isSpacePressed && currentIndexRef.current !== null) {\r\n        e.preventDefault();\r\n        setIsSpacePressed(true);\r\n        handleMouseDown(currentIndexRef.current);\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\r\n        e.preventDefault();\r\n        if (e.shiftKey) {\r\n          // Handle Ctrl+Shift+Z (Windows) or Cmd+Shift+Z (Mac)\r\n          handleRedo();\r\n        } else {\r\n          // Handle Ctrl+Z (Windows) or Cmd+Z (Mac)\r\n          handleUndo();\r\n        }\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\r\n        // Add alternative redo shortcut (Ctrl+Y)\r\n        e.preventDefault();\r\n        handleRedo();\r\n      } else if (e.key === 'b') {\r\n        // Shortcut for brush (freeform)\r\n        e.preventDefault();\r\n        setIsLineModeActive(false);\r\n        setIsCircleModeActive(false);\r\n        setIsBucketFillModeActive(false);\r\n      }\r\n    };\r\n\r\n    const handleKeyUp = (e) => {\r\n      if (e.code === 'Space') {\r\n        e.preventDefault();\r\n        setIsSpacePressed(false);\r\n        // Add state to history when space drawing ends\r\n        if (isDrawingRef.current) {\r\n          addToHistory([...pixels]);\r\n        }\r\n        handleMouseUp();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, [isSpacePressed, pixels]); // Add pixels to dependencies\r\n\r\n  const handlePixelUpdate = (updateFn) => {\r\n    const newPixels = updateFn(pixels);\r\n    setPixels(newPixels);\r\n    // Remove addToHistory from here since we want to add it only on mouse up\r\n  };\r\n\r\n  const handleUndo = () => {\r\n    const previousState = undo();\r\n    if (previousState) {\r\n      setPixels(previousState);\r\n    }\r\n  };\r\n\r\n  const handleRedo = () => {\r\n    const nextState = redo();\r\n    if (nextState) {\r\n      setPixels(nextState);\r\n    }\r\n  };\r\n\r\n  const isFreeformActive = !isLineModeActive && !isCircleModeActive && \r\n                           !isBucketFillModeActive && !isRectangleModeActive;\r\n\r\n  const freeformMode = FreeformMode({\r\n    isActive: isFreeformActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    brushSize,\r\n    drawColor\r\n  });\r\n\r\n  const lineMode = LineMode({\r\n    isActive: isLineModeActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    onPreviewUpdate: setPreviewPixels,\r\n    drawColor  // Pass the color to line mode\r\n  });\r\n\r\n  const circleMode = CircleMode({\r\n    isActive: isCircleModeActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    onPreviewUpdate: setPreviewPixels,\r\n    drawColor  // Pass the color to circle mode\r\n  });\r\n\r\n  const bucketFillMode = BucketFillMode({\r\n    isActive: isBucketFillModeActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    drawColor  // Pass the color to bucket fill mode\r\n  });\r\n\r\n  const rectangleMode = RectangleMode({\r\n    isActive: isRectangleModeActive,\r\n    onPixelUpdate: handlePixelUpdate,\r\n    onPreviewUpdate: setPreviewPixels,\r\n    drawColor\r\n  });\r\n\r\n  const handleMouseDown = (index) => {\r\n    isDrawingRef.current = true;\r\n    \r\n    if (isBucketFillModeActive) {\r\n      // For bucket fill, execute fill immediately\r\n      bucketFillMode.handleFill(index, pixels);\r\n      addToHistory([...pixels]);\r\n      isDrawingRef.current = false;\r\n      return;\r\n    }\r\n    \r\n    if (isFreeformActive) {\r\n      // For freeform mode, draw immediately on click\r\n      const point = getCoordinates(index);\r\n      lastPointRef.current = point;\r\n      freeformMode.handleStart(index);\r\n    } else {\r\n      startPointRef.current = getCoordinates(index);\r\n      lastPointRef.current = getCoordinates(index);\r\n    }\r\n  };\r\n\r\n  const handleMouseEnter = (index) => {\r\n    if (!isDrawingRef.current) return;\r\n    \r\n    if (isFreeformActive) {\r\n      // For freeform mode\r\n      lastPointRef.current = freeformMode.handleDraw(lastPointRef.current, index);\r\n    } else if (isLineModeActive) {\r\n      // For line mode\r\n      lineMode.handlePreview(startPointRef.current, index);\r\n      lastPointRef.current = getCoordinates(index);\r\n    } else if (isCircleModeActive) {\r\n      // For circle mode\r\n      circleMode.handlePreview(startPointRef.current, index);\r\n      lastPointRef.current = getCoordinates(index);\r\n    } else if (isRectangleModeActive) {\r\n      // For rectangle mode\r\n      rectangleMode.handlePreview(startPointRef.current, index);\r\n      lastPointRef.current = getCoordinates(index);\r\n    }\r\n  };\r\n\r\n  const handleMouseUp = (event) => {\r\n    if (isDrawingRef.current) {\r\n      if ((isLineModeActive || isCircleModeActive || isRectangleModeActive) && \r\n          startPointRef.current && lastPointRef.current) {\r\n        \r\n        const endIndex = lastPointRef.current.y * 128 + lastPointRef.current.x;\r\n        let updatedPixels = [...pixels];\r\n        \r\n        if (isLineModeActive) {\r\n          const linePoints = lineMode.handleCommit(startPointRef.current, endIndex);\r\n          if (linePoints) {\r\n            linePoints.forEach(idx => {\r\n              updatedPixels[idx] = drawColor;\r\n            });\r\n          }\r\n        } else if (isCircleModeActive) {\r\n          const circlePoints = circleMode.handleCommit(startPointRef.current, endIndex);\r\n          if (circlePoints) {\r\n            circlePoints.forEach(idx => {\r\n              updatedPixels[idx] = drawColor;\r\n            });\r\n          }\r\n        } else if (isRectangleModeActive) {\r\n          const rectanglePoints = rectangleMode.handleCommit(startPointRef.current, endIndex);\r\n          if (rectanglePoints) {\r\n            rectanglePoints.forEach(idx => {\r\n              updatedPixels[idx] = drawColor;\r\n            });\r\n          }\r\n        }\r\n        \r\n        setPixels(updatedPixels);\r\n        setPreviewPixels(Array(8192).fill(false));\r\n        addToHistory(updatedPixels);\r\n      } else if (!isBucketFillModeActive) {\r\n        // For freeform, only save on mouse up\r\n        addToHistory([...pixels]);\r\n      }\r\n    }\r\n    \r\n    isDrawingRef.current = false;\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n  };\r\n\r\n  const handleReset = () => {\r\n    const newState = Array(8192).fill(false);\r\n    setPixels(newState);\r\n    setPreviewPixels(Array(8192).fill(false));\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n    isDrawingRef.current = false;\r\n    addToHistory(newState);\r\n  };\r\n\r\n  const handlePixelHover = (index) => {\r\n    currentIndexRef.current = index;\r\n    if (isDrawingRef.current || isSpacePressed) {\r\n      handleMouseEnter(index);\r\n    }\r\n  };\r\n\r\n  // This controls whether to show the brush size control\r\n  const showBrushSizeControl = isFreeformActive;\r\n\r\n  // Add this effect for handling the brush outline\r\n  useEffect(() => {\r\n    const handleMouseMove = (e) => {\r\n      if (!outlineRef.current) return;\r\n      \r\n      // Only show outline for freeform mode\r\n      if (isFreeformActive) {\r\n        const grid = document.querySelector('.pixel-grid');\r\n        if (!grid) return;\r\n        \r\n        const rect = grid.getBoundingClientRect();\r\n        \r\n        // Check if the mouse is within the grid boundaries\r\n        if (e.clientX < rect.left || e.clientX > rect.right || \r\n            e.clientY < rect.top || e.clientY > rect.bottom) {\r\n          outlineRef.current.style.display = 'none';\r\n          return;\r\n        }\r\n        \r\n        const mouseX = e.clientX - rect.left;\r\n        const mouseY = e.clientY - rect.top;\r\n        \r\n        // Calculate which pixel we're hovering over\r\n        const pixelX = Math.floor(mouseX / 8);\r\n        const pixelY = Math.floor(mouseY / 8);\r\n        \r\n        // Ensure we're within grid boundaries\r\n        if (pixelX < 0 || pixelX >= 128 || pixelY < 0 || pixelY >= 64) {\r\n          outlineRef.current.style.display = 'none';\r\n          return;\r\n        }\r\n        \r\n        // Store the current pixel index for consistent drawing\r\n        const currentIndex = pixelY * 128 + pixelX;\r\n        currentIndexRef.current = currentIndex;\r\n        \r\n        if (brushSize === 1) {\r\n          // For brush size 1, just show a simple pixel outline\r\n          outlineRef.current.innerHTML = '';\r\n          outlineRef.current.style.left = `${pixelX * 8}px`;\r\n          outlineRef.current.style.top = `${pixelY * 8}px`;\r\n          outlineRef.current.style.width = `8px`;\r\n          outlineRef.current.style.height = `8px`;\r\n          outlineRef.current.style.display = 'block';\r\n          outlineRef.current.style.border = `1px solid ${drawColor ? 'white' : 'red'}`;\r\n          outlineRef.current.style.borderRadius = '0'; // Ensure square shape\r\n        } else {\r\n          // Create a canvas-based outline for the diamond pattern\r\n          outlineRef.current.style.display = 'block';\r\n          outlineRef.current.style.border = 'none';\r\n          outlineRef.current.innerHTML = '';\r\n          \r\n          const diamondPixels = [];\r\n          \r\n          // Calculate points based on Manhattan distance (diamond pattern)\r\n          for (let y = -brushSize + 1; y < brushSize; y++) {\r\n            for (let x = -brushSize + 1; x < brushSize; x++) {\r\n              if (Math.abs(x) + Math.abs(y) < brushSize) {\r\n                const newX = pixelX + x;\r\n                const newY = pixelY + y;\r\n                \r\n                if (newX >= 0 && newX < 128 && newY >= 0 && newY < 64) {\r\n                  diamondPixels.push({ x: newX, y: newY });\r\n                }\r\n              }\r\n            }\r\n          }\r\n          \r\n          if (diamondPixels.length > 0) {\r\n            // Find bounds of the diamond\r\n            let minX = 128, minY = 64, maxX = 0, maxY = 0;\r\n            \r\n            diamondPixels.forEach(({x, y}) => {\r\n              minX = Math.min(minX, x);\r\n              minY = Math.min(minY, y);\r\n              maxX = Math.max(maxX, x);\r\n              maxY = Math.max(maxY, y);\r\n            });\r\n            \r\n            // Set up the canvas that will contain our outline\r\n            const canvas = document.createElement('canvas');\r\n            const width = (maxX - minX + 1) * 8;\r\n            const height = (maxY - minY + 1) * 8;\r\n            canvas.width = width;\r\n            canvas.height = height;\r\n            canvas.style.position = 'absolute';\r\n            canvas.style.left = '0';\r\n            canvas.style.top = '0';\r\n            \r\n            const ctx = canvas.getContext('2d');\r\n            ctx.strokeStyle = drawColor ? 'white' : 'red';\r\n            ctx.lineWidth = 1;\r\n            \r\n            // Only create paths for the outline (edges)\r\n            const visited = new Set();\r\n            const drawEdge = (x, y, side) => {\r\n              const key = `${x},${y},${side}`;\r\n              if (visited.has(key)) return;\r\n              visited.add(key);\r\n              \r\n              const pixelX = (x - minX) * 8;\r\n              const pixelY = (y - minY) * 8;\r\n              \r\n              if (side === 'top') {\r\n                ctx.moveTo(pixelX, pixelY);\r\n                ctx.lineTo(pixelX + 8, pixelY);\r\n              } else if (side === 'right') {\r\n                ctx.moveTo(pixelX + 8, pixelY);\r\n                ctx.lineTo(pixelX + 8, pixelY + 8);\r\n              } else if (side === 'bottom') {\r\n                ctx.moveTo(pixelX, pixelY + 8);\r\n                ctx.lineTo(pixelX + 8, pixelY + 8);\r\n              } else if (side === 'left') {\r\n                ctx.moveTo(pixelX, pixelY);\r\n                ctx.lineTo(pixelX, pixelY + 8);\r\n              }\r\n            };\r\n            \r\n            ctx.beginPath();\r\n            \r\n            // Draw only the outer edges\r\n            diamondPixels.forEach(({x, y}) => {\r\n              // Check each neighboring position\r\n              [\r\n                { dx: 0, dy: -1, side: 'top' },\r\n                { dx: 1, dy: 0, side: 'right' },\r\n                { dx: 0, dy: 1, side: 'bottom' },\r\n                { dx: -1, dy: 0, side: 'left' }\r\n              ].forEach(({dx, dy, side}) => {\r\n                const nx = x + dx;\r\n                const ny = y + dy;\r\n                const found = diamondPixels.some(p => p.x === nx && p.y === ny);\r\n                if (!found) {\r\n                  drawEdge(x, y, side);\r\n                }\r\n              });\r\n            });\r\n            \r\n            ctx.stroke();\r\n            \r\n            // Position the container and add the canvas\r\n            outlineRef.current.style.left = `${minX * 8}px`;\r\n            outlineRef.current.style.top = `${minY * 8}px`;\r\n            outlineRef.current.style.width = `${width}px`;\r\n            outlineRef.current.style.height = `${height}px`;\r\n            outlineRef.current.appendChild(canvas);\r\n          }\r\n        }\r\n      } else {\r\n        outlineRef.current.style.display = 'none';\r\n      }\r\n    };\r\n    \r\n    const handleMouseLeave = () => {\r\n      if (outlineRef.current) {\r\n        outlineRef.current.style.display = 'none';\r\n      }\r\n    };\r\n    \r\n    const grid = document.querySelector('.pixel-grid');\r\n    if (grid) {\r\n      grid.addEventListener('mousemove', handleMouseMove);\r\n      grid.addEventListener('mouseleave', handleMouseLeave);\r\n    }\r\n    \r\n    return () => {\r\n      if (grid) {\r\n        grid.removeEventListener('mousemove', handleMouseMove);\r\n        grid.removeEventListener('mouseleave', handleMouseLeave);\r\n      }\r\n    };\r\n  }, [brushSize, isFreeformActive, drawColor]); // Add drawColor to dependencies\r\n\r\n  // Add this function to toggle the draw color\r\n  const toggleDrawColor = () => {\r\n    setDrawColor(!drawColor);\r\n  };\r\n\r\n  // Modify the pixel click handler to use the stored index\r\n  const handlePixelClick = (event) => {\r\n    event.preventDefault();\r\n    \r\n    if (!currentIndexRef.current && currentIndexRef.current !== 0) return;\r\n    \r\n    handleMouseDown(currentIndexRef.current);\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      {/* ESP32 Button - fixed to top left */}\r\n      <div className=\"esp32-container\" style={{ \r\n        position: 'fixed', \r\n        top: '10px', \r\n        left: '10px', \r\n        zIndex: 1000 \r\n      }}>\r\n        <ESP32Connection pixelData={pixels} />\r\n      </div>\r\n      \r\n      {/* BMP Buttons - fixed to top right */}\r\n      <div className=\"bmp-container\" style={{ \r\n        position: 'fixed', \r\n        top: '10px', \r\n        right: '10px', \r\n        zIndex: 1000 \r\n      }}>\r\n        <BMPHandler pixelData={pixels} onPixelUpdate={setPixels} />\r\n      </div>\r\n\r\n      {/* Brush size control */}\r\n      <div className=\"brush-size-control\" style={{ visibility: showBrushSizeControl ? 'visible' : 'hidden' }}>\r\n        <label htmlFor=\"brushSize\" style={{ color: 'white', minWidth: '100px' }}>\r\n          Brush Size: {brushSize}\r\n        </label>\r\n        <input\r\n          type=\"range\"\r\n          id=\"brushSize\"\r\n          className=\"brush-size-slider\"\r\n          min=\"1\"\r\n          max=\"5\"\r\n          value={brushSize}\r\n          onChange={(e) => setBrushSize(Number(e.target.value))}\r\n        />\r\n      </div>\r\n      \r\n      {/* Mode buttons - properly positioned */}\r\n      <div style={{ \r\n        display: 'flex', \r\n        justifyContent: 'center', \r\n        width: '100%',\r\n        position: 'relative'\r\n      }}>\r\n        {/* This wrapper ensures buttons are centered correctly over the grid */}\r\n        <div className=\"mode-buttons-container\" style={{\r\n          position: 'relative',\r\n          left: '22px', /* Increased from 15px to 23px to shift buttons more to the right */\r\n          width: '1024px',\r\n          boxSizing: 'border-box',\r\n          marginLeft: 'auto',\r\n          marginRight: 'auto'\r\n        }}>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n              setPreviewPixels(Array(8192).fill(false));\r\n            }}\r\n            className={`mode-button ${isFreeformActive ? 'active' : ''}`}\r\n          >\r\n            {freeformMode.modeName}\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(true);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isLineModeActive ? 'active' : ''}`}\r\n          >\r\n            {lineMode.modeName}\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(true);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isCircleModeActive ? 'active' : ''}`}\r\n          >\r\n            {circleMode.modeName}\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(true);\r\n            }}\r\n            className={`mode-button ${isRectangleModeActive ? 'active' : ''}`}\r\n          >\r\n            {rectangleMode.modeName}\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(true);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isBucketFillModeActive ? 'active' : ''}`}\r\n          >\r\n            {bucketFillMode.modeName}\r\n          </button>\r\n          <button \r\n            onClick={handleUndo}\r\n            className=\"mode-button\"\r\n            disabled={!canUndo}\r\n            style={{ marginLeft: 'auto' }}\r\n          >\r\n            Undo\r\n          </button>\r\n          <button \r\n            onClick={handleRedo}\r\n            className=\"mode-button\"\r\n            disabled={!canRedo}\r\n          >\r\n            Redo\r\n          </button>\r\n        </div>\r\n      </div>\r\n      \r\n      <div className=\"drawing-area\">\r\n        {/* Color selection squares - left side of grid */}\r\n        <div className=\"color-selector\" style={{\r\n          display: 'flex',\r\n          flexDirection: 'column',\r\n          gap: '15px',\r\n          marginRight: '15px'\r\n        }}>\r\n          <div \r\n            onClick={() => setDrawColor(true)}\r\n            className=\"color-button\"\r\n            style={{\r\n              width: '30px',\r\n              height: '30px',\r\n              backgroundColor: '#fff',\r\n              border: drawColor ? '3px solid #2196F3' : '1px solid #666',\r\n              borderRadius: '4px',\r\n              cursor: 'pointer',\r\n              boxSizing: 'border-box',\r\n              boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\r\n            }}\r\n            title=\"White (Draw)\"\r\n          />\r\n          <div \r\n            onClick={() => setDrawColor(false)}\r\n            className=\"color-button\"\r\n            style={{\r\n              width: '30px',\r\n              height: '30px',\r\n              backgroundColor: '#000',\r\n              border: !drawColor ? '3px solid #ff4444' : '1px solid #666',\r\n              borderRadius: '4px',\r\n              cursor: 'pointer',\r\n              boxSizing: 'border-box',\r\n              boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\r\n            }}\r\n            title=\"Black (Eraser)\"\r\n          />\r\n        </div>\r\n        \r\n        <div \r\n          className=\"pixel-grid\"\r\n          onMouseUp={handleMouseUp}\r\n          onMouseLeave={handleMouseUp}\r\n          onDragStart={(e) => e.preventDefault()}\r\n          onContextMenu={(e) => e.preventDefault()}\r\n        >\r\n          {/* Brush outline */}\r\n          <div \r\n            className=\"brush-outline\" \r\n            ref={outlineRef}\r\n            style={{ \r\n              borderColor: drawColor ? 'white' : 'red'\r\n            }}\r\n          ></div>\r\n          \r\n          {/* Pixels */}\r\n          {pixels.map((isWhite, index) => (\r\n            <div\r\n              key={index}\r\n              className={`pixel ${\r\n                // Change the order: check previews first, then actual pixel state\r\n                previewPixels[index] === true ? 'white' :\r\n                previewPixels[index] === 'black-preview' ? 'black-preview' : \r\n                isWhite ? 'white' : ''\r\n              }`}\r\n              onMouseDown={(e) => {\r\n                e.preventDefault(); // Prevent dragging\r\n                handleMouseDown(index);\r\n              }}\r\n              onMouseEnter={() => handlePixelHover(index)}\r\n              draggable=\"false\"\r\n              style={{ \r\n                cursor: isFreeformActive ? 'none' : \r\n                        isBucketFillModeActive ? 'cell' : 'crosshair'\r\n              }}\r\n            />\r\n          ))}\r\n        </div>\r\n      </div>\r\n      \r\n      <ResetButton onReset={handleReset} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PixelGrid;","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\utils.js",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\LineMode.jsx",["109"],"import React from 'react';\r\n\r\nconst getCoordinates = (index) => ({\r\n  x: index % 128,\r\n  y: Math.floor(index / 128)\r\n});\r\n\r\nconst getIndex = (x, y) => y * 128 + x;\r\n\r\nconst drawLine = (start, end) => {\r\n  const points = [];\r\n  let x0 = start.x;\r\n  let y0 = start.y;\r\n  let x1 = end.x;\r\n  let y1 = end.y;\r\n\r\n  x0 = Math.max(0, Math.min(127, x0));\r\n  y0 = Math.max(0, Math.min(63, y0));\r\n  x1 = Math.max(0, Math.min(127, x1));\r\n  y1 = Math.max(0, Math.min(63, y1));\r\n\r\n  const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n\r\n  if (steep) {\r\n    [x0, y0] = [y0, x0];\r\n    [x1, y1] = [y1, x1];\r\n  }\r\n\r\n  if (x0 > x1) {\r\n    [x0, x1] = [x1, x0];\r\n    [y0, y1] = [y1, y0];\r\n  }\r\n\r\n  const dx = x1 - x0;\r\n  const dy = Math.abs(y1 - y0);\r\n  const yStep = y0 < y1 ? 1 : -1;\r\n  \r\n  let error = dx / 2;\r\n  let y = y0;\r\n\r\n  for (let x = x0; x <= x1; x++) {\r\n    const currentX = steep ? y : x;\r\n    const currentY = steep ? x : y;\r\n    const index = getIndex(currentX, currentY);\r\n    if (index >= 0 && index < 8192) {\r\n      points.push(index);\r\n    }\r\n    error -= dy;\r\n    if (error < 0) {\r\n      y += yStep;\r\n      error += dx;\r\n    }\r\n  }\r\n\r\n  return points;\r\n};\r\n\r\nconst LineMode = ({ isActive, onPixelUpdate, onPreviewUpdate, drawColor = true }) => {\r\n  const updateLine = (startPoint, endPoint) => {\r\n    if (!startPoint || !endPoint) return;\r\n    const linePoints = drawLine(startPoint, endPoint);\r\n    const newPreview = Array(8192).fill(false);\r\n    linePoints.forEach(idx => {\r\n      if (drawColor) {\r\n        newPreview[idx] = true;\r\n      } else {\r\n        newPreview[idx] = 'black-preview';\r\n      }\r\n    });\r\n    return newPreview;\r\n  };\r\n\r\n  const handlePreview = (startPoint, currentIndex) => {\r\n    if (!startPoint || typeof currentIndex !== 'number') return;\r\n    const currentPoint = getCoordinates(currentIndex);\r\n    const previewState = updateLine(startPoint, currentPoint);\r\n    onPreviewUpdate(() => previewState);\r\n  };\r\n\r\n  const handleCommit = (startPoint, endIndex) => {\r\n    if (!startPoint || typeof endIndex !== 'number') return;\r\n    const endPoint = getCoordinates(endIndex);\r\n    const linePoints = drawLine(startPoint, endPoint);\r\n    return linePoints;\r\n  };\r\n\r\n  return {\r\n    handlePreview,\r\n    handleCommit,\r\n    modeName: 'Line Mode',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default LineMode;","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\CircleMode.jsx",["110"],"import React from 'react';\r\n\r\nconst getCoordinates = (index) => ({\r\n  x: index % 128,\r\n  y: Math.floor(index / 128)\r\n});\r\n\r\nconst getIndex = (x, y) => y * 128 + x;\r\n\r\nconst drawCircle = (center, point) => {\r\n  const points = [];\r\n  const radius = Math.floor(Math.sqrt(\r\n    Math.pow(point.x - center.x, 2) + \r\n    Math.pow(point.y - center.y, 2)\r\n  ));\r\n\r\n  const actualCenter = center;\r\n\r\n  let x = radius;\r\n  let y = 0;\r\n  let error = 0;\r\n\r\n  while (x >= y) {\r\n    const coordinates = [\r\n      [actualCenter.x + x, actualCenter.y + y],\r\n      [actualCenter.x + y, actualCenter.y + x],\r\n      [actualCenter.x - y, actualCenter.y + x],\r\n      [actualCenter.x - x, actualCenter.y + y],\r\n      [actualCenter.x - x, actualCenter.y - y],\r\n      [actualCenter.x - y, actualCenter.y - x],\r\n      [actualCenter.x + y, actualCenter.y - x],\r\n      [actualCenter.x + x, actualCenter.y - y],\r\n    ];\r\n\r\n    coordinates.forEach(([px, py]) => {\r\n      if (px >= 0 && px < 128 && py >= 0 && py < 64) {\r\n        const index = getIndex(px, py);\r\n        if (index >= 0 && index < 8192) {\r\n          points.push(index);\r\n        }\r\n      }\r\n    });\r\n\r\n    y++;\r\n    error += 1 + 2 * y;\r\n    if (2 * (error - x) + 1 > 0) {\r\n      x--;\r\n      error += 1 - 2 * x;\r\n    }\r\n  }\r\n\r\n  return points;\r\n};\r\n\r\nconst CircleMode = ({ isActive, onPixelUpdate, onPreviewUpdate, drawColor = true }) => {\r\n  const updateCircle = (centerPoint, currentPoint) => {\r\n    if (!centerPoint || !currentPoint) return;\r\n    const circlePoints = drawCircle(centerPoint, currentPoint);\r\n    const newPreview = Array(8192).fill(false);\r\n    circlePoints.forEach(idx => {\r\n      newPreview[idx] = drawColor ? true : 'black-preview';\r\n    });\r\n    return newPreview;\r\n  };\r\n\r\n  const handlePreview = (centerPoint, currentIndex) => {\r\n    if (!centerPoint || typeof currentIndex !== 'number') return;\r\n    const currentPoint = getCoordinates(currentIndex);\r\n    const previewState = updateCircle(centerPoint, currentPoint);\r\n    onPreviewUpdate(() => previewState);\r\n  };\r\n\r\n  const handleCommit = (centerPoint, endIndex) => {\r\n    if (!centerPoint || typeof endIndex !== 'number') return;\r\n    const endPoint = getCoordinates(endIndex);\r\n    const circlePoints = drawCircle(centerPoint, endPoint);\r\n    return circlePoints;\r\n  };\r\n\r\n  return {\r\n    handlePreview,\r\n    handleCommit,\r\n    modeName: 'Circle Mode',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default CircleMode;","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\FreeFormMode.jsx",["111"],"import React from 'react';\r\nimport { getCoordinates, drawLine } from './utils';\r\n\r\nconst FreeformMode = ({ isActive, onPixelUpdate, brushSize, drawColor = true }) => {\r\n  const handleDraw = (lastPoint, currentIndex) => {\r\n    const currentPoint = getCoordinates(currentIndex);\r\n    if (lastPoint) {\r\n      const pointsToDraw = [];\r\n      drawLine(lastPoint, currentPoint).forEach(idx => {\r\n        pointsToDraw.push(idx);\r\n        const centerX = idx % 128;\r\n        const centerY = Math.floor(idx / 128);\r\n        for (let offset = 0; offset < brushSize; offset++) {\r\n          for (let i = -offset; i <= offset; i++) {\r\n            const points = [\r\n              { x: centerX + i, y: centerY - (brushSize - 1 - offset) },\r\n              { x: centerX + i, y: centerY + (brushSize - 1 - offset) },\r\n              { x: centerX - (brushSize - 1 - offset), y: centerY + i },\r\n              { x: centerX + (brushSize - 1 - offset), y: centerY + i }\r\n            ];\r\n            points.forEach(point => {\r\n              if (point.x >= 0 && point.x < 128 && point.y >= 0 && point.y < 64) {\r\n                const newIdx = point.y * 128 + point.x;\r\n                if (newIdx >= 0 && newIdx < 8192) {\r\n                  pointsToDraw.push(newIdx);\r\n                }\r\n              }\r\n            });\r\n          }\r\n        }\r\n      });\r\n\r\n      onPixelUpdate(prev => {\r\n        const newPixels = [...prev];\r\n        pointsToDraw.forEach(idx => {\r\n          if (idx >= 0 && idx < 8192) {\r\n            newPixels[idx] = drawColor;\r\n          }\r\n        });\r\n        return newPixels;\r\n      });\r\n    }\r\n    return currentPoint;\r\n  };\r\n\r\n  const handleStart = (index) => {\r\n    const pointsToDraw = [];\r\n    const centerX = index % 128;\r\n    const centerY = Math.floor(index / 128);\r\n    for (let offset = 0; offset < brushSize; offset++) {\r\n      for (let i = -offset; i <= offset; i++) {\r\n        const points = [\r\n          { x: centerX + i, y: centerY - (brushSize - 1 - offset) },\r\n          { x: centerX + i, y: centerY + (brushSize - 1 - offset) },\r\n          { x: centerX - (brushSize - 1 - offset), y: centerY + i },\r\n          { x: centerX + (brushSize - 1 - offset), y: centerY + i }\r\n        ];\r\n        points.forEach(point => {\r\n          if (point.x >= 0 && point.x < 128 && point.y >= 0 && point.y < 64) {\r\n            const newIdx = point.y * 128 + point.x;\r\n            if (newIdx >= 0 && newIdx < 8192) {\r\n              pointsToDraw.push(newIdx);\r\n            }\r\n          }\r\n        });\r\n      }\r\n    }\r\n\r\n    onPixelUpdate(prev => {\r\n      const newPixels = [...prev];\r\n      pointsToDraw.forEach(idx => {\r\n        if (idx >= 0 && idx < 8192) {\r\n          newPixels[idx] = drawColor;\r\n        }\r\n      });\r\n      return newPixels;\r\n    });\r\n  };\r\n\r\n  return {\r\n    handleDraw,\r\n    handleStart,\r\n    modeName: 'Freeform Mode',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default FreeformMode;","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\useUndoRedo.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\ResetButton.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\RectangleMode.jsx",["112"],"import React from 'react';\r\n\r\nconst getCoordinates = (index) => ({\r\n  x: index % 128,\r\n  y: Math.floor(index / 128)\r\n});\r\n\r\nconst getIndex = (x, y) => y * 128 + x;\r\n\r\nconst drawRectangle = (start, end) => {\r\n  const points = [];\r\n  const startX = Math.min(start.x, end.x);\r\n  const startY = Math.min(start.y, end.y);\r\n  const endX = Math.max(start.x, end.x);\r\n  const endY = Math.max(start.y, end.y);\r\n  \r\n  // Draw the rectangle perimeter\r\n  for (let x = startX; x <= endX; x++) {\r\n    // Draw top and bottom lines\r\n    if (startX <= x && x <= endX) {\r\n      if (startY >= 0 && startY < 64) {\r\n        const topIndex = getIndex(x, startY);\r\n        if (topIndex >= 0 && topIndex < 8192) points.push(topIndex);\r\n      }\r\n      \r\n      if (endY >= 0 && endY < 64) {\r\n        const bottomIndex = getIndex(x, endY);\r\n        if (bottomIndex >= 0 && bottomIndex < 8192) points.push(bottomIndex);\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Draw left and right lines (avoiding corners which are already drawn)\r\n  for (let y = startY + 1; y < endY; y++) {\r\n    // Draw left and right lines\r\n    if (startY < y && y < endY) {\r\n      if (startX >= 0 && startX < 128) {\r\n        const leftIndex = getIndex(startX, y);\r\n        if (leftIndex >= 0 && leftIndex < 8192) points.push(leftIndex);\r\n      }\r\n      \r\n      if (endX >= 0 && endX < 128) {\r\n        const rightIndex = getIndex(endX, y);\r\n        if (rightIndex >= 0 && rightIndex < 8192) points.push(rightIndex);\r\n      }\r\n    }\r\n  }\r\n  \r\n  return points;\r\n};\r\n\r\nconst RectangleMode = ({ isActive, onPixelUpdate, onPreviewUpdate, drawColor = true }) => {\r\n  const updateRectangle = (startPoint, endPoint) => {\r\n    if (!startPoint || !endPoint) return;\r\n    \r\n    const rectanglePoints = drawRectangle(startPoint, endPoint);\r\n    const newPreview = Array(8192).fill(false);\r\n    rectanglePoints.forEach(idx => {\r\n      newPreview[idx] = drawColor ? true : 'black-preview';\r\n    });\r\n    \r\n    return newPreview;\r\n  };\r\n\r\n  const handlePreview = (startPoint, currentIndex) => {\r\n    if (!startPoint || typeof currentIndex !== 'number') return;\r\n    const currentPoint = getCoordinates(currentIndex);\r\n    const previewState = updateRectangle(startPoint, currentPoint);\r\n    onPreviewUpdate(() => previewState);\r\n  };\r\n\r\n  const handleCommit = (startPoint, endIndex) => {\r\n    if (!startPoint || typeof endIndex !== 'number') return;\r\n    const endPoint = getCoordinates(endIndex);\r\n    const rectanglePoints = drawRectangle(startPoint, endPoint);\r\n    return rectanglePoints;\r\n  };\r\n\r\n  return {\r\n    handlePreview,\r\n    handleCommit,\r\n    modeName: 'Rectangle Mode',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default RectangleMode;","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\BucketFillMode.jsx",["113"],"import React from 'react';\r\n\r\nconst BucketFillMode = ({ isActive, onPixelUpdate, drawColor = true }) => {\r\n  const handleFill = (index, pixels) => {\r\n    const targetColor = pixels[index];\r\n    \r\n    if (targetColor === drawColor) return;\r\n    \r\n    const newPixels = [...pixels];\r\n    const width = 128;\r\n    const height = 64;\r\n    \r\n    if (drawColor === true) {\r\n      const stack = [index];\r\n      \r\n      while (stack.length > 0) {\r\n        const currentIndex = stack.pop();\r\n        \r\n        if (newPixels[currentIndex] === targetColor) {\r\n          newPixels[currentIndex] = drawColor;\r\n          \r\n          const x = currentIndex % width;\r\n          const y = Math.floor(currentIndex / width);\r\n          \r\n          if (x > 0 && newPixels[getIndex(x-1, y)] === targetColor) {\r\n            stack.push(getIndex(x-1, y));\r\n          }\r\n          if (x < width - 1 && newPixels[getIndex(x+1, y)] === targetColor) {\r\n            stack.push(getIndex(x+1, y));\r\n          }\r\n          if (y > 0 && newPixels[getIndex(x, y-1)] === targetColor) {\r\n            stack.push(getIndex(x, y-1));\r\n          }\r\n          if (y < height - 1 && newPixels[getIndex(x, y+1)] === targetColor) {\r\n            stack.push(getIndex(x, y+1));\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      const stack = [index];\r\n      const filledIndices = new Set();\r\n      \r\n      while (stack.length > 0) {\r\n        const currentIndex = stack.pop();\r\n        \r\n        if (newPixels[currentIndex] === targetColor && !filledIndices.has(currentIndex)) {\r\n          filledIndices.add(currentIndex);\r\n          \r\n          const x = currentIndex % width;\r\n          const y = Math.floor(currentIndex / width);\r\n          \r\n          if (x > 0 && newPixels[getIndex(x-1, y)] === targetColor) {\r\n            stack.push(getIndex(x-1, y));\r\n          }\r\n          if (x < width - 1 && newPixels[getIndex(x+1, y)] === targetColor) {\r\n            stack.push(getIndex(x+1, y));\r\n          }\r\n          if (y > 0 && newPixels[getIndex(x, y-1)] === targetColor) {\r\n            stack.push(getIndex(x, y-1));\r\n          }\r\n          if (y < height - 1 && newPixels[getIndex(x, y+1)] === targetColor) {\r\n            stack.push(getIndex(x, y+1));\r\n          }\r\n        }\r\n      }\r\n      \r\n      for (const idx of filledIndices) {\r\n        const x = idx % width;\r\n        const y = Math.floor(idx / width);\r\n        \r\n        const hasNonMatchingNeighbor = \r\n            (x > 0 && !filledIndices.has(getIndex(x-1, y)) && newPixels[getIndex(x-1, y)] !== targetColor) || \r\n            (x < width - 1 && !filledIndices.has(getIndex(x+1, y)) && newPixels[getIndex(x+1, y)] !== targetColor) ||\r\n            (y > 0 && !filledIndices.has(getIndex(x, y-1)) && newPixels[getIndex(x, y-1)] !== targetColor) ||\r\n            (y < height - 1 && !filledIndices.has(getIndex(x, y+1)) && newPixels[getIndex(x, y+1)] !== targetColor);\r\n            \r\n        if (!hasNonMatchingNeighbor) {\r\n          newPixels[idx] = drawColor;\r\n        }\r\n      }\r\n    }\r\n    \r\n    onPixelUpdate(() => newPixels);\r\n  };\r\n  \r\n  const getIndex = (x, y) => y * 128 + x;\r\n  \r\n  return {\r\n    handleFill,\r\n    modeName: 'Bucket Fill',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default BucketFillMode;","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\ESP32Connection.jsx",["114"],"import React, { useState, useEffect, useRef } from 'react';\r\n\r\nconst ESP32Connection = ({ pixelData }) => {\r\n  const [ipAddress, setIpAddress] = useState('');\r\n  const [connectionStatus, setConnectionStatus] = useState('Disconnected');\r\n  const [showSettings, setShowSettings] = useState(false);\r\n  const [autoUpdate, setAutoUpdate] = useState(false);\r\n  const previousPixelDataRef = useRef(null);\r\n  const updateIntervalRef = useRef(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  \r\n  useEffect(() => {\r\n    if (autoUpdate && ipAddress) {\r\n      updateIntervalRef.current = setInterval(() => {\r\n        if (!previousPixelDataRef.current || \r\n            !arraysEqual(pixelData, previousPixelDataRef.current)) {\r\n          sendToESP32(false);\r\n          previousPixelDataRef.current = [...pixelData];\r\n        }\r\n      }, 100);\r\n      \r\n      return () => {\r\n        if (updateIntervalRef.current) {\r\n          clearInterval(updateIntervalRef.current);\r\n        }\r\n      };\r\n    } else if (updateIntervalRef.current) {\r\n      clearInterval(updateIntervalRef.current);\r\n    }\r\n  }, [autoUpdate, ipAddress, pixelData]);\r\n  \r\n  const arraysEqual = (a, b) => {\r\n    if (a.length !== b.length) return false;\r\n    for (let i = 0; i < a.length; i++) {\r\n      if (a[i] !== b[i]) return false;\r\n    }\r\n    return true;\r\n  };\r\n  \r\n  const convertToRLE = (pixels) => {\r\n    const rle = [];\r\n    let currentValue = pixels[0] === true;\r\n    let count = 1;\r\n    \r\n    for (let i = 1; i < pixels.length; i++) {\r\n      if (pixels[i] === currentValue) {\r\n        count++;\r\n      } else {\r\n        rle.push({ value: currentValue, count });\r\n        currentValue = pixels[i] === true;\r\n        count = 1;\r\n      }\r\n    }\r\n    \r\n    rle.push({ value: currentValue, count });\r\n    return rle;\r\n  };\r\n  \r\n  const testConnection = async () => {\r\n    if (!ipAddress) return false;\r\n    \r\n    try {\r\n      setConnectionStatus('Testing connection...');\r\n      const response = await fetch(`http://${ipAddress}/ping`, { cache: 'no-store' });\r\n      \r\n      if (response.ok) {\r\n        setConnectionStatus('Connected');\r\n        setIsConnected(true);\r\n        return true;\r\n      } else {\r\n        setConnectionStatus('Connection failed');\r\n        setIsConnected(false);\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Connection test failed:\", error);\r\n      setConnectionStatus('Connection failed');\r\n      setIsConnected(false);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  const sendToESP32 = async (updateStatus = true) => {\r\n    if (!ipAddress) {\r\n      if (updateStatus) alert('Please enter ESP32 IP address');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      if (updateStatus) setConnectionStatus('Sending data...');\r\n      \r\n      let dataToSend;\r\n      const whitePixelCount = pixelData.filter(p => p === true).length;\r\n      \r\n      if (whitePixelCount < 100) {\r\n        dataToSend = {\r\n          pixels: pixelData.map((val, idx) => val === true ? idx : -1).filter(idx => idx !== -1)\r\n        };\r\n      } else {\r\n        dataToSend = {\r\n          data: convertToRLE(pixelData)\r\n        };\r\n      }\r\n      \r\n      const response = await fetch(`http://${ipAddress}/update`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(dataToSend),\r\n        cache: 'no-store'\r\n      });\r\n      \r\n      if (response.ok) {\r\n        if (updateStatus) setConnectionStatus('Connected');\r\n        setIsConnected(true);\r\n      } else {\r\n        if (updateStatus) setConnectionStatus('Update failed');\r\n        setIsConnected(false);\r\n      }\r\n    } catch (error) {\r\n      console.error('ESP32 connection error:', error);\r\n      if (updateStatus) setConnectionStatus('Error: ' + error.message);\r\n      setIsConnected(false);\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <div className=\"esp32-connection\">\r\n      <button \r\n        className=\"esp-button\"\r\n        onClick={() => setShowSettings(!showSettings)}\r\n        style={{ \r\n          position: 'relative',\r\n          backgroundColor: isConnected ? \r\n            (autoUpdate ? '#4CAF50' : '#2196F3') : '#555'\r\n        }}\r\n      >\r\n        ESP32 OLED\r\n        {autoUpdate && (\r\n          <span style={{ \r\n            position: 'absolute',\r\n            top: '-5px',\r\n            right: '-5px',\r\n            backgroundColor: '#ff4444',\r\n            color: 'white',\r\n            borderRadius: '50%',\r\n            width: '10px',\r\n            height: '10px'\r\n          }}></span>\r\n        )}\r\n      </button>\r\n      \r\n      {showSettings && (\r\n        <div className=\"esp-settings\">\r\n          <div>\r\n            <input\r\n              type=\"text\"\r\n              placeholder=\"ESP32 IP Address\"\r\n              value={ipAddress}\r\n              onChange={(e) => setIpAddress(e.target.value)}\r\n            />\r\n            <button \r\n              onClick={() => sendToESP32(true)}\r\n              disabled={!ipAddress}\r\n            >\r\n              Send to OLED\r\n            </button>\r\n          </div>\r\n          \r\n          <div style={{ \r\n            marginTop: '10px',\r\n            display: 'flex',\r\n            alignItems: 'center'\r\n          }}>\r\n            <input \r\n              type=\"checkbox\" \r\n              id=\"autoUpdate\" \r\n              checked={autoUpdate}\r\n              onChange={(e) => setAutoUpdate(e.target.checked)}\r\n              style={{ marginRight: '5px' }}\r\n              disabled={!isConnected}\r\n            />\r\n            <label htmlFor=\"autoUpdate\" style={{ color: '#ccc', fontSize: '14px' }}>\r\n              Auto-update (10 FPS)\r\n            </label>\r\n          </div>\r\n          \r\n          <div className=\"status\" style={{ \r\n            color: isConnected ? '#4CAF50' : '#ff6b6b'\r\n          }}>\r\n            Status: {connectionStatus}\r\n          </div>\r\n          \r\n          <div style={{ marginTop: '10px' }}>\r\n            <button \r\n              onClick={testConnection}\r\n              style={{ \r\n                fontSize: '12px', \r\n                padding: '4px 8px', \r\n                backgroundColor: '#555',\r\n                color: 'white',\r\n                border: 'none',\r\n                borderRadius: '4px'\r\n              }}\r\n              disabled={!ipAddress}\r\n            >\r\n              Test Connection\r\n            </button>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ESP32Connection;","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\BMPHandler.jsx",[],{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"119","severity":1,"message":"120","line":30,"column":6,"nodeType":"121","endLine":30,"endColumn":40,"suggestions":"122"},{"ruleId":"115","severity":1,"message":"123","line":32,"column":10,"nodeType":"117","messageId":"118","endLine":32,"endColumn":21},{"ruleId":"115","severity":1,"message":"124","line":32,"column":23,"nodeType":"117","messageId":"118","endLine":32,"endColumn":37},{"ruleId":"119","severity":1,"message":"125","line":81,"column":6,"nodeType":"121","endLine":81,"endColumn":30,"suggestions":"126"},{"ruleId":"115","severity":1,"message":"127","line":422,"column":9,"nodeType":"117","messageId":"118","endLine":422,"endColumn":24},{"ruleId":"115","severity":1,"message":"128","line":427,"column":9,"nodeType":"117","messageId":"118","endLine":427,"endColumn":25},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"115","severity":1,"message":"116","line":1,"column":8,"nodeType":"117","messageId":"118","endLine":1,"endColumn":13},{"ruleId":"119","severity":1,"message":"120","line":30,"column":6,"nodeType":"121","endLine":30,"endColumn":40,"suggestions":"129"},"no-unused-vars","'React' is defined but never used.","Identifier","unusedVar","react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'sendToESP32'. Either include it or remove the dependency array.","ArrayExpression",["130"],"'showOutline' is assigned a value but never used.","'setShowOutline' is assigned a value but never used.","React Hook useEffect has missing dependencies: 'addToHistory', 'handleMouseDown', 'handleMouseUp', 'handleRedo', and 'handleUndo'. Either include them or remove the dependency array.",["131"],"'toggleDrawColor' is assigned a value but never used.","'handlePixelClick' is assigned a value but never used.",["132"],{"desc":"133","fix":"134"},{"desc":"135","fix":"136"},{"desc":"133","fix":"137"},"Update the dependencies array to be: [autoUpdate, ipAddress, pixelData, sendToESP32]",{"range":"138","text":"139"},"Update the dependencies array to be: [addToHistory, handleMouseDown, handleMouseUp, handleRedo, handleUndo, isSpacePressed, pixels]",{"range":"140","text":"141"},{"range":"142","text":"139"},[1101,1135],"[autoUpdate, ipAddress, pixelData, sendToESP32]",[3152,3176],"[addToHistory, handleMouseDown, handleMouseUp, handleRedo, handleUndo, isSpacePressed, pixels]",[1101,1135]]