{"ast":null,"code":"import React from 'react';\nconst BucketFillMode = ({\n  isActive,\n  onPixelUpdate,\n  drawColor = true\n}) => {\n  const handleFill = (index, pixels) => {\n    const targetColor = pixels[index];\n    if (targetColor === drawColor) return;\n    const newPixels = [...pixels];\n    const width = 128;\n    const height = 64;\n    if (drawColor === true) {\n      const stack = [index];\n      while (stack.length > 0) {\n        const currentIndex = stack.pop();\n        if (newPixels[currentIndex] === targetColor) {\n          newPixels[currentIndex] = drawColor;\n          const x = currentIndex % width;\n          const y = Math.floor(currentIndex / width);\n          if (x > 0 && newPixels[getIndex(x - 1, y)] === targetColor) {\n            stack.push(getIndex(x - 1, y));\n          }\n          if (x < width - 1 && newPixels[getIndex(x + 1, y)] === targetColor) {\n            stack.push(getIndex(x + 1, y));\n          }\n          if (y > 0 && newPixels[getIndex(x, y - 1)] === targetColor) {\n            stack.push(getIndex(x, y - 1));\n          }\n          if (y < height - 1 && newPixels[getIndex(x, y + 1)] === targetColor) {\n            stack.push(getIndex(x, y + 1));\n          }\n        }\n      }\n    } else {\n      const stack = [index];\n      const filledIndices = new Set();\n      while (stack.length > 0) {\n        const currentIndex = stack.pop();\n        if (newPixels[currentIndex] === targetColor && !filledIndices.has(currentIndex)) {\n          filledIndices.add(currentIndex);\n          const x = currentIndex % width;\n          const y = Math.floor(currentIndex / width);\n          if (x > 0 && newPixels[getIndex(x - 1, y)] === targetColor) {\n            stack.push(getIndex(x - 1, y));\n          }\n          if (x < width - 1 && newPixels[getIndex(x + 1, y)] === targetColor) {\n            stack.push(getIndex(x + 1, y));\n          }\n          if (y > 0 && newPixels[getIndex(x, y - 1)] === targetColor) {\n            stack.push(getIndex(x, y - 1));\n          }\n          if (y < height - 1 && newPixels[getIndex(x, y + 1)] === targetColor) {\n            stack.push(getIndex(x, y + 1));\n          }\n        }\n      }\n      for (const idx of filledIndices) {\n        const x = idx % width;\n        const y = Math.floor(idx / width);\n        const hasNonMatchingNeighbor = x > 0 && !filledIndices.has(getIndex(x - 1, y)) && newPixels[getIndex(x - 1, y)] !== targetColor || x < width - 1 && !filledIndices.has(getIndex(x + 1, y)) && newPixels[getIndex(x + 1, y)] !== targetColor || y > 0 && !filledIndices.has(getIndex(x, y - 1)) && newPixels[getIndex(x, y - 1)] !== targetColor || y < height - 1 && !filledIndices.has(getIndex(x, y + 1)) && newPixels[getIndex(x, y + 1)] !== targetColor;\n        if (!hasNonMatchingNeighbor) {\n          newPixels[idx] = drawColor;\n        }\n      }\n    }\n    onPixelUpdate(() => newPixels);\n  };\n  const getIndex = (x, y) => y * 128 + x;\n  return {\n    handleFill,\n    modeName: 'Bucket Fill',\n    isActive\n  };\n};\n_c = BucketFillMode;\nexport default BucketFillMode;\nvar _c;\n$RefreshReg$(_c, \"BucketFillMode\");","map":{"version":3,"names":["React","BucketFillMode","isActive","onPixelUpdate","drawColor","handleFill","index","pixels","targetColor","newPixels","width","height","stack","length","currentIndex","pop","x","y","Math","floor","getIndex","push","filledIndices","Set","has","add","idx","hasNonMatchingNeighbor","modeName","_c","$RefreshReg$"],"sources":["C:/Users/wikx3/Documents/VS_code/React/ESP32_OLED_Drawing/src/components/pixelGrid/BucketFillMode.jsx"],"sourcesContent":["import React from 'react';\r\n\r\nconst BucketFillMode = ({ isActive, onPixelUpdate, drawColor = true }) => {\r\n  const handleFill = (index, pixels) => {\r\n    const targetColor = pixels[index];\r\n    \r\n    if (targetColor === drawColor) return;\r\n    \r\n    const newPixels = [...pixels];\r\n    const width = 128;\r\n    const height = 64;\r\n    \r\n    if (drawColor === true) {\r\n      const stack = [index];\r\n      \r\n      while (stack.length > 0) {\r\n        const currentIndex = stack.pop();\r\n        \r\n        if (newPixels[currentIndex] === targetColor) {\r\n          newPixels[currentIndex] = drawColor;\r\n          \r\n          const x = currentIndex % width;\r\n          const y = Math.floor(currentIndex / width);\r\n          \r\n          if (x > 0 && newPixels[getIndex(x-1, y)] === targetColor) {\r\n            stack.push(getIndex(x-1, y));\r\n          }\r\n          if (x < width - 1 && newPixels[getIndex(x+1, y)] === targetColor) {\r\n            stack.push(getIndex(x+1, y));\r\n          }\r\n          if (y > 0 && newPixels[getIndex(x, y-1)] === targetColor) {\r\n            stack.push(getIndex(x, y-1));\r\n          }\r\n          if (y < height - 1 && newPixels[getIndex(x, y+1)] === targetColor) {\r\n            stack.push(getIndex(x, y+1));\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      const stack = [index];\r\n      const filledIndices = new Set();\r\n      \r\n      while (stack.length > 0) {\r\n        const currentIndex = stack.pop();\r\n        \r\n        if (newPixels[currentIndex] === targetColor && !filledIndices.has(currentIndex)) {\r\n          filledIndices.add(currentIndex);\r\n          \r\n          const x = currentIndex % width;\r\n          const y = Math.floor(currentIndex / width);\r\n          \r\n          if (x > 0 && newPixels[getIndex(x-1, y)] === targetColor) {\r\n            stack.push(getIndex(x-1, y));\r\n          }\r\n          if (x < width - 1 && newPixels[getIndex(x+1, y)] === targetColor) {\r\n            stack.push(getIndex(x+1, y));\r\n          }\r\n          if (y > 0 && newPixels[getIndex(x, y-1)] === targetColor) {\r\n            stack.push(getIndex(x, y-1));\r\n          }\r\n          if (y < height - 1 && newPixels[getIndex(x, y+1)] === targetColor) {\r\n            stack.push(getIndex(x, y+1));\r\n          }\r\n        }\r\n      }\r\n      \r\n      for (const idx of filledIndices) {\r\n        const x = idx % width;\r\n        const y = Math.floor(idx / width);\r\n        \r\n        const hasNonMatchingNeighbor = \r\n            (x > 0 && !filledIndices.has(getIndex(x-1, y)) && newPixels[getIndex(x-1, y)] !== targetColor) || \r\n            (x < width - 1 && !filledIndices.has(getIndex(x+1, y)) && newPixels[getIndex(x+1, y)] !== targetColor) ||\r\n            (y > 0 && !filledIndices.has(getIndex(x, y-1)) && newPixels[getIndex(x, y-1)] !== targetColor) ||\r\n            (y < height - 1 && !filledIndices.has(getIndex(x, y+1)) && newPixels[getIndex(x, y+1)] !== targetColor);\r\n            \r\n        if (!hasNonMatchingNeighbor) {\r\n          newPixels[idx] = drawColor;\r\n        }\r\n      }\r\n    }\r\n    \r\n    onPixelUpdate(() => newPixels);\r\n  };\r\n  \r\n  const getIndex = (x, y) => y * 128 + x;\r\n  \r\n  return {\r\n    handleFill,\r\n    modeName: 'Bucket Fill',\r\n    isActive\r\n  };\r\n};\r\n\r\nexport default BucketFillMode;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module"}