[{"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\index.jsx":"1","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\App.jsx":"2","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\index.jsx":"3","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\utils.js":"4","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\BMPHandler.jsx":"5","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\ESP32Connection.jsx":"6","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\ResetButton.jsx":"7"},{"size":237,"mtime":1767772131817,"results":"8","hashOfConfig":"9"},{"size":182,"mtime":1767773703083,"results":"10","hashOfConfig":"9"},{"size":38240,"mtime":1767775911121,"results":"11","hashOfConfig":"9"},{"size":722,"mtime":1748162141872,"results":"12","hashOfConfig":"9"},{"size":4319,"mtime":1748164143556,"results":"13","hashOfConfig":"9"},{"size":6396,"mtime":1748164111550,"results":"14","hashOfConfig":"9"},{"size":1102,"mtime":1748164007844,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"j6pyvg",{"filePath":"19","messages":"20","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"23"},{"filePath":"24","messages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"26","messages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"28","messages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"30","usedDeprecatedRules":"18"},{"filePath":"31","messages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\index.jsx",[],["33","34"],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\App.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\index.jsx",["35"],"import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\r\nimport { drawLine } from './utils';\r\nimport ESP32Connection from '../ESP32Connection';\r\nimport BMPHandler from '../BMPHandler';\r\nimport ResetButton from './ResetButton';\r\n\r\nconst GRID_WIDTH = 128;\r\nconst GRID_HEIGHT = 64;\r\nconst PIXEL_SIZE = 8;\r\nconst TOTAL_PIXELS = GRID_WIDTH * GRID_HEIGHT;\r\n\r\nconst PixelGrid = () => {\r\n  // Use Uint8Array for better performance (0 = black, 1 = white)\r\n  const [pixels, setPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\r\n  const [previewPixels, setPreviewPixels] = useState(() => new Uint8Array(TOTAL_PIXELS));\r\n  \r\n  const [isLineModeActive, setIsLineModeActive] = useState(false);\r\n  const [isCircleModeActive, setIsCircleModeActive] = useState(false);\r\n  const [isBucketFillModeActive, setIsBucketFillModeActive] = useState(false);\r\n  const [isRectangleModeActive, setIsRectangleModeActive] = useState(false);\r\n  \r\n  const isDrawingRef = useRef(false);\r\n  const startPointRef = useRef(null);\r\n  const lastPointRef = useRef(null);\r\n  const [isSpacePressed, setIsSpacePressed] = useState(false);\r\n  const currentIndexRef = useRef(null);\r\n  const [brushSize, setBrushSize] = useState(1);\r\n  const [drawColor, setDrawColor] = useState(true);\r\n  \r\n  // Canvas refs\r\n  const canvasRef = useRef(null);\r\n  const brushCanvasRef = useRef(null);\r\n  const renderRequestRef = useRef(null);\r\n  const pixelsRef = useRef(pixels);\r\n  const previewPixelsRef = useRef(previewPixels);\r\n  \r\n  // FPS counter\r\n  const [fps, setFps] = useState(0);\r\n  const frameCountRef = useRef(0);\r\n  const lastFpsTimeRef = useRef(performance.now());\r\n\r\n  // History for undo/redo - optimized\r\n  const historyRef = useRef([new Uint8Array(TOTAL_PIXELS)]);\r\n  const historyIndexRef = useRef(0);\r\n  const [canUndo, setCanUndo] = useState(false);\r\n  const [canRedo, setCanRedo] = useState(false);\r\n\r\n  const addToHistory = useCallback((newState) => {\r\n    const newHistory = historyRef.current.slice(0, historyIndexRef.current + 1);\r\n    newHistory.push(new Uint8Array(newState));\r\n    if (newHistory.length > 100) newHistory.shift();\r\n    historyRef.current = newHistory;\r\n    historyIndexRef.current = newHistory.length - 1;\r\n    setCanUndo(historyIndexRef.current > 0);\r\n    setCanRedo(false);\r\n  }, []);\r\n\r\n  const undo = useCallback(() => {\r\n    if (historyIndexRef.current > 0) {\r\n      historyIndexRef.current--;\r\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\r\n      setPixels(state);\r\n      setCanUndo(historyIndexRef.current > 0);\r\n      setCanRedo(true);\r\n    }\r\n  }, []);\r\n\r\n  const redo = useCallback(() => {\r\n    if (historyIndexRef.current < historyRef.current.length - 1) {\r\n      historyIndexRef.current++;\r\n      const state = new Uint8Array(historyRef.current[historyIndexRef.current]);\r\n      setPixels(state);\r\n      setCanUndo(true);\r\n      setCanRedo(historyIndexRef.current < historyRef.current.length - 1);\r\n    }\r\n  }, []);\r\n\r\n  // Keep pixelsRef in sync\r\n  useEffect(() => {\r\n    pixelsRef.current = pixels;\r\n  }, [pixels]);\r\n  \r\n  useEffect(() => {\r\n    previewPixelsRef.current = previewPixels;\r\n  }, [previewPixels]);\r\n\r\n  // Optimized canvas render function\r\n  const renderCanvas = useCallback(() => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n    \r\n    const ctx = canvas.getContext('2d', { alpha: false });\r\n    const imageData = ctx.createImageData(GRID_WIDTH, GRID_HEIGHT);\r\n    const data = imageData.data;\r\n    \r\n    const currentPixels = pixelsRef.current;\r\n    const currentPreview = previewPixelsRef.current;\r\n    \r\n    for (let i = 0; i < TOTAL_PIXELS; i++) {\r\n      const offset = i * 4;\r\n      if (currentPreview[i] === 1) {\r\n        // White preview\r\n        data[offset] = 255;\r\n        data[offset + 1] = 255;\r\n        data[offset + 2] = 255;\r\n      } else if (currentPreview[i] === 2) {\r\n        // Black preview (dark gray for visibility)\r\n        data[offset] = 34;\r\n        data[offset + 1] = 34;\r\n        data[offset + 2] = 34;\r\n      } else if (currentPixels[i] === 1) {\r\n        // White pixel\r\n        data[offset] = 255;\r\n        data[offset + 1] = 255;\r\n        data[offset + 2] = 255;\r\n      } else {\r\n        // Black pixel (background)\r\n        data[offset] = 17;\r\n        data[offset + 1] = 17;\r\n        data[offset + 2] = 17;\r\n      }\r\n      data[offset + 3] = 255;\r\n    }\r\n    \r\n    ctx.putImageData(imageData, 0, 0);\r\n    \r\n    // FPS counting\r\n    frameCountRef.current++;\r\n    const now = performance.now();\r\n    if (now - lastFpsTimeRef.current >= 1000) {\r\n      setFps(frameCountRef.current);\r\n      frameCountRef.current = 0;\r\n      lastFpsTimeRef.current = now;\r\n    }\r\n  }, []);\r\n\r\n  // Schedule render with requestAnimationFrame\r\n  const scheduleRender = useCallback(() => {\r\n    if (renderRequestRef.current) return;\r\n    renderRequestRef.current = requestAnimationFrame(() => {\r\n      renderCanvas();\r\n      renderRequestRef.current = null;\r\n    });\r\n  }, [renderCanvas]);\r\n\r\n  // Render on pixel changes\r\n  useEffect(() => {\r\n    scheduleRender();\r\n  }, [pixels, previewPixels, scheduleRender]);\r\n\r\n  // Initial render\r\n  useEffect(() => {\r\n    renderCanvas();\r\n  }, [renderCanvas]);\r\n\r\n  const isFreeformActive = !isLineModeActive && !isCircleModeActive && \r\n                           !isBucketFillModeActive && !isRectangleModeActive;\r\n\r\n  // Drawing utility functions\r\n  const getLinePoints = useCallback((start, end) => {\r\n    const points = [];\r\n    let x0 = Math.max(0, Math.min(127, start.x));\r\n    let y0 = Math.max(0, Math.min(63, start.y));\r\n    let x1 = Math.max(0, Math.min(127, end.x));\r\n    let y1 = Math.max(0, Math.min(63, end.y));\r\n\r\n    const steep = Math.abs(y1 - y0) > Math.abs(x1 - x0);\r\n    if (steep) { [x0, y0] = [y0, x0]; [x1, y1] = [y1, x1]; }\r\n    if (x0 > x1) { [x0, x1] = [x1, x0]; [y0, y1] = [y1, y0]; }\r\n\r\n    const dx = x1 - x0;\r\n    const dy = Math.abs(y1 - y0);\r\n    const yStep = y0 < y1 ? 1 : -1;\r\n    let error = dx / 2;\r\n    let y = y0;\r\n\r\n    for (let x = x0; x <= x1; x++) {\r\n      const currentX = steep ? y : x;\r\n      const currentY = steep ? x : y;\r\n      const index = currentY * GRID_WIDTH + currentX;\r\n      if (index >= 0 && index < TOTAL_PIXELS) points.push(index);\r\n      error -= dy;\r\n      if (error < 0) { y += yStep; error += dx; }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  const getCirclePoints = useCallback((center, point) => {\r\n    const points = [];\r\n    const radius = Math.floor(Math.sqrt(\r\n      Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)\r\n    ));\r\n\r\n    let x = radius, y = 0, error = 0;\r\n    while (x >= y) {\r\n      const coords = [\r\n        [center.x + x, center.y + y], [center.x + y, center.y + x],\r\n        [center.x - y, center.y + x], [center.x - x, center.y + y],\r\n        [center.x - x, center.y - y], [center.x - y, center.y - x],\r\n        [center.x + y, center.y - x], [center.x + x, center.y - y],\r\n      ];\r\n      coords.forEach(([px, py]) => {\r\n        if (px >= 0 && px < GRID_WIDTH && py >= 0 && py < GRID_HEIGHT) {\r\n          points.push(py * GRID_WIDTH + px);\r\n        }\r\n      });\r\n      y++;\r\n      error += 1 + 2 * y;\r\n      if (2 * (error - x) + 1 > 0) { x--; error += 1 - 2 * x; }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  const getRectPoints = useCallback((start, end) => {\r\n    const points = [];\r\n    const startX = Math.max(0, Math.min(start.x, end.x));\r\n    const startY = Math.max(0, Math.min(start.y, end.y));\r\n    const endX = Math.min(127, Math.max(start.x, end.x));\r\n    const endY = Math.min(63, Math.max(start.y, end.y));\r\n    \r\n    for (let x = startX; x <= endX; x++) {\r\n      if (startY >= 0 && startY < GRID_HEIGHT) points.push(startY * GRID_WIDTH + x);\r\n      if (endY >= 0 && endY < GRID_HEIGHT && endY !== startY) points.push(endY * GRID_WIDTH + x);\r\n    }\r\n    for (let y = startY + 1; y < endY; y++) {\r\n      if (startX >= 0 && startX < GRID_WIDTH) points.push(y * GRID_WIDTH + startX);\r\n      if (endX >= 0 && endX < GRID_WIDTH && endX !== startX) points.push(y * GRID_WIDTH + endX);\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  // Get brush pattern points\r\n  const getBrushPoints = useCallback((centerX, centerY, size) => {\r\n    const points = [];\r\n    for (let offset = 0; offset < size; offset++) {\r\n      for (let i = -offset; i <= offset; i++) {\r\n        const coords = [\r\n          { x: centerX + i, y: centerY - (size - 1 - offset) },\r\n          { x: centerX + i, y: centerY + (size - 1 - offset) },\r\n          { x: centerX - (size - 1 - offset), y: centerY + i },\r\n          { x: centerX + (size - 1 - offset), y: centerY + i }\r\n        ];\r\n        coords.forEach(point => {\r\n          if (point.x >= 0 && point.x < GRID_WIDTH && point.y >= 0 && point.y < GRID_HEIGHT) {\r\n            points.push(point.y * GRID_WIDTH + point.x);\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return points;\r\n  }, []);\r\n\r\n  // Get coordinates from canvas position\r\n  const getCanvasCoordinates = useCallback((e) => {\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return null;\r\n    \r\n    const rect = canvas.getBoundingClientRect();\r\n    const scaleX = GRID_WIDTH / rect.width;\r\n    const scaleY = GRID_HEIGHT / rect.height;\r\n    \r\n    const x = Math.floor((e.clientX - rect.left) * scaleX);\r\n    const y = Math.floor((e.clientY - rect.top) * scaleY);\r\n    \r\n    return { x, y };\r\n  }, []);\r\n\r\n  // Bucket fill\r\n  const handleBucketFill = useCallback((index) => {\r\n    const currentPixels = pixelsRef.current;\r\n    const targetColor = currentPixels[index];\r\n    const fillColor = drawColor ? 1 : 0;\r\n    if (targetColor === fillColor) return;\r\n\r\n    const newPixels = new Uint8Array(currentPixels);\r\n    const stack = [index];\r\n    const visited = new Set();\r\n\r\n    while (stack.length > 0) {\r\n      const currentIndex = stack.pop();\r\n      if (visited.has(currentIndex) || newPixels[currentIndex] !== targetColor) continue;\r\n      visited.add(currentIndex);\r\n      newPixels[currentIndex] = fillColor;\r\n\r\n      const x = currentIndex % GRID_WIDTH;\r\n      const y = Math.floor(currentIndex / GRID_WIDTH);\r\n\r\n      if (x > 0) stack.push(currentIndex - 1);\r\n      if (x < GRID_WIDTH - 1) stack.push(currentIndex + 1);\r\n      if (y > 0) stack.push(currentIndex - GRID_WIDTH);\r\n      if (y < GRID_HEIGHT - 1) stack.push(currentIndex + GRID_WIDTH);\r\n    }\r\n\r\n    setPixels(newPixels);\r\n    addToHistory(newPixels);\r\n  }, [drawColor, addToHistory]);\r\n\r\n  // Mouse event handlers\r\n  const handleCanvasMouseDown = useCallback((e) => {\r\n    if (e.button !== 0) return;\r\n    \r\n    const coords = getCanvasCoordinates(e);\r\n    if (!coords) return;\r\n    \r\n    isDrawingRef.current = true;\r\n    \r\n    if (isBucketFillModeActive) {\r\n      // Only bucket fill if click is within grid\r\n      if (coords.x >= 0 && coords.x < GRID_WIDTH && coords.y >= 0 && coords.y < GRID_HEIGHT) {\r\n        const index = coords.y * GRID_WIDTH + coords.x;\r\n        currentIndexRef.current = index;\r\n        handleBucketFill(index);\r\n      }\r\n      isDrawingRef.current = false;\r\n      return;\r\n    }\r\n    \r\n    if (isFreeformActive) {\r\n      // Allow drawing even if mouse is outside grid - draw any pixels that fall within grid\r\n      lastPointRef.current = { x: coords.x, y: coords.y };\r\n      const points = getBrushPoints(coords.x, coords.y, brushSize);\r\n      if (points.length > 0) {\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          points.forEach(idx => { newPixels[idx] = drawColor ? 1 : 0; });\r\n          return newPixels;\r\n        });\r\n      }\r\n    } else {\r\n      startPointRef.current = coords;\r\n      lastPointRef.current = coords;\r\n    }\r\n  }, [isBucketFillModeActive, isFreeformActive, handleBucketFill, getCanvasCoordinates, getBrushPoints, brushSize, drawColor]);\r\n\r\n  const handleCanvasMouseMove = useCallback((e) => {\r\n    const coords = getCanvasCoordinates(e);\r\n    if (!coords) return;\r\n    \r\n    // Update brush outline\r\n    updateBrushOutline(e);\r\n    \r\n    if (!isDrawingRef.current) return;\r\n    \r\n    // If we're drawing but have no last point (we left the grid earlier), and now re-enter,\r\n    // draw a disconnected segment (no connecting line)\r\n    if (isFreeformActive && !lastPointRef.current) {\r\n      const currentPoints = getBrushPoints(coords.x, coords.y, brushSize);\r\n      if (currentPoints.length > 0) {\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          currentPoints.forEach(idx => {\r\n            if (idx >= 0 && idx < TOTAL_PIXELS) newPixels[idx] = drawColor ? 1 : 0;\r\n          });\r\n          return newPixels;\r\n        });\r\n        lastPointRef.current = { x: coords.x, y: coords.y };\r\n      }\r\n      return;\r\n    }\r\n    \r\n    if (isFreeformActive && lastPointRef.current) {\r\n      // Check if we have any pixels within the grid from the brush at current position\r\n      const currentPoints = getBrushPoints(coords.x, coords.y, brushSize);\r\n      const lastPoints = getBrushPoints(lastPointRef.current.x, lastPointRef.current.y, brushSize);\r\n      \r\n      // Determine if we should draw a connecting line or start fresh\r\n      const lastWasInGrid = lastPoints.length > 0;\r\n      const currentIsInGrid = currentPoints.length > 0;\r\n      \r\n      if (!currentIsInGrid) {\r\n        // Outside grid, just update position without drawing\r\n        lastPointRef.current = { x: coords.x, y: coords.y };\r\n      } else if (!lastWasInGrid) {\r\n        // Re-entering grid from outside - start fresh without connecting line\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          currentPoints.forEach(idx => {\r\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n              newPixels[idx] = drawColor ? 1 : 0;\r\n            }\r\n          });\r\n          return newPixels;\r\n        });\r\n        lastPointRef.current = { x: coords.x, y: coords.y };\r\n      } else {\r\n        // Both last and current positions are in grid - draw connecting line\r\n        // Only draw line between points that are both within reasonable grid bounds\r\n        const lastInBounds = lastPointRef.current.x >= -brushSize && lastPointRef.current.x < GRID_WIDTH + brushSize &&\r\n                             lastPointRef.current.y >= -brushSize && lastPointRef.current.y < GRID_HEIGHT + brushSize;\r\n        const currentInBounds = coords.x >= -brushSize && coords.x < GRID_WIDTH + brushSize &&\r\n                                coords.y >= -brushSize && coords.y < GRID_HEIGHT + brushSize;\r\n        \r\n        if (lastInBounds && currentInBounds) {\r\n          const linePoints = getLinePoints(lastPointRef.current, { x: coords.x, y: coords.y });\r\n          const allPoints = [];\r\n          linePoints.forEach(idx => {\r\n            const centerX = idx % GRID_WIDTH;\r\n            const centerY = Math.floor(idx / GRID_WIDTH);\r\n            if (centerX >= 0 && centerX < GRID_WIDTH && centerY >= 0 && centerY < GRID_HEIGHT) {\r\n              allPoints.push(...getBrushPoints(centerX, centerY, brushSize));\r\n            }\r\n          });\r\n          \r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            allPoints.forEach(idx => {\r\n              if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n                newPixels[idx] = drawColor ? 1 : 0;\r\n              }\r\n            });\r\n            return newPixels;\r\n          });\r\n        } else {\r\n          // If coordinates are too far out of bounds, just draw current position\r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            currentPoints.forEach(idx => {\r\n              if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n                newPixels[idx] = drawColor ? 1 : 0;\r\n              }\r\n            });\r\n            return newPixels;\r\n          });\r\n        }\r\n        lastPointRef.current = { x: coords.x, y: coords.y };\r\n      }\r\n    } else if (isLineModeActive && startPointRef.current) {\r\n      const points = getLinePoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    } else if (isCircleModeActive && startPointRef.current) {\r\n      const points = getCirclePoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    } else if (isRectangleModeActive && startPointRef.current) {\r\n      const points = getRectPoints(startPointRef.current, coords);\r\n      const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n      points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n      setPreviewPixels(newPreview);\r\n      lastPointRef.current = coords;\r\n    }\r\n  // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [isFreeformActive, isLineModeActive, isCircleModeActive, isRectangleModeActive,\r\n      getCanvasCoordinates, getBrushPoints, getLinePoints, getCirclePoints, getRectPoints,\r\n      brushSize, drawColor]);\r\n\r\n  const handleMouseUp = useCallback(() => {\r\n    if (!isDrawingRef.current) return;\r\n    \r\n    if ((isLineModeActive || isCircleModeActive || isRectangleModeActive) && \r\n        startPointRef.current && lastPointRef.current) {\r\n      \r\n      let points = [];\r\n      if (isLineModeActive) {\r\n        points = getLinePoints(startPointRef.current, lastPointRef.current);\r\n      } else if (isCircleModeActive) {\r\n        points = getCirclePoints(startPointRef.current, lastPointRef.current);\r\n      } else if (isRectangleModeActive) {\r\n        points = getRectPoints(startPointRef.current, lastPointRef.current);\r\n      }\r\n      \r\n      if (points.length > 0) {\r\n        setPixels(prev => {\r\n          const newPixels = new Uint8Array(prev);\r\n          points.forEach(idx => {\r\n            if (idx >= 0 && idx < TOTAL_PIXELS) {\r\n              newPixels[idx] = drawColor ? 1 : 0;\r\n            }\r\n          });\r\n          // Add to history after state update\r\n          setTimeout(() => addToHistory(newPixels), 0);\r\n          return newPixels;\r\n        });\r\n      }\r\n      setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n    } else if (isFreeformActive) {\r\n      addToHistory(pixelsRef.current);\r\n    }\r\n    \r\n    isDrawingRef.current = false;\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, isFreeformActive,\r\n      drawColor, getLinePoints, getCirclePoints, getRectPoints, addToHistory]);\r\n\r\n  // Global mouse events for drawing outside the grid\r\n  useEffect(() => {\r\n    const handleGlobalMouseMove = (e) => {\r\n      if (isDrawingRef.current && (isLineModeActive || isCircleModeActive || isRectangleModeActive)) {\r\n        const canvas = canvasRef.current;\r\n        if (!canvas) return;\r\n        \r\n        const rect = canvas.getBoundingClientRect();\r\n        const scaleX = GRID_WIDTH / rect.width;\r\n        const scaleY = GRID_HEIGHT / rect.height;\r\n        \r\n        // Allow coordinates outside the grid\r\n        const x = Math.floor((e.clientX - rect.left) * scaleX);\r\n        const y = Math.floor((e.clientY - rect.top) * scaleY);\r\n        const coords = { x, y };\r\n        \r\n        let points = [];\r\n        if (isLineModeActive && startPointRef.current) {\r\n          points = getLinePoints(startPointRef.current, coords);\r\n        } else if (isCircleModeActive && startPointRef.current) {\r\n          points = getCirclePoints(startPointRef.current, coords);\r\n        } else if (isRectangleModeActive && startPointRef.current) {\r\n          points = getRectPoints(startPointRef.current, coords);\r\n        }\r\n        \r\n        const newPreview = new Uint8Array(TOTAL_PIXELS);\r\n        points.forEach(idx => { newPreview[idx] = drawColor ? 1 : 2; });\r\n        setPreviewPixels(newPreview);\r\n        lastPointRef.current = coords;\r\n      }\r\n    };\r\n\r\n    const handleGlobalMouseUp = () => {\r\n      if (isDrawingRef.current) {\r\n        handleMouseUp();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleGlobalMouseMove);\r\n    window.addEventListener('mouseup', handleGlobalMouseUp);\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\r\n      window.removeEventListener('mouseup', handleGlobalMouseUp);\r\n    };\r\n  }, [isLineModeActive, isCircleModeActive, isRectangleModeActive, drawColor,\r\n      getLinePoints, getCirclePoints, getRectPoints, handleMouseUp]);\r\n\r\n  // Global freeform drawing while dragging outside the grid\r\n  useEffect(() => {\r\n    if (!isFreeformActive) return;\r\n\r\n    const handleGlobalFreeformMove = (e) => {\r\n      if (!isDrawingRef.current) return;\r\n      const canvas = canvasRef.current;\r\n      if (!canvas) return;\r\n\r\n      const rect = canvas.getBoundingClientRect();\r\n      const scaleX = GRID_WIDTH / rect.width;\r\n      const scaleY = GRID_HEIGHT / rect.height;\r\n\r\n      const x = Math.floor((e.clientX - rect.left) * scaleX);\r\n      const y = Math.floor((e.clientY - rect.top) * scaleY);\r\n\r\n      if (lastPointRef.current) {\r\n        const linePoints = getLinePoints(lastPointRef.current, { x, y });\r\n        const allPoints = [];\r\n        linePoints.forEach(idx => {\r\n          const centerX = idx % GRID_WIDTH;\r\n          const centerY = Math.floor(idx / GRID_WIDTH);\r\n          if (centerX >= 0 && centerX < GRID_WIDTH && centerY >= 0 && centerY < GRID_HEIGHT) {\r\n            allPoints.push(...getBrushPoints(centerX, centerY, brushSize));\r\n          }\r\n        });\r\n\r\n        if (allPoints.length > 0) {\r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            allPoints.forEach(idx => {\r\n              if (idx >= 0 && idx < TOTAL_PIXELS) newPixels[idx] = drawColor ? 1 : 0;\r\n            });\r\n            return newPixels;\r\n          });\r\n        }\r\n      } else {\r\n        // No last point (e.g., started outside and re-entered); just draw current brush overlap\r\n        const points = getBrushPoints(x, y, brushSize);\r\n        if (points.length > 0) {\r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            points.forEach(idx => {\r\n              if (idx >= 0 && idx < TOTAL_PIXELS) newPixels[idx] = drawColor ? 1 : 0;\r\n            });\r\n            return newPixels;\r\n          });\r\n        }\r\n      }\r\n\r\n      lastPointRef.current = { x, y };\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleGlobalFreeformMove);\r\n    return () => window.removeEventListener('mousemove', handleGlobalFreeformMove);\r\n  }, [isFreeformActive, brushSize, drawColor, getBrushPoints, drawLine]);\r\n\r\n  // Keyboard shortcuts\r\n  useEffect(() => {\r\n    const handleKeyDown = (e) => {\r\n      if (e.code === 'Space' && !isSpacePressed && currentIndexRef.current !== null) {\r\n        e.preventDefault();\r\n        setIsSpacePressed(true);\r\n        // Trigger drawing at current position\r\n        const index = currentIndexRef.current;\r\n        isDrawingRef.current = true;\r\n        if (isFreeformActive) {\r\n          const x = index % GRID_WIDTH;\r\n          const y = Math.floor(index / GRID_WIDTH);\r\n          lastPointRef.current = { x, y };\r\n          const points = getBrushPoints(x, y, brushSize);\r\n          setPixels(prev => {\r\n            const newPixels = new Uint8Array(prev);\r\n            points.forEach(idx => { newPixels[idx] = drawColor ? 1 : 0; });\r\n            return newPixels;\r\n          });\r\n        }\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {\r\n        e.preventDefault();\r\n        if (e.shiftKey) {\r\n          redo();\r\n        } else {\r\n          undo();\r\n        }\r\n      } else if ((e.ctrlKey || e.metaKey) && e.key === 'y') {\r\n        e.preventDefault();\r\n        redo();\r\n      } else if (e.key === 'b') {\r\n        e.preventDefault();\r\n        setIsLineModeActive(false);\r\n        setIsCircleModeActive(false);\r\n        setIsBucketFillModeActive(false);\r\n        setIsRectangleModeActive(false);\r\n      }\r\n    };\r\n\r\n    const handleKeyUp = (e) => {\r\n      if (e.code === 'Space') {\r\n        e.preventDefault();\r\n        setIsSpacePressed(false);\r\n        if (isDrawingRef.current) {\r\n          addToHistory(pixelsRef.current);\r\n          isDrawingRef.current = false;\r\n          lastPointRef.current = null;\r\n        }\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyDown);\r\n    window.addEventListener('keyup', handleKeyUp);\r\n\r\n    return () => {\r\n      window.removeEventListener('keydown', handleKeyDown);\r\n      window.removeEventListener('keyup', handleKeyUp);\r\n    };\r\n  }, [isSpacePressed, isFreeformActive, brushSize, drawColor, getBrushPoints, undo, redo, addToHistory]);\r\n\r\n  // Brush outline rendering\r\n  const updateBrushOutline = useCallback((e) => {\r\n    const brushCanvas = brushCanvasRef.current;\r\n    if (!brushCanvas || !isFreeformActive) {\r\n      if (brushCanvas) brushCanvas.style.display = 'none';\r\n      return;\r\n    }\r\n\r\n    const canvas = canvasRef.current;\r\n    if (!canvas) return;\r\n\r\n    const rect = canvas.getBoundingClientRect();\r\n    \r\n    // Calculate pixel position (allow outside bounds)\r\n    const scaleX = GRID_WIDTH / rect.width;\r\n    const scaleY = GRID_HEIGHT / rect.height;\r\n    const pixelX = Math.floor((e.clientX - rect.left) * scaleX);\r\n    const pixelY = Math.floor((e.clientY - rect.top) * scaleY);\r\n\r\n    const ctx = brushCanvas.getContext('2d');\r\n    ctx.clearRect(0, 0, brushCanvas.width, brushCanvas.height);\r\n    ctx.strokeStyle = drawColor ? '#fff' : '#f00';\r\n    ctx.lineWidth = 1;\r\n\r\n    if (brushSize === 1) {\r\n      // Only draw if any part would be visible in the grid\r\n      if (pixelX >= 0 && pixelX < GRID_WIDTH && pixelY >= 0 && pixelY < GRID_HEIGHT) {\r\n        ctx.strokeRect(pixelX * PIXEL_SIZE + 0.5, pixelY * PIXEL_SIZE + 0.5, PIXEL_SIZE - 1, PIXEL_SIZE - 1);\r\n      }\r\n    } else {\r\n      const diamondPixels = [];\r\n      for (let y = -brushSize + 1; y < brushSize; y++) {\r\n        for (let x = -brushSize + 1; x < brushSize; x++) {\r\n          if (Math.abs(x) + Math.abs(y) < brushSize) {\r\n            const newX = pixelX + x;\r\n            const newY = pixelY + y;\r\n            // Include pixels even outside grid for outline calculation\r\n            if (newX >= 0 && newX < GRID_WIDTH && newY >= 0 && newY < GRID_HEIGHT) {\r\n              diamondPixels.push({ x: newX, y: newY });\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      if (diamondPixels.length > 0) {\r\n        ctx.beginPath();\r\n        diamondPixels.forEach(({ x, y }) => {\r\n          [{ dx: 0, dy: -1, side: 'top' }, { dx: 1, dy: 0, side: 'right' },\r\n           { dx: 0, dy: 1, side: 'bottom' }, { dx: -1, dy: 0, side: 'left' }]\r\n          .forEach(({ dx, dy, side }) => {\r\n            const nx = x + dx;\r\n            const ny = y + dy;\r\n            if (!diamondPixels.some(p => p.x === nx && p.y === ny)) {\r\n              const px = x * PIXEL_SIZE;\r\n              const py = y * PIXEL_SIZE;\r\n              if (side === 'top') { ctx.moveTo(px, py); ctx.lineTo(px + PIXEL_SIZE, py); }\r\n              else if (side === 'right') { ctx.moveTo(px + PIXEL_SIZE, py); ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE); }\r\n              else if (side === 'bottom') { ctx.moveTo(px, py + PIXEL_SIZE); ctx.lineTo(px + PIXEL_SIZE, py + PIXEL_SIZE); }\r\n              else if (side === 'left') { ctx.moveTo(px, py); ctx.lineTo(px, py + PIXEL_SIZE); }\r\n            }\r\n          });\r\n        });\r\n        ctx.stroke();\r\n      }\r\n    }\r\n\r\n    brushCanvas.style.display = 'block';\r\n  }, [isFreeformActive, brushSize, drawColor]);\r\n\r\n  // Update brush outline on global mouse move for freeform mode\r\n  useEffect(() => {\r\n    if (!isFreeformActive) return;\r\n\r\n    const handleGlobalMouseMove = (e) => {\r\n      const canvas = canvasRef.current;\r\n      if (!canvas) return;\r\n\r\n      const rect = canvas.getBoundingClientRect();\r\n      // Determine if we're reasonably close to the canvas\r\n      const margin = brushSize * PIXEL_SIZE * 2; // Allow brush size distance from edges\r\n      if (\r\n        e.clientX >= rect.left - margin &&\r\n        e.clientX <= rect.right + margin &&\r\n        e.clientY >= rect.top - margin &&\r\n        e.clientY <= rect.bottom + margin\r\n      ) {\r\n        updateBrushOutline(e);\r\n      } else {\r\n        // Hide if too far from canvas and break any in-progress freeform stroke so re-entry doesn't connect\r\n        const brushCanvas = brushCanvasRef.current;\r\n        if (brushCanvas) brushCanvas.style.display = 'none';\r\n        if (isDrawingRef.current) {\r\n          lastPointRef.current = null;\r\n        }\r\n      }\r\n    };\r\n\r\n    window.addEventListener('mousemove', handleGlobalMouseMove);\r\n\r\n    return () => {\r\n      window.removeEventListener('mousemove', handleGlobalMouseMove);\r\n    };\r\n  }, [isFreeformActive, brushSize, updateBrushOutline, getBrushPoints, drawColor]);\r\n\r\n  // Allow drawing when the user presses outside the canvas if part of the brush overlaps the grid\r\n  useEffect(() => {\r\n    if (!isFreeformActive) return;\r\n\r\n    const handleGlobalMouseDown = (e) => {\r\n      if (e.button !== 0) return;\r\n      const canvas = canvasRef.current;\r\n      if (!canvas) return;\r\n\r\n      const rect = canvas.getBoundingClientRect();\r\n      const scaleX = GRID_WIDTH / rect.width;\r\n      const scaleY = GRID_HEIGHT / rect.height;\r\n      const pixelX = Math.floor((e.clientX - rect.left) * scaleX);\r\n      const pixelY = Math.floor((e.clientY - rect.top) * scaleY);\r\n\r\n      // Get brush pixels (this will only include points inside the grid)\r\n      const points = getBrushPoints(pixelX, pixelY, brushSize);\r\n      if (points.length === 0) return;\r\n\r\n      isDrawingRef.current = true;\r\n      currentIndexRef.current = points[0];\r\n\r\n      setPixels(prev => {\r\n        const newPixels = new Uint8Array(prev);\r\n        points.forEach(idx => {\r\n          if (idx >= 0 && idx < TOTAL_PIXELS) newPixels[idx] = drawColor ? 1 : 0;\r\n        });\r\n        return newPixels;\r\n      });\r\n\r\n      // Set last point to the clicked logical position (may be outside bounds)\r\n      lastPointRef.current = { x: pixelX, y: pixelY };\r\n    };\r\n\r\n    window.addEventListener('mousedown', handleGlobalMouseDown);\r\n    return () => window.removeEventListener('mousedown', handleGlobalMouseDown);\r\n  }, [isFreeformActive, brushSize, getBrushPoints, drawColor]);\r\n\r\n  const handleReset = useCallback(() => {\r\n    const newState = new Uint8Array(TOTAL_PIXELS);\r\n    setPixels(newState);\r\n    setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n    startPointRef.current = null;\r\n    lastPointRef.current = null;\r\n    isDrawingRef.current = false;\r\n    addToHistory(newState);\r\n  }, [addToHistory]);\r\n\r\n  // Convert Uint8Array to boolean array for ESP32Connection and BMPHandler compatibility\r\n  const pixelsAsBoolArray = useMemo(() => {\r\n    return Array.from(pixels).map(p => p === 1);\r\n  }, [pixels]);\r\n\r\n  const handleBMPPixelUpdate = useCallback((newPixels) => {\r\n    if (Array.isArray(newPixels)) {\r\n      const uint8Pixels = new Uint8Array(TOTAL_PIXELS);\r\n      newPixels.forEach((val, i) => {\r\n        uint8Pixels[i] = val ? 1 : 0;\r\n      });\r\n      setPixels(uint8Pixels);\r\n      addToHistory(uint8Pixels);\r\n    }\r\n  }, [addToHistory]);\r\n\r\n  const showBrushSizeControl = isFreeformActive;\r\n\r\n  return (\r\n    <div className=\"pixel-grid-container\">\r\n      {/* FPS Counter */}\r\n      <div style={{\r\n        position: 'absolute',\r\n        top: '10px',\r\n        left: '50%',\r\n        transform: 'translateX(-50%)',\r\n        backgroundColor: 'rgba(0,0,0,0.7)',\r\n        color: fps < 30 ? '#ff4444' : fps < 50 ? '#ffaa00' : '#44ff44',\r\n        padding: '5px 15px',\r\n        borderRadius: '4px',\r\n        fontFamily: 'monospace',\r\n        fontSize: '14px',\r\n        zIndex: 1001\r\n      }}>\r\n        FPS: {fps}\r\n      </div>\r\n\r\n      {/* ESP32 Button */}\r\n      <div className=\"esp32-container\" style={{ position: 'fixed', top: '10px', left: '10px', zIndex: 1000 }}>\r\n        <ESP32Connection pixelData={pixelsAsBoolArray} />\r\n      </div>\r\n      \r\n      {/* BMP Buttons */}\r\n      <div className=\"bmp-container\" style={{ position: 'fixed', top: '10px', right: '10px', zIndex: 1000 }}>\r\n        <BMPHandler pixelData={pixelsAsBoolArray} onPixelUpdate={handleBMPPixelUpdate} />\r\n      </div>\r\n\r\n      {/* Brush size control */}\r\n      <div className=\"brush-size-control\" style={{ visibility: showBrushSizeControl ? 'visible' : 'hidden' }}>\r\n        <label htmlFor=\"brushSize\" style={{ color: 'white', minWidth: '100px' }}>\r\n          Brush Size: {brushSize}\r\n        </label>\r\n        <input\r\n          type=\"range\"\r\n          id=\"brushSize\"\r\n          className=\"brush-size-slider\"\r\n          min=\"1\"\r\n          max=\"5\"\r\n          value={brushSize}\r\n          onChange={(e) => setBrushSize(Number(e.target.value))}\r\n        />\r\n      </div>\r\n      \r\n      {/* Mode buttons */}\r\n      <div style={{ display: 'flex', justifyContent: 'center', width: '100%', position: 'relative' }}>\r\n        <div className=\"mode-buttons-container\" style={{\r\n          position: 'relative', left: '22px', width: '1024px',\r\n          boxSizing: 'border-box', marginLeft: 'auto', marginRight: 'auto'\r\n        }}>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n              setPreviewPixels(new Uint8Array(TOTAL_PIXELS));\r\n            }}\r\n            className={`mode-button ${isFreeformActive ? 'active' : ''}`}\r\n          >\r\n            Freeform Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(true);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isLineModeActive ? 'active' : ''}`}\r\n          >\r\n            Line Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(true);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isCircleModeActive ? 'active' : ''}`}\r\n          >\r\n            Circle Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(false);\r\n              setIsRectangleModeActive(true);\r\n            }}\r\n            className={`mode-button ${isRectangleModeActive ? 'active' : ''}`}\r\n          >\r\n            Rectangle Mode\r\n          </button>\r\n          <button \r\n            onClick={() => {\r\n              setIsLineModeActive(false);\r\n              setIsCircleModeActive(false);\r\n              setIsBucketFillModeActive(true);\r\n              setIsRectangleModeActive(false);\r\n            }}\r\n            className={`mode-button ${isBucketFillModeActive ? 'active' : ''}`}\r\n          >\r\n            Bucket Fill\r\n          </button>\r\n          <button onClick={undo} className=\"mode-button\" disabled={!canUndo} style={{ marginLeft: 'auto' }}>\r\n            Undo\r\n          </button>\r\n          <button onClick={redo} className=\"mode-button\" disabled={!canRedo}>\r\n            Redo\r\n          </button>\r\n        </div>\r\n      </div>\r\n      \r\n      <div className=\"drawing-area\">\r\n        {/* Color selection */}\r\n        <div className=\"color-selector\" style={{ display: 'flex', flexDirection: 'column', gap: '15px', marginRight: '15px' }}>\r\n          <div \r\n            onClick={() => setDrawColor(true)}\r\n            style={{\r\n              width: '30px', height: '30px', backgroundColor: '#fff',\r\n              border: drawColor ? '3px solid #2196F3' : '1px solid #666',\r\n              borderRadius: '4px', cursor: 'pointer', boxSizing: 'border-box',\r\n              boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\r\n            }}\r\n            title=\"White (Draw)\"\r\n          />\r\n          <div \r\n            onClick={() => setDrawColor(false)}\r\n            style={{\r\n              width: '30px', height: '30px', backgroundColor: '#000',\r\n              border: !drawColor ? '3px solid #ff4444' : '1px solid #666',\r\n              borderRadius: '4px', cursor: 'pointer', boxSizing: 'border-box',\r\n              boxShadow: '0 2px 4px rgba(0,0,0,0.3)'\r\n            }}\r\n            title=\"Black (Eraser)\"\r\n          />\r\n        </div>\r\n        \r\n        {/* Canvas-based pixel grid */}\r\n        <div \r\n          className=\"canvas-container\"\r\n          style={{ position: 'relative', width: `${GRID_WIDTH * PIXEL_SIZE}px`, height: `${GRID_HEIGHT * PIXEL_SIZE}px` }}\r\n          onMouseDown={handleCanvasMouseDown}\r\n          onMouseMove={handleCanvasMouseMove}\r\n          onMouseUp={handleMouseUp}\r\n          onMouseLeave={() => {\r\n            if (brushCanvasRef.current) brushCanvasRef.current.style.display = 'none';\r\n            // When the mouse leaves the canvas while freeform-drawing, break the stroke so re-entry doesn't connect\r\n            if (isFreeformActive && isDrawingRef.current) {\r\n              lastPointRef.current = null;\r\n            }\r\n          }}\r\n          onContextMenu={(e) => e.preventDefault()}\r\n        >\r\n          <canvas\r\n            ref={canvasRef}\r\n            width={GRID_WIDTH}\r\n            height={GRID_HEIGHT}\r\n            style={{\r\n              width: '100%',\r\n              height: '100%',\r\n              imageRendering: 'pixelated',\r\n              cursor: isFreeformActive ? 'none' : isBucketFillModeActive ? 'cell' : 'crosshair',\r\n              border: '1px solid #666'\r\n            }}\r\n          />\r\n          <canvas\r\n            ref={brushCanvasRef}\r\n            width={GRID_WIDTH * PIXEL_SIZE}\r\n            height={GRID_HEIGHT * PIXEL_SIZE}\r\n            style={{\r\n              position: 'absolute',\r\n              top: 0,\r\n              left: 0,\r\n              width: '100%',\r\n              height: '100%',\r\n              pointerEvents: 'none',\r\n              display: 'none'\r\n            }}\r\n          />\r\n        </div>\r\n      </div>\r\n      \r\n      <ResetButton onReset={handleReset} />\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PixelGrid;\r\n","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\utils.js",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\BMPHandler.jsx",[],"C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\ESP32Connection.jsx",["36"],"import React, { useState, useEffect, useRef } from 'react';\r\n\r\nconst ESP32Connection = ({ pixelData }) => {\r\n  const [ipAddress, setIpAddress] = useState('');\r\n  const [connectionStatus, setConnectionStatus] = useState('Disconnected');\r\n  const [showSettings, setShowSettings] = useState(false);\r\n  const [autoUpdate, setAutoUpdate] = useState(false);\r\n  const previousPixelDataRef = useRef(null);\r\n  const updateIntervalRef = useRef(null);\r\n  const [isConnected, setIsConnected] = useState(false);\r\n  \r\n  useEffect(() => {\r\n    if (autoUpdate && ipAddress) {\r\n      updateIntervalRef.current = setInterval(() => {\r\n        if (!previousPixelDataRef.current || \r\n            !arraysEqual(pixelData, previousPixelDataRef.current)) {\r\n          sendToESP32(false);\r\n          previousPixelDataRef.current = [...pixelData];\r\n        }\r\n      }, 100);\r\n      \r\n      return () => {\r\n        if (updateIntervalRef.current) {\r\n          clearInterval(updateIntervalRef.current);\r\n        }\r\n      };\r\n    } else if (updateIntervalRef.current) {\r\n      clearInterval(updateIntervalRef.current);\r\n    }\r\n  }, [autoUpdate, ipAddress, pixelData]);\r\n  \r\n  const arraysEqual = (a, b) => {\r\n    if (a.length !== b.length) return false;\r\n    for (let i = 0; i < a.length; i++) {\r\n      if (a[i] !== b[i]) return false;\r\n    }\r\n    return true;\r\n  };\r\n  \r\n  const convertToRLE = (pixels) => {\r\n    const rle = [];\r\n    let currentValue = pixels[0] === true;\r\n    let count = 1;\r\n    \r\n    for (let i = 1; i < pixels.length; i++) {\r\n      if (pixels[i] === currentValue) {\r\n        count++;\r\n      } else {\r\n        rle.push({ value: currentValue, count });\r\n        currentValue = pixels[i] === true;\r\n        count = 1;\r\n      }\r\n    }\r\n    \r\n    rle.push({ value: currentValue, count });\r\n    return rle;\r\n  };\r\n  \r\n  const testConnection = async () => {\r\n    if (!ipAddress) return false;\r\n    \r\n    try {\r\n      setConnectionStatus('Testing connection...');\r\n      const response = await fetch(`http://${ipAddress}/ping`, { cache: 'no-store' });\r\n      \r\n      if (response.ok) {\r\n        setConnectionStatus('Connected');\r\n        setIsConnected(true);\r\n        return true;\r\n      } else {\r\n        setConnectionStatus('Connection failed');\r\n        setIsConnected(false);\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      console.error(\"Connection test failed:\", error);\r\n      setConnectionStatus('Connection failed');\r\n      setIsConnected(false);\r\n      return false;\r\n    }\r\n  };\r\n  \r\n  const sendToESP32 = async (updateStatus = true) => {\r\n    if (!ipAddress) {\r\n      if (updateStatus) alert('Please enter ESP32 IP address');\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      if (updateStatus) setConnectionStatus('Sending data...');\r\n      \r\n      let dataToSend;\r\n      const whitePixelCount = pixelData.filter(p => p === true).length;\r\n      \r\n      if (whitePixelCount < 100) {\r\n        dataToSend = {\r\n          pixels: pixelData.map((val, idx) => val === true ? idx : -1).filter(idx => idx !== -1)\r\n        };\r\n      } else {\r\n        dataToSend = {\r\n          data: convertToRLE(pixelData)\r\n        };\r\n      }\r\n      \r\n      const response = await fetch(`http://${ipAddress}/update`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify(dataToSend),\r\n        cache: 'no-store'\r\n      });\r\n      \r\n      if (response.ok) {\r\n        if (updateStatus) setConnectionStatus('Connected');\r\n        setIsConnected(true);\r\n      } else {\r\n        if (updateStatus) setConnectionStatus('Update failed');\r\n        setIsConnected(false);\r\n      }\r\n    } catch (error) {\r\n      console.error('ESP32 connection error:', error);\r\n      if (updateStatus) setConnectionStatus('Error: ' + error.message);\r\n      setIsConnected(false);\r\n    }\r\n  };\r\n  \r\n  return (\r\n    <div className=\"esp32-connection\">\r\n      <button \r\n        className=\"esp-button\"\r\n        onClick={() => setShowSettings(!showSettings)}\r\n        style={{ \r\n          position: 'relative',\r\n          backgroundColor: isConnected ? \r\n            (autoUpdate ? '#4CAF50' : '#2196F3') : '#555'\r\n        }}\r\n      >\r\n        ESP32 OLED\r\n        {autoUpdate && (\r\n          <span style={{ \r\n            position: 'absolute',\r\n            top: '-5px',\r\n            right: '-5px',\r\n            backgroundColor: '#ff4444',\r\n            color: 'white',\r\n            borderRadius: '50%',\r\n            width: '10px',\r\n            height: '10px'\r\n          }}></span>\r\n        )}\r\n      </button>\r\n      \r\n      {showSettings && (\r\n        <div className=\"esp-settings\">\r\n          <div>\r\n            <input\r\n              type=\"text\"\r\n              placeholder=\"ESP32 IP Address\"\r\n              value={ipAddress}\r\n              onChange={(e) => setIpAddress(e.target.value)}\r\n            />\r\n            <button \r\n              onClick={() => sendToESP32(true)}\r\n              disabled={!ipAddress}\r\n            >\r\n              Send to OLED\r\n            </button>\r\n          </div>\r\n          \r\n          <div style={{ \r\n            marginTop: '10px',\r\n            display: 'flex',\r\n            alignItems: 'center'\r\n          }}>\r\n            <input \r\n              type=\"checkbox\" \r\n              id=\"autoUpdate\" \r\n              checked={autoUpdate}\r\n              onChange={(e) => setAutoUpdate(e.target.checked)}\r\n              style={{ marginRight: '5px' }}\r\n              disabled={!isConnected}\r\n            />\r\n            <label htmlFor=\"autoUpdate\" style={{ color: '#ccc', fontSize: '14px' }}>\r\n              Auto-update (10 FPS)\r\n            </label>\r\n          </div>\r\n          \r\n          <div className=\"status\" style={{ \r\n            color: isConnected ? '#4CAF50' : '#ff6b6b'\r\n          }}>\r\n            Status: {connectionStatus}\r\n          </div>\r\n          \r\n          <div style={{ marginTop: '10px' }}>\r\n            <button \r\n              onClick={testConnection}\r\n              style={{ \r\n                fontSize: '12px', \r\n                padding: '4px 8px', \r\n                backgroundColor: '#555',\r\n                color: 'white',\r\n                border: 'none',\r\n                borderRadius: '4px'\r\n              }}\r\n              disabled={!ipAddress}\r\n            >\r\n              Test Connection\r\n            </button>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ESP32Connection;","C:\\Users\\wikx3\\Documents\\VS_code\\React\\ESP32_OLED_Drawing\\src\\components\\pixelGrid\\ResetButton.jsx",[],{"ruleId":"37","replacedBy":"38"},{"ruleId":"39","replacedBy":"40"},{"ruleId":"41","severity":1,"message":"42","line":593,"column":6,"nodeType":"43","endLine":593,"endColumn":72,"suggestions":"44"},{"ruleId":"41","severity":1,"message":"45","line":30,"column":6,"nodeType":"43","endLine":30,"endColumn":40,"suggestions":"46"},"no-native-reassign",["47"],"no-negated-in-lhs",["48"],"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'getLinePoints'. Either include it or remove the dependency array. Outer scope values like 'drawLine' aren't valid dependencies because mutating them doesn't re-render the component.","ArrayExpression",["49"],"React Hook useEffect has a missing dependency: 'sendToESP32'. Either include it or remove the dependency array.",["50"],"no-global-assign","no-unsafe-negation",{"desc":"51","fix":"52"},{"desc":"53","fix":"54"},"Update the dependencies array to be: [isFreeformActive, brushSize, drawColor, getBrushPoints, getLinePoints]",{"range":"55","text":"56"},"Update the dependencies array to be: [autoUpdate, ipAddress, pixelData, sendToESP32]",{"range":"57","text":"58"},[22549,22615],"[isFreeformActive, brushSize, drawColor, getBrushPoints, getLinePoints]",[1101,1135],"[autoUpdate, ipAddress, pixelData, sendToESP32]"]